{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python for Humanists Digital Humanists are individuals with technical skills and critical awareness. By combining the critical thinking and social consciousness rooted in social theory and humanist thougth with the technical know-how rooted in computer science and software development, digital humanists can help make our technologically saturated society more just, humane, and good. This text is designed to help digital humanists learn the Python programming language from a humanist perspective. Along with learning the syntax and design patterns, readers will be encouraged to consider what the software they develop does to the human society that it serves. This is very much a survey text, and I would strongly encourage readers to also visit Python for Everybody For the exercises in this text, starter-code is available. Please feel free to clone it here . About the Author I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids. Acknowledgements This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License .","title":"Home"},{"location":"#python-for-humanists","text":"Digital Humanists are individuals with technical skills and critical awareness. By combining the critical thinking and social consciousness rooted in social theory and humanist thougth with the technical know-how rooted in computer science and software development, digital humanists can help make our technologically saturated society more just, humane, and good. This text is designed to help digital humanists learn the Python programming language from a humanist perspective. Along with learning the syntax and design patterns, readers will be encouraged to consider what the software they develop does to the human society that it serves. This is very much a survey text, and I would strongly encourage readers to also visit Python for Everybody For the exercises in this text, starter-code is available. Please feel free to clone it here .","title":"Python for Humanists"},{"location":"#about-the-author","text":"I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids.","title":"About the Author"},{"location":"#acknowledgements","text":"This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License .","title":"Acknowledgements"},{"location":"ch1/","text":"Computers and You Welcome to Python for Humanists. This first chapter will introduce you to basic architecture of computers and the basics of setting up your development environment. By the end of this chapter, you'll have exercises that will ask you to walk through getting your development environment set up and ready to go. Computer Architecture If you were to open up your computer, and I do recommend that you do so someday, you'll see a bunch of silicone chips and wires and tower looking things. Whenever we use our computer, regardless of how fancy and complex the output on our screen might be or the calculations that the machine can accomplish, all that is happening inside the computer is a bunch of electricity flowing across the metal in particular patterns that are meaningful and useful. The various components work together to create patterns that achieve whatever commands we or some developer have provided to the machine. To understand how Python is working and to understand Concepts in Computing, it is useful to know the anatomy of a computer. There are very many types of computers from the system in your car to your smartphone to your desktop to your digital watch. In a nutshell, computers are machines that take some sort of input, do some calculations on those input, and finally return some sort of output. A simple calculator, for instance, takes numbers and operators as inputs, processes those inputs by performing the input operators, and finally returns the result of that operation as an output. More complicated computers, like a smartphone, just take different types of inputs and perform more complicated processes. Since all computers fundamentally do the same thing in varying degrees of complexities, they all have a basic set of components: Input and Output devices Processing Device Memory (Optional) Storage Let's start with the Input and Output (I/O) devices. I/O devices are the features that allow the computer to interact with the world. Input devices include keyboards, mice, touch screens, and so on. Each input device takes a specific type of data. Output devices include printers, monitors, speakers, and so on. Each output device returns a specific type of data. Computers might have various I/O devices, sometimes built in, sometimes peripheral, but they all will have some sort of I/O otherwise they won't be able to take data and return results. Memory is the next step. Memory is the space where data is stored when it is not immediately being processed. For instance, when you work in a Word document, your document is read from the long term storage to the memory. As you make changes, those changes are written to the memory, and when you \"Save\" the version of the document is written back to the long term storage medium. Memory is volatile, which means that when the computer shuts down or loses power, the memory is erased. The solution to this is long term storage, which will be covered below. If you've ever had the experience of working on a file and losing unsaved changes, it happened because those changes had not yet been written to long term storage. Processing devices are the processor. Processors come in various flavors and functionality, but they are responsible for managing all of the components of the computer (the memory and the I/O devices), and for running calculations. Every operation in a computer is the result of calculations done in binary. The processor is doing that constantly, often several calculations at once if you have a processor capable of multi-threading. (Optional) Most computers also have some form of long term storage. This might be a hard disk drive, a solid state drive, or a memory card. These are physical media of various sorts that can have data written to them in a permanent or semi-permanent state. In the case of hard disk drives, data is stored as charges written to magnetic platters. On larger computers like laptops and desktops, these components are usually connected through a motherboard that helps orchestrate the processes. When we begin programming, it is useful to consider what part of the physical machine is performing a particular thing because it perhaps will help you visualize and make sense of what's going on. This is especially true when we get to variables and files. Interacting with variables means we are interacting with memory and interacting with files we are interacting usually with long term storage. Beyond the Graphical User Interface Most of the time when you interact with a computer, you probably are doing so through what is called a Graphical User Interface (GUI). When you open your web browser, for instance, you have a window with URL bar and menus and a main pane where the website code is rendered for your enjoyment. Likewise, when you search for files, you are probably using File Explorer or Finder, both of which are GUIs for interacting with the file system. GUIs allow you to use your mouse and keyboard to interact with the computer through visual icons and fields. I cannot overstate the importance of GUIs to the proliferation of computers. Without a GUI, you would either have to use a command line interface or punch cards to use a computer. GUI's allow non-experts to gain access without facing the steep learning curve of learning commands or code or punch card patterns. Instead, you can issue commands to the computer through an intuitive interface of icons, labelled fields, and so on. That being said, GUIs limit the efficiency at which you can work and frequently limit your ability to issue commands to the computer. This means that if you want to move from being a user towards being a maker or developer (one who uses the computer as is, to one who might explore what the computer can be made to do) is to become familiar with what is called a Command Line Interface (CLI). There are numerous CLIs ranging from DOS Prompt, Windows Command LIne, Powershell, Bash, etc. Even Python has a CLI, which allows you to issue Python commands directly to the Python interpreter (this will make more sense next chapter). CLIs allow the user to issue text based commands to the system (whichever system reads and interprets the commands). So, just as I could use a GUI to view, create, open, move, and delete files and folders in the above example by clicking on buttons and icons in the GUI to issue commands to the Operating System, so too can I use the CLI to view, create, open, move, and delete files and folders by entering commands as text via the keyboard into the CLI. The particular CLI we will be using in this class is BASH . We are learning Bash instead of Command Prompt or Powershell because it is a very powerful \"shell\" that is built into all unix operating systems (Mac and Linux); however, at the time of writing, Mac is beginning to use Zsh instead, but the commands are largely the same so no worries. It is the standard CLI that you will encounter on nearly all web servers and will give you the most bang for your buck. Plus, it can be installed on Windows, and many bash commands are the saem in Powershell. Learning a CLI involves learning a set of commands (or \"magic words\") that are available. You won't need to memorize them all, but by spending time using the CLI, you will gradually pick them up. Why would we take the time to learn a CLI when you're already proficient at using a GUI? Great question! GUIs are limited to the set of actions that the GUI designer thinks that most users will need. The actions are usually triggered by a mouse click, but advanced users will likely learn Hotkeys or keyboard shortcuts to make their work faster. However, the program often has a number of other commands or actions that are difficult to access via the GUI. Using a CLI often gives you more power and control over what the program is doing. GUIs involve using a mouse or tabbing through buttons with the keyboard. This means that they are much slower to do complicated tasks. Once you become familiar with a CLI, you will be much faster at doing the same kinds of tasks, and many tasks are less complicated using a CLI than they are using a graphical interface. Let's say you decide to set up an application on a web server. First, that server exists in some server farm somewhere and the company that provides it allows you to access it remotely over a secure connection. That web server probably will not have a Desktop environment (a GUI for an operating system). Instead, it will have a CLI environment, and you will access it through a secure shell (ssh). Let's ignore the fact that the server will require that you use the CLI and think about how we might connect to that server remotely. To connect to that server, you set up an ssh connection. There are GUI programs that allow you to do this, like Putty, for instance. To do this, you must first install the program, then set up a connection through the form that the GUI provides and finally click the connect button. In Bash, however, all you have to do is type ssh username@server.com with any additional settings that might be necessary (e.g. you might need to type ssh -p 5257 username@server.com if you want to specify a particular port to connect to) and then hit enter. Likewise, many coding related applications have poor GUIs. Python's package manager (pip) for example only works in CLI. One word of caution: CLIs give you greater power and control over the machine, but that means you can mess things up pretty severely. I recommend knowing what a command will do before you execute it. This is particularly important if you are reading advice from StackOverflow or some other online forum that answers questions. Likewise, if you are not already practicing good backup habits, not would be an ideal time to start because it is possible to break things or lose data (e.g. rm -rf /home/ would delete all files installed by users without asking if you're sure). Installing Bash So if you're a Mac or Linux User, you can skip this section. You already have Bash or Zsh installed on your computer. In Mac, you'll need to locate the application called Terminal. In Linux, usually the hotkeys to open a terminal is CTRL+ALT+T. If you're a Windows 10 user, you have two options. You can set up Windows Subsystem Linux. Since developers frequently prefer developing in a Unix environment like Mac or Linux (for many reasons which I won't go into here), Windows has built a subsystem that allows you to use Linux within your Windows operating system. I use this personally when I'm using my Windows computer, but it is a little bit fiddly and permissions can be weird. The option I will walk you through here is using Git Bash. Git is a version control program that we'll talk about in a little bit, but they have created a version of Bash that works on Windows. It's lovely. head over to Git's download page and select the appropriate version of Git Bash to download. Run the installer that you just downloaded. I use the default settings, but if you want to customize the installation, feel free. Open Git Bash and a terminal will open up. Hooray. A taste of Bash If you want a great tutorial on how to use Bash and even write scripts in the Bash scripting language, check out Bash Academy for a really detailed tutorial of Bash. I strongly recommend this because knowing your way around a CLI will make the work of this program much easier. I will give you a quick overview here of Bash. I'd encourage you to follow along on your computer. When you open a Bash terminal, you will see a window with a black background and some text. Mine lookes like this: user1@DESKTOP-61VJ97U:~$ _ This is the prompt, and you'll see a cursor blinking right after the dollar sign. You can type commands here. Throughout this program, I will share code snippets and when I do, I will simply start with either ~$ or (env) ~$ So if you are following along and it looks slightly different, just know I'm cutting out the username and host for brevity sake. The first thing to learn about the CLI is how to navigate. Wherever the prompt is \"located\" in your file tree is where you will execute your commands. For example, if I am in a directory called \"projects\" and my prompt is set in that directory, then when I create a file it will be created within that directory. The first command we need to learn is pwd which stands for \"print working directory.\" The working directory is where my terminal is currently working. For example, when I open a terminal, it automatically opens to the home directory, represented by the tilda (~). So when I issue the command: ~$ pwd /home/user1 This means that my current working directory is /home/user1 and any command I issue, unless I specify otherwise, will be executed in that directory. Next, I will use the ls command to show you what directories reside within my home directory: ~$ ls Books Projects dylanmedina experiments Within my home directory I have Books, Projects, dylanmedina, and experiments. These are all directories that I can navigate into. These first two commands are crucial because they give me the location and context in which my CLI is operating. Now, let's say we're starting a new project, like this lesson. I might make a new directory for that project. To do so, I need to create a new directory and give it a name. The command is mkdir for \"make directory.\" You follow that by the name of the directory. One word on names: spaces don't work because each word of a command is separated by a space. So if I wanted to create a directory called Python for Humanists, and I issued the command ~$ mkdir Python for Humanists it would create three directories. One workaround is surround the name with quotation marks, but it's easier to just use names that don't have spaces. So let's go: ~$ mkdir pythonHumanist ~$ ls Books Projects dylanmedina experiments pythonHumanist You'll see, I created a directory called pythonHumanist and then I listed out the contents of my home directory, and you can see that my command worked. Now let's say we want to create our first Python script inside of the pythonHumanist directory. First, we can move into that directory and then we can create the file. To change directories we type cd followed by the absolute or relative path of the directory we want to visit. ~$ cd pythonHumanist ~/pythonHumanist$ You'll notice that the tilda is now followed by the directory name in my prompt showing me conveniently where I am (my working directory). Next, we create a file in that directory called hello.py and add some text to that file. We can do this in one step, but I'm doing two so you can see two different commands: ~/pythonHumanist$ touch hello.py ~/pythonHumanist$ ls hello.py ~/pythonHumanist$ echo \"print('Hello World')\" >> hello.py A few notes. First, we used the touch command to create a file. The general syntax is touch {filename} where {filename} is replaced by the name of the file you want to create. If you want to create multiple files, you can list them with a space separating each file name. Again, the same \"no spaces\" rule applies. Second, I listed out the contents of the directory to show that the file was created. If you opened the file at this point, it will be empty. Finally, I used the echo command followed by two >> greater than signs. The echo command prints some text. The greater than symbols writes the output of the echo command to the file. If I use 2 greater than signs, the output is appended to the end of the file. If I use one greater than sign, the file is overwritten with the new content. After this command, you'll see that the file hello.py contains the text print('Hello World') , which is Python code. More on that later. You can send the output of commands to other commands in Bash, and that ends up being a powerful feature. Next, let's say I want to copy files. This is really easy in Bash. The command is cp for copy and the syntax is cp {source} {destination} ~/pythonHumanist$ cp hello.py hello2.py ~/pythonHumanist$ ls hello.py hello2.py If you want to copy directories, you do so with the -r flag. Many commands have flags. These flags change the behavior of the command. In this case, I mean \"copy recursively\" or go through the contained directories and files and copy those as well as the outer directory that I named. The final command I want to cover here is rm which deletes files. BE CAREFUL WITH THIS COMMAND BECAUSE THERE WILL NOT BE A PROMPT ASKING IF YOU'RE SURE YOU WANT TO DELETE A FILE ~/pythonHumanist$ rm hello.py ~/pythonHumanist$ cd .. ~$ rm -r pythonHumanist First, I remove the file hello.py using the rm command. Then I change directories up one level ( .. signifies up one level) so I change the working directory to home. Then I remove the pythonHumanist directory using the -r flag. Again, many commands in Bash have flags that you can add that change the behavior. -r means recursive and it is what we use to remove directories. It means go into the directory, recursively delete all the files and then remove the directory. So if I had wanted to, I could have skipped removing the hello.py file first and just removed the directory and the file would have been deleted, too. There are many other commands that you will want to use, but I just wanted to give you a brief overview. We will encounter others that you'll have to learn as you go. If you have the time and energy, I strongly suggest spending a few hours and going further into Bash, as some of the concepts will make learning Python a bit easier. Setup our Environment We've done a bit of set up already and introduced you to the CLI. Now we need to finish getting things set up so that we can dive into Python next chapter. There are a few things we'll need. First, we need to get a good text editor. Python, as all code, is a bunch of human readable text that some program on the computer can understand and translate into the appropriate machine language that the computer can understand. There are tons of text editors out there and technically we could use Notepad for our code, but we want to use something with a few more features. KEY: do not use a word processor like Word to write code. When you use a word processor it adds extra markup to your file to display the formatting of the text and this will make your code non-functional. We will be using Visual Studio Code, but Atom is another good free option. I like Visual Studio Code because it gives you a file explorer and a terminal all built into one. Head over to the Visual Studio Code download page Download the installer for your operating system and run the installer. Check the installation by opening Git Bash (or Bash if you're in Mac) and typing code --version Set up User Settings in Visual Studio Code VS Code allows you to customize settings for all projects (User Settings) or for a single project (Workspace settings). To modify default settings select Code | Preferences for the Mac or File | Preferences for Windows and then Settings. You will see 2 files side by side. On the left are the default settings and on the right are the User setting overrides. To change a default setting find the setting on the left and then copy it to the right with your desired setting. For example, if you don't want to see the minimap on the right hand side of the application, you can make the following entry in the file on the right. Notice that options are key : value pairs and that they are commas separated. { \"editor.minimap.enabled\":false } Make \"Git Bash\" the default command line in VS Code terminal by adding the following to your User Settings: \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\" Install Python You'll also need to install Python. Python has a number of versions, and Python 3 is the one we will be using. If you are on Windows, you don't have Python. If you're on Mac or Linux, you have Python 2 so you need to add Python 3. Installing Python on Windows Head to the Python downloads page and select the Python 3 installer. Run the installer, and allow it to add Python3 to the Path. This is important, so make sure you pay attention to the option for adding Python3 to your PATH. Once you've installed Python3, open Git Bash and type python --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. If it still doesn't work, probably Python was not added to the PATH. You can Google adding Python to the PATH in Windows. Installing Python 3 on Mac Macs come with Python2 installed, so you will need to install Python3. Note, DO NOT UNINSTALL OR OTHERWISE REMOVE PYTHON 2 . It will break your operating system. Head to the Python downloads page and select the Python 3 installer. Run the installer. (Don't worry about the PATH, as that's not an issue we deal with in UNIX in the same way.) Once you've installed Python3, open Git Bash and type python3 --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. Also, if you type python --version it will say python 2.7 or something like that. By default on Mac and Linux, Python 2 is installed so the python command will use Python 2. We need to use python3 instead until we setup virtual environments. Set up Github Github is awesome! It is a place where you can share code and manage version control. Please do not get confused between Github and Git. Git is a CLI program that manages version control. Every time you \"commit\" changes with git, you create a new version. Behind the scenes, git manages a set of diff files that keep track of the changes that were made to the repository (or collection of code) since the last commit. Github is an online storage service that integrates with git and allows you to push your code to this service and share it both with teams and publicly. I'm not going to go over the Git commands here, but here is a good tutorial .","title":"Computers and You"},{"location":"ch1/#computers-and-you","text":"Welcome to Python for Humanists. This first chapter will introduce you to basic architecture of computers and the basics of setting up your development environment. By the end of this chapter, you'll have exercises that will ask you to walk through getting your development environment set up and ready to go.","title":"Computers and You"},{"location":"ch1/#computer-architecture","text":"If you were to open up your computer, and I do recommend that you do so someday, you'll see a bunch of silicone chips and wires and tower looking things. Whenever we use our computer, regardless of how fancy and complex the output on our screen might be or the calculations that the machine can accomplish, all that is happening inside the computer is a bunch of electricity flowing across the metal in particular patterns that are meaningful and useful. The various components work together to create patterns that achieve whatever commands we or some developer have provided to the machine. To understand how Python is working and to understand Concepts in Computing, it is useful to know the anatomy of a computer. There are very many types of computers from the system in your car to your smartphone to your desktop to your digital watch. In a nutshell, computers are machines that take some sort of input, do some calculations on those input, and finally return some sort of output. A simple calculator, for instance, takes numbers and operators as inputs, processes those inputs by performing the input operators, and finally returns the result of that operation as an output. More complicated computers, like a smartphone, just take different types of inputs and perform more complicated processes. Since all computers fundamentally do the same thing in varying degrees of complexities, they all have a basic set of components: Input and Output devices Processing Device Memory (Optional) Storage Let's start with the Input and Output (I/O) devices. I/O devices are the features that allow the computer to interact with the world. Input devices include keyboards, mice, touch screens, and so on. Each input device takes a specific type of data. Output devices include printers, monitors, speakers, and so on. Each output device returns a specific type of data. Computers might have various I/O devices, sometimes built in, sometimes peripheral, but they all will have some sort of I/O otherwise they won't be able to take data and return results. Memory is the next step. Memory is the space where data is stored when it is not immediately being processed. For instance, when you work in a Word document, your document is read from the long term storage to the memory. As you make changes, those changes are written to the memory, and when you \"Save\" the version of the document is written back to the long term storage medium. Memory is volatile, which means that when the computer shuts down or loses power, the memory is erased. The solution to this is long term storage, which will be covered below. If you've ever had the experience of working on a file and losing unsaved changes, it happened because those changes had not yet been written to long term storage. Processing devices are the processor. Processors come in various flavors and functionality, but they are responsible for managing all of the components of the computer (the memory and the I/O devices), and for running calculations. Every operation in a computer is the result of calculations done in binary. The processor is doing that constantly, often several calculations at once if you have a processor capable of multi-threading. (Optional) Most computers also have some form of long term storage. This might be a hard disk drive, a solid state drive, or a memory card. These are physical media of various sorts that can have data written to them in a permanent or semi-permanent state. In the case of hard disk drives, data is stored as charges written to magnetic platters. On larger computers like laptops and desktops, these components are usually connected through a motherboard that helps orchestrate the processes. When we begin programming, it is useful to consider what part of the physical machine is performing a particular thing because it perhaps will help you visualize and make sense of what's going on. This is especially true when we get to variables and files. Interacting with variables means we are interacting with memory and interacting with files we are interacting usually with long term storage.","title":"Computer Architecture"},{"location":"ch1/#beyond-the-graphical-user-interface","text":"Most of the time when you interact with a computer, you probably are doing so through what is called a Graphical User Interface (GUI). When you open your web browser, for instance, you have a window with URL bar and menus and a main pane where the website code is rendered for your enjoyment. Likewise, when you search for files, you are probably using File Explorer or Finder, both of which are GUIs for interacting with the file system. GUIs allow you to use your mouse and keyboard to interact with the computer through visual icons and fields. I cannot overstate the importance of GUIs to the proliferation of computers. Without a GUI, you would either have to use a command line interface or punch cards to use a computer. GUI's allow non-experts to gain access without facing the steep learning curve of learning commands or code or punch card patterns. Instead, you can issue commands to the computer through an intuitive interface of icons, labelled fields, and so on. That being said, GUIs limit the efficiency at which you can work and frequently limit your ability to issue commands to the computer. This means that if you want to move from being a user towards being a maker or developer (one who uses the computer as is, to one who might explore what the computer can be made to do) is to become familiar with what is called a Command Line Interface (CLI). There are numerous CLIs ranging from DOS Prompt, Windows Command LIne, Powershell, Bash, etc. Even Python has a CLI, which allows you to issue Python commands directly to the Python interpreter (this will make more sense next chapter). CLIs allow the user to issue text based commands to the system (whichever system reads and interprets the commands). So, just as I could use a GUI to view, create, open, move, and delete files and folders in the above example by clicking on buttons and icons in the GUI to issue commands to the Operating System, so too can I use the CLI to view, create, open, move, and delete files and folders by entering commands as text via the keyboard into the CLI. The particular CLI we will be using in this class is BASH . We are learning Bash instead of Command Prompt or Powershell because it is a very powerful \"shell\" that is built into all unix operating systems (Mac and Linux); however, at the time of writing, Mac is beginning to use Zsh instead, but the commands are largely the same so no worries. It is the standard CLI that you will encounter on nearly all web servers and will give you the most bang for your buck. Plus, it can be installed on Windows, and many bash commands are the saem in Powershell. Learning a CLI involves learning a set of commands (or \"magic words\") that are available. You won't need to memorize them all, but by spending time using the CLI, you will gradually pick them up. Why would we take the time to learn a CLI when you're already proficient at using a GUI? Great question! GUIs are limited to the set of actions that the GUI designer thinks that most users will need. The actions are usually triggered by a mouse click, but advanced users will likely learn Hotkeys or keyboard shortcuts to make their work faster. However, the program often has a number of other commands or actions that are difficult to access via the GUI. Using a CLI often gives you more power and control over what the program is doing. GUIs involve using a mouse or tabbing through buttons with the keyboard. This means that they are much slower to do complicated tasks. Once you become familiar with a CLI, you will be much faster at doing the same kinds of tasks, and many tasks are less complicated using a CLI than they are using a graphical interface. Let's say you decide to set up an application on a web server. First, that server exists in some server farm somewhere and the company that provides it allows you to access it remotely over a secure connection. That web server probably will not have a Desktop environment (a GUI for an operating system). Instead, it will have a CLI environment, and you will access it through a secure shell (ssh). Let's ignore the fact that the server will require that you use the CLI and think about how we might connect to that server remotely. To connect to that server, you set up an ssh connection. There are GUI programs that allow you to do this, like Putty, for instance. To do this, you must first install the program, then set up a connection through the form that the GUI provides and finally click the connect button. In Bash, however, all you have to do is type ssh username@server.com with any additional settings that might be necessary (e.g. you might need to type ssh -p 5257 username@server.com if you want to specify a particular port to connect to) and then hit enter. Likewise, many coding related applications have poor GUIs. Python's package manager (pip) for example only works in CLI. One word of caution: CLIs give you greater power and control over the machine, but that means you can mess things up pretty severely. I recommend knowing what a command will do before you execute it. This is particularly important if you are reading advice from StackOverflow or some other online forum that answers questions. Likewise, if you are not already practicing good backup habits, not would be an ideal time to start because it is possible to break things or lose data (e.g. rm -rf /home/ would delete all files installed by users without asking if you're sure).","title":"Beyond the Graphical User Interface"},{"location":"ch1/#installing-bash","text":"So if you're a Mac or Linux User, you can skip this section. You already have Bash or Zsh installed on your computer. In Mac, you'll need to locate the application called Terminal. In Linux, usually the hotkeys to open a terminal is CTRL+ALT+T. If you're a Windows 10 user, you have two options. You can set up Windows Subsystem Linux. Since developers frequently prefer developing in a Unix environment like Mac or Linux (for many reasons which I won't go into here), Windows has built a subsystem that allows you to use Linux within your Windows operating system. I use this personally when I'm using my Windows computer, but it is a little bit fiddly and permissions can be weird. The option I will walk you through here is using Git Bash. Git is a version control program that we'll talk about in a little bit, but they have created a version of Bash that works on Windows. It's lovely. head over to Git's download page and select the appropriate version of Git Bash to download. Run the installer that you just downloaded. I use the default settings, but if you want to customize the installation, feel free. Open Git Bash and a terminal will open up. Hooray.","title":"Installing Bash"},{"location":"ch1/#a-taste-of-bash","text":"If you want a great tutorial on how to use Bash and even write scripts in the Bash scripting language, check out Bash Academy for a really detailed tutorial of Bash. I strongly recommend this because knowing your way around a CLI will make the work of this program much easier. I will give you a quick overview here of Bash. I'd encourage you to follow along on your computer. When you open a Bash terminal, you will see a window with a black background and some text. Mine lookes like this: user1@DESKTOP-61VJ97U:~$ _ This is the prompt, and you'll see a cursor blinking right after the dollar sign. You can type commands here. Throughout this program, I will share code snippets and when I do, I will simply start with either ~$ or (env) ~$ So if you are following along and it looks slightly different, just know I'm cutting out the username and host for brevity sake. The first thing to learn about the CLI is how to navigate. Wherever the prompt is \"located\" in your file tree is where you will execute your commands. For example, if I am in a directory called \"projects\" and my prompt is set in that directory, then when I create a file it will be created within that directory. The first command we need to learn is pwd which stands for \"print working directory.\" The working directory is where my terminal is currently working. For example, when I open a terminal, it automatically opens to the home directory, represented by the tilda (~). So when I issue the command: ~$ pwd /home/user1 This means that my current working directory is /home/user1 and any command I issue, unless I specify otherwise, will be executed in that directory. Next, I will use the ls command to show you what directories reside within my home directory: ~$ ls Books Projects dylanmedina experiments Within my home directory I have Books, Projects, dylanmedina, and experiments. These are all directories that I can navigate into. These first two commands are crucial because they give me the location and context in which my CLI is operating. Now, let's say we're starting a new project, like this lesson. I might make a new directory for that project. To do so, I need to create a new directory and give it a name. The command is mkdir for \"make directory.\" You follow that by the name of the directory. One word on names: spaces don't work because each word of a command is separated by a space. So if I wanted to create a directory called Python for Humanists, and I issued the command ~$ mkdir Python for Humanists it would create three directories. One workaround is surround the name with quotation marks, but it's easier to just use names that don't have spaces. So let's go: ~$ mkdir pythonHumanist ~$ ls Books Projects dylanmedina experiments pythonHumanist You'll see, I created a directory called pythonHumanist and then I listed out the contents of my home directory, and you can see that my command worked. Now let's say we want to create our first Python script inside of the pythonHumanist directory. First, we can move into that directory and then we can create the file. To change directories we type cd followed by the absolute or relative path of the directory we want to visit. ~$ cd pythonHumanist ~/pythonHumanist$ You'll notice that the tilda is now followed by the directory name in my prompt showing me conveniently where I am (my working directory). Next, we create a file in that directory called hello.py and add some text to that file. We can do this in one step, but I'm doing two so you can see two different commands: ~/pythonHumanist$ touch hello.py ~/pythonHumanist$ ls hello.py ~/pythonHumanist$ echo \"print('Hello World')\" >> hello.py A few notes. First, we used the touch command to create a file. The general syntax is touch {filename} where {filename} is replaced by the name of the file you want to create. If you want to create multiple files, you can list them with a space separating each file name. Again, the same \"no spaces\" rule applies. Second, I listed out the contents of the directory to show that the file was created. If you opened the file at this point, it will be empty. Finally, I used the echo command followed by two >> greater than signs. The echo command prints some text. The greater than symbols writes the output of the echo command to the file. If I use 2 greater than signs, the output is appended to the end of the file. If I use one greater than sign, the file is overwritten with the new content. After this command, you'll see that the file hello.py contains the text print('Hello World') , which is Python code. More on that later. You can send the output of commands to other commands in Bash, and that ends up being a powerful feature. Next, let's say I want to copy files. This is really easy in Bash. The command is cp for copy and the syntax is cp {source} {destination} ~/pythonHumanist$ cp hello.py hello2.py ~/pythonHumanist$ ls hello.py hello2.py If you want to copy directories, you do so with the -r flag. Many commands have flags. These flags change the behavior of the command. In this case, I mean \"copy recursively\" or go through the contained directories and files and copy those as well as the outer directory that I named. The final command I want to cover here is rm which deletes files. BE CAREFUL WITH THIS COMMAND BECAUSE THERE WILL NOT BE A PROMPT ASKING IF YOU'RE SURE YOU WANT TO DELETE A FILE ~/pythonHumanist$ rm hello.py ~/pythonHumanist$ cd .. ~$ rm -r pythonHumanist First, I remove the file hello.py using the rm command. Then I change directories up one level ( .. signifies up one level) so I change the working directory to home. Then I remove the pythonHumanist directory using the -r flag. Again, many commands in Bash have flags that you can add that change the behavior. -r means recursive and it is what we use to remove directories. It means go into the directory, recursively delete all the files and then remove the directory. So if I had wanted to, I could have skipped removing the hello.py file first and just removed the directory and the file would have been deleted, too. There are many other commands that you will want to use, but I just wanted to give you a brief overview. We will encounter others that you'll have to learn as you go. If you have the time and energy, I strongly suggest spending a few hours and going further into Bash, as some of the concepts will make learning Python a bit easier.","title":"A taste of Bash"},{"location":"ch1/#setup-our-environment","text":"We've done a bit of set up already and introduced you to the CLI. Now we need to finish getting things set up so that we can dive into Python next chapter. There are a few things we'll need. First, we need to get a good text editor. Python, as all code, is a bunch of human readable text that some program on the computer can understand and translate into the appropriate machine language that the computer can understand. There are tons of text editors out there and technically we could use Notepad for our code, but we want to use something with a few more features. KEY: do not use a word processor like Word to write code. When you use a word processor it adds extra markup to your file to display the formatting of the text and this will make your code non-functional. We will be using Visual Studio Code, but Atom is another good free option. I like Visual Studio Code because it gives you a file explorer and a terminal all built into one. Head over to the Visual Studio Code download page Download the installer for your operating system and run the installer. Check the installation by opening Git Bash (or Bash if you're in Mac) and typing code --version Set up User Settings in Visual Studio Code VS Code allows you to customize settings for all projects (User Settings) or for a single project (Workspace settings). To modify default settings select Code | Preferences for the Mac or File | Preferences for Windows and then Settings. You will see 2 files side by side. On the left are the default settings and on the right are the User setting overrides. To change a default setting find the setting on the left and then copy it to the right with your desired setting. For example, if you don't want to see the minimap on the right hand side of the application, you can make the following entry in the file on the right. Notice that options are key : value pairs and that they are commas separated. { \"editor.minimap.enabled\":false } Make \"Git Bash\" the default command line in VS Code terminal by adding the following to your User Settings: \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\"","title":"Setup our Environment"},{"location":"ch1/#install-python","text":"You'll also need to install Python. Python has a number of versions, and Python 3 is the one we will be using. If you are on Windows, you don't have Python. If you're on Mac or Linux, you have Python 2 so you need to add Python 3.","title":"Install Python"},{"location":"ch1/#installing-python-on-windows","text":"Head to the Python downloads page and select the Python 3 installer. Run the installer, and allow it to add Python3 to the Path. This is important, so make sure you pay attention to the option for adding Python3 to your PATH. Once you've installed Python3, open Git Bash and type python --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. If it still doesn't work, probably Python was not added to the PATH. You can Google adding Python to the PATH in Windows.","title":"Installing Python on Windows"},{"location":"ch1/#installing-python-3-on-mac","text":"Macs come with Python2 installed, so you will need to install Python3. Note, DO NOT UNINSTALL OR OTHERWISE REMOVE PYTHON 2 . It will break your operating system. Head to the Python downloads page and select the Python 3 installer. Run the installer. (Don't worry about the PATH, as that's not an issue we deal with in UNIX in the same way.) Once you've installed Python3, open Git Bash and type python3 --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. Also, if you type python --version it will say python 2.7 or something like that. By default on Mac and Linux, Python 2 is installed so the python command will use Python 2. We need to use python3 instead until we setup virtual environments.","title":"Installing Python 3 on Mac"},{"location":"ch1/#set-up-github","text":"Github is awesome! It is a place where you can share code and manage version control. Please do not get confused between Github and Git. Git is a CLI program that manages version control. Every time you \"commit\" changes with git, you create a new version. Behind the scenes, git manages a set of diff files that keep track of the changes that were made to the repository (or collection of code) since the last commit. Github is an online storage service that integrates with git and allows you to push your code to this service and share it both with teams and publicly. I'm not going to go over the Git commands here, but here is a good tutorial .","title":"Set up Github"},{"location":"ch10/","text":"Black Boxing and Algorithms Black Boxing The notion of black-boxed systems can largely be credited to Bruno Latour . Latour is a contemporary French philosopher who introduces a Theory and Method called Actor-Network-Theory (ANT). ANT, in general terms responds to a problem that we have when studying social systems, specifically, that the moment we observe a social system, the system changes. In other words, the claims that we can make about such social systems are based on a glimpse of the social system at one moment in time, and do not effectively describe the social system now. Further, since Latour was a relativist suggesting that the world is in a constant state of flux, our claims are ultimately flawed if we state \"the world is like x.\" To counter this, he suggests that we look at agency, or the ability of actors to do things that affect the network in which they are embedded. For instance, we might not know who I am as your instructor, and we might not be able to know exactly the nature of our class, but we can see how I have authority to cause you to do, or not do, assignments and readings, etc. In short, ANT is interested in how different elements of a network can exert force on the network. \"What does this have to do with computing?\" you might ask. That's a good question. Latour was also very interested in scientific and technological networks. He was particularly concerned by the fact that these networks have a tendency towards positivism--or the belief that the world has knowable characteristics waiting for humans to discover. Since they expect truth from their work, they do not stop to question their approach to producing knowledge. As a result, scientific and technological systems have a tendency to become black-boxed--or the internal workings of them become hidden, and our concern becomes only inputs and outputs. I think machine learning is a very good example of this. In the most general sense, we feed a bunch of clean data to some sophisticated statistics algorithms (or functions), and it spits out models that define the phenomenon to, as many data scientists claim, a greater degree of accuracy than an expert on that phenomenon might be able to. The same data scientists who are so excited about the machine learning algorithm and its effectiveness are also quick to claim that they don't know exactly what the algorithm is doing. In a more complicated explanation, the machine learning algorithm is a multi-variable algebraic function. The system then runs the data through the function gradually tweaking each variable's coefficient until the function sufficiently matches the data being fed in. Understanding the math doesn't matter so much, but what's important is how we are expected to feed a machine learning system like TensorFlow data, it does some process on the data, and it returns us a model that accurately describes the data. The \"it does some process on the data\" is a prime example of a black box in the scientific and technical sphere. While Latour was using the notion of the Black box to describe the social systems within the STEM fields, it also applies very well to technology itself. Think of your computer. Unless we've studied some computer science or programming, how many of us understand how our operating system takes the input from our keyboard and converts it into the appropriate actions and outputs? What about our cell phones? Most of the major carriers forbid us from opening the cases and seeing what's inside on pain of a violated warranty. The same is true, in many cases, if we want root access to our devices. I'm personally skeptical about the blackboxing that occurs in technology, but it does serve a purpose. First, it helps companies maintain their intellectual property rights on their technology. We don't have access to Windows source code because it belongs to Microsoft. Instead we get a compiled version that works, but we don't get to read the source code that makes it work. This is useful if we have some proprietary piece of software that we want to sell and don't want people to share--though it happens still. Second, blackboxing can help us with security. There is an argument in the Open Source community surrounding whether open source software can ever be secure. For instance, I can read through the entirety of the Ubuntu source, find potential bugs that can be exploited, and then write and deploy an exploit. It is more difficult for me to read through Windows because I don't have access to the source unless I steal it. On the other hand, open source advocates say that since anyone can read Ubuntu source, there's a greater community trying to find and report bugs so they can get patched. For Windows, I'm dependent upon Microsoft to find and patch bugs. Likewise, plenty of exploits have been found in Windows without the help of an open source. In terms of our smartphones, not having root access can be useful because it means we cannot as easily install apps that might be malicious because as non-root users we can only install apps through the Apple, Play, or Amazon store--depending on our device. So the companies are vetting the apps. Third, blackboxing makes things a lot simpler. Look at Apple's model. You buy a computer from them. It costs twice what a Windows machine would cost for the same specs, but you know that the computer is simply going to work. Granted, Apple might stop supporting the hardware in a few years, but for those few years, you'll have an easy to use computer that works. Finally, and this is where things are really relevant to us, blackboxing makes it a lot easier for us to work with technology when we're programming through API's. In Everyday Coding, you'll be building a RESTful API, but for now and API is short for application programming interface. This means, an API is an interface that expects particular inputs and given the appropriate inputs, will return predictable outputs. Twitter, and most social media sites, provide a public API for us to use. With the Twitter API, I can create a bot in python that, say, tweets twice an hour, every hour, about how great polar bears are. My bot will send an appropriate series of commands to the Twitter API, including authentication token and secret along with my particular command (post a new tweet about these bears). If all of that matches what the API expects, then my command is executed and the tweet will be posted. Likewise, many of the libraries in Python can be considered API's. When you install a library, it gives you a series of classes and functions that you can use. When you use these, you are interacting with the library's API. So, when I write: import requests r = requests.get('http://www.google.com') I am using the requests library. Then I call the get() function within requests passing it a URL as an input. The get() function is part of the requests API and is a function that makes an HTTP GET call to the url and returns the response from the request. Why does this matter to us? Whenever you're writing a function, just as someone wrote the get() function in the requests library, you're creating a blackbox. Inside that black box is a series of procedures that are performed on the input to the function. Ultimately that returns some output on the other side. When you design, use, and share your function, the most important thing to remember is that while the series of procedures might be complex, a user should be able to provide some appropriate input and receive an expected output from the function. Let me show you an example: def square_a_number(num): \"\"\"This is an easy function. It expects some integer. If the input is an integer, it will return that integer squared\"\"\" if type(num) == int: # The return statement is sends some output to the python interpreter. return num * num else: raise ValueError(\"{} is not an integer.\".format(num)) # Test square_a_num() if __name__ == \"__main__\": nums = [2, 7, \"purple\", 8] for i in nums: try: num_squared = square_a_number(i) print(\"{} squared is {}\".format(i,num_squared)) except ValueError as e: print(e) In the above example, square_a_number() is a function that expects an integer. If it receives an integer, it returns (or has an output of) the input multiplied by itself. If it does not receive an integer, it raises an error saying the input is the wrong kind of value. Notice, I'm not converting the input to an integer, but testing that it is one. This is a good approach because many data types can be converted to an integer even if they're not. A, for instance, has an integer value. This week for your programming assignment, you'll be building a more complicated function that reads a file, finds matching words, and returns a count of the number of words that match. You'll be graded on both internal and external correctness. External correctness means it returns the expected value for an input regardless of how you get there inside the function. Internal correctness means that your solution makes sense inside the function. Algorithms One of the crucial things we want to consider in programming is how can we be as efficient as possible and still effective. This can be seen in the \"divide and conquer\" strategy, where one big problem is broken into smaller sub-problems of the same type (divide), so they become simple enough to be solved directly (conquer). One example of an algorithm that uses divide-and-conquer decomposition is when you're searching a large amount of data. Say you're looking for the word \"recursion\" in a dictionary. You know the order of the alphabet, so rather than looking through every page starting at the beginning of the book, you'd start at the middle of the book and flip through the last half. When you find the R section, you'd look for a page with R-E words at the top. Then you'd look at the bottom of the page for R-E-C words. Then you'd scan that page to find your word. It turns out that every time you did this, you were using a divide and conquer algorithm. Here's another example \u2013 searching a library. We'll explore algorithms more next week, but this method of \"decomposing\" a search by breaking the area to be searched into increasingly small sections is a classic binary search algorithm, illustrated below, along with the much-less-efficient sequential search method: # Different types of search # This will show you two ways to find a value in a sorted list # The point here is that part of decomposition is not only finding # steps to solve a problem, but also finding efficient ways to # do so. my_list = [0, 1, 2, 15, 17, 19, 21, 147, 376, 2000] my_search_term = 21 # Linear search # in linear search, I start with the first element of the list # loop through the list until I find the appropriate element # return the index of that element # In the worst case, we'll have to check every value in the list. # trivial for a list with this few elements, but if I had a million # entries, it would be a problem. count = 0 found = False while count < len(my_list) and not found: if my_search_term == my_list[count]: print(\"Found at index: {}\".format(count)) found = True count += 1 if not found: print(\"That value was not in the list.\") # Binary Search # in binary search, I first need a sorted list. # then I jump to the middle value and see if the search value # is bigger or smaller. I then move my search range accordingly. left = 0 right = len(my_list) found = False while not found and right > left: middle = int(left + ((right - left) / 2)) if my_search_term == my_list[middle]: print(\"Found at index: {}\".format(middle)) found = True elif my_search_term > my_list[middle]: left = middle elif my_search_term < my_list[middle]: right = middle if not found: print(\"The value was not found in the list.\")","title":"Blackboxing and Algorithms"},{"location":"ch10/#black-boxing-and-algorithms","text":"","title":"Black Boxing and Algorithms"},{"location":"ch10/#black-boxing","text":"The notion of black-boxed systems can largely be credited to Bruno Latour . Latour is a contemporary French philosopher who introduces a Theory and Method called Actor-Network-Theory (ANT). ANT, in general terms responds to a problem that we have when studying social systems, specifically, that the moment we observe a social system, the system changes. In other words, the claims that we can make about such social systems are based on a glimpse of the social system at one moment in time, and do not effectively describe the social system now. Further, since Latour was a relativist suggesting that the world is in a constant state of flux, our claims are ultimately flawed if we state \"the world is like x.\" To counter this, he suggests that we look at agency, or the ability of actors to do things that affect the network in which they are embedded. For instance, we might not know who I am as your instructor, and we might not be able to know exactly the nature of our class, but we can see how I have authority to cause you to do, or not do, assignments and readings, etc. In short, ANT is interested in how different elements of a network can exert force on the network. \"What does this have to do with computing?\" you might ask. That's a good question. Latour was also very interested in scientific and technological networks. He was particularly concerned by the fact that these networks have a tendency towards positivism--or the belief that the world has knowable characteristics waiting for humans to discover. Since they expect truth from their work, they do not stop to question their approach to producing knowledge. As a result, scientific and technological systems have a tendency to become black-boxed--or the internal workings of them become hidden, and our concern becomes only inputs and outputs. I think machine learning is a very good example of this. In the most general sense, we feed a bunch of clean data to some sophisticated statistics algorithms (or functions), and it spits out models that define the phenomenon to, as many data scientists claim, a greater degree of accuracy than an expert on that phenomenon might be able to. The same data scientists who are so excited about the machine learning algorithm and its effectiveness are also quick to claim that they don't know exactly what the algorithm is doing. In a more complicated explanation, the machine learning algorithm is a multi-variable algebraic function. The system then runs the data through the function gradually tweaking each variable's coefficient until the function sufficiently matches the data being fed in. Understanding the math doesn't matter so much, but what's important is how we are expected to feed a machine learning system like TensorFlow data, it does some process on the data, and it returns us a model that accurately describes the data. The \"it does some process on the data\" is a prime example of a black box in the scientific and technical sphere. While Latour was using the notion of the Black box to describe the social systems within the STEM fields, it also applies very well to technology itself. Think of your computer. Unless we've studied some computer science or programming, how many of us understand how our operating system takes the input from our keyboard and converts it into the appropriate actions and outputs? What about our cell phones? Most of the major carriers forbid us from opening the cases and seeing what's inside on pain of a violated warranty. The same is true, in many cases, if we want root access to our devices. I'm personally skeptical about the blackboxing that occurs in technology, but it does serve a purpose. First, it helps companies maintain their intellectual property rights on their technology. We don't have access to Windows source code because it belongs to Microsoft. Instead we get a compiled version that works, but we don't get to read the source code that makes it work. This is useful if we have some proprietary piece of software that we want to sell and don't want people to share--though it happens still. Second, blackboxing can help us with security. There is an argument in the Open Source community surrounding whether open source software can ever be secure. For instance, I can read through the entirety of the Ubuntu source, find potential bugs that can be exploited, and then write and deploy an exploit. It is more difficult for me to read through Windows because I don't have access to the source unless I steal it. On the other hand, open source advocates say that since anyone can read Ubuntu source, there's a greater community trying to find and report bugs so they can get patched. For Windows, I'm dependent upon Microsoft to find and patch bugs. Likewise, plenty of exploits have been found in Windows without the help of an open source. In terms of our smartphones, not having root access can be useful because it means we cannot as easily install apps that might be malicious because as non-root users we can only install apps through the Apple, Play, or Amazon store--depending on our device. So the companies are vetting the apps. Third, blackboxing makes things a lot simpler. Look at Apple's model. You buy a computer from them. It costs twice what a Windows machine would cost for the same specs, but you know that the computer is simply going to work. Granted, Apple might stop supporting the hardware in a few years, but for those few years, you'll have an easy to use computer that works. Finally, and this is where things are really relevant to us, blackboxing makes it a lot easier for us to work with technology when we're programming through API's. In Everyday Coding, you'll be building a RESTful API, but for now and API is short for application programming interface. This means, an API is an interface that expects particular inputs and given the appropriate inputs, will return predictable outputs. Twitter, and most social media sites, provide a public API for us to use. With the Twitter API, I can create a bot in python that, say, tweets twice an hour, every hour, about how great polar bears are. My bot will send an appropriate series of commands to the Twitter API, including authentication token and secret along with my particular command (post a new tweet about these bears). If all of that matches what the API expects, then my command is executed and the tweet will be posted. Likewise, many of the libraries in Python can be considered API's. When you install a library, it gives you a series of classes and functions that you can use. When you use these, you are interacting with the library's API. So, when I write: import requests r = requests.get('http://www.google.com') I am using the requests library. Then I call the get() function within requests passing it a URL as an input. The get() function is part of the requests API and is a function that makes an HTTP GET call to the url and returns the response from the request.","title":"Black Boxing"},{"location":"ch10/#why-does-this-matter-to-us","text":"Whenever you're writing a function, just as someone wrote the get() function in the requests library, you're creating a blackbox. Inside that black box is a series of procedures that are performed on the input to the function. Ultimately that returns some output on the other side. When you design, use, and share your function, the most important thing to remember is that while the series of procedures might be complex, a user should be able to provide some appropriate input and receive an expected output from the function. Let me show you an example: def square_a_number(num): \"\"\"This is an easy function. It expects some integer. If the input is an integer, it will return that integer squared\"\"\" if type(num) == int: # The return statement is sends some output to the python interpreter. return num * num else: raise ValueError(\"{} is not an integer.\".format(num)) # Test square_a_num() if __name__ == \"__main__\": nums = [2, 7, \"purple\", 8] for i in nums: try: num_squared = square_a_number(i) print(\"{} squared is {}\".format(i,num_squared)) except ValueError as e: print(e) In the above example, square_a_number() is a function that expects an integer. If it receives an integer, it returns (or has an output of) the input multiplied by itself. If it does not receive an integer, it raises an error saying the input is the wrong kind of value. Notice, I'm not converting the input to an integer, but testing that it is one. This is a good approach because many data types can be converted to an integer even if they're not. A, for instance, has an integer value. This week for your programming assignment, you'll be building a more complicated function that reads a file, finds matching words, and returns a count of the number of words that match. You'll be graded on both internal and external correctness. External correctness means it returns the expected value for an input regardless of how you get there inside the function. Internal correctness means that your solution makes sense inside the function.","title":"Why does this matter to us?"},{"location":"ch10/#algorithms","text":"One of the crucial things we want to consider in programming is how can we be as efficient as possible and still effective. This can be seen in the \"divide and conquer\" strategy, where one big problem is broken into smaller sub-problems of the same type (divide), so they become simple enough to be solved directly (conquer). One example of an algorithm that uses divide-and-conquer decomposition is when you're searching a large amount of data. Say you're looking for the word \"recursion\" in a dictionary. You know the order of the alphabet, so rather than looking through every page starting at the beginning of the book, you'd start at the middle of the book and flip through the last half. When you find the R section, you'd look for a page with R-E words at the top. Then you'd look at the bottom of the page for R-E-C words. Then you'd scan that page to find your word. It turns out that every time you did this, you were using a divide and conquer algorithm. Here's another example \u2013 searching a library. We'll explore algorithms more next week, but this method of \"decomposing\" a search by breaking the area to be searched into increasingly small sections is a classic binary search algorithm, illustrated below, along with the much-less-efficient sequential search method: # Different types of search # This will show you two ways to find a value in a sorted list # The point here is that part of decomposition is not only finding # steps to solve a problem, but also finding efficient ways to # do so. my_list = [0, 1, 2, 15, 17, 19, 21, 147, 376, 2000] my_search_term = 21 # Linear search # in linear search, I start with the first element of the list # loop through the list until I find the appropriate element # return the index of that element # In the worst case, we'll have to check every value in the list. # trivial for a list with this few elements, but if I had a million # entries, it would be a problem. count = 0 found = False while count < len(my_list) and not found: if my_search_term == my_list[count]: print(\"Found at index: {}\".format(count)) found = True count += 1 if not found: print(\"That value was not in the list.\") # Binary Search # in binary search, I first need a sorted list. # then I jump to the middle value and see if the search value # is bigger or smaller. I then move my search range accordingly. left = 0 right = len(my_list) found = False while not found and right > left: middle = int(left + ((right - left) / 2)) if my_search_term == my_list[middle]: print(\"Found at index: {}\".format(middle)) found = True elif my_search_term > my_list[middle]: left = middle elif my_search_term < my_list[middle]: right = middle if not found: print(\"The value was not found in the list.\")","title":"Algorithms"},{"location":"ch2/","text":"A Taste of Python File Structures Before we get too far into Python, there's one thing you need to understand very well. That is file structures. Your files are stored the computer in a hierarchical structure. A good way to think of it is as a tree starting from the root. / or c:\\ [The root directory. Everything is within this directory] /bin /opt /var /home /user1 /Documents /3010 /code my_function.py hangman.py anotherprogram.py /Articles transitions.docx techofhate.docx /Desktop hangman.py /Videos /Pictures If you look at the directory above, in the root I have the directories bin, opt, var, and home. These directories are at the same level, so they are called siblings. Each of these is a directory within the root, so the root is the parent. In Windows, the root is \"c:\\\" and folders will likely have different names, but the structure is similar. If we look at the \"home\" directory, we have a directory called \"user1\", and within that a few directories, including Documents, Desktop, Videos, and Pictures. Documents contains directories 3010 and Articles. user1 would be called a child of home. 3010 contains the code directory. /code and Articles both contain files. When I want to identify a file, I can identify it with its absolute path. This is the path from the root to the file or folder I'm identifying. So to identify the absolute path of hangman.py, I would need to call it /home/user1/Documents/code/3010/hangman.py. Likewise, to identify transitions.docx, I'd need to call it /home/user1/Documents/Articles/transitions.docx. Using the absolute path in a command or in code will guarantee that the computer can find a file I'm looking for. In commands and programming, it's important to note that unless we use a search function, the computer will not be able to \"search\" for a file. So, if I am working in /home/user1/Desktop and I issue the command python hangman.py the computer will look for hangman.py in my current working directory, and since there is no file called \"hangman.py\" in that working directory, it will be unable to find the file, and the terminal will throw a File Not Found error. What's going on here? Why can't the computer just know what file I'm talking about and run it. After all, it's stored in the memory, right? Yes, but there may be multiple files called \"hangman.py\" in different directories. That is totally legal in terms of storage, and maybe even reasonable practice. After all, you might be working on 100 websites on your local server, and each of them will have an \"index.php\" or \"index.html\" file because the web server looks for that. When entering commands or executing programs, don't want your program to stop and say, \"which hangman.py?\" every time you try to reference a file. To address such possible collisions, computers use something called \"namespaces.\" We'll think about this more later, but for now think of it as the \"working context\" in which your program is running. When you type pwd into your terminal, it tells you what the working context is, or where your terminal is focused. When you issue a command or write a line of code that references a named entity like a variable or a file, it looks for that entity or file in the working context unless you specify otherwise. This means that if you're working in /home/user1/Documents/code/3010 and you enter python hangman.py it looks only in the 3010 directory even though there is a hangman.py in Documents (see above). The thing to understand now is that the working context is where the program looks for named entities. If that entity (a file or variable) doesn't exist in that context (in that directory), then the program won't look elsewhere. It will throw an error. This is true for executing code and for changing directories. Let's say I'm working in the root directory (/). If I want to change directories to code/ I can't simply say cd code because there is no \"code\" directory in the root. Instead, I have to explicitly give the terminal the path to that directory with this command cd home/user1/Documents/code Let's break down how this is interpreted: Computer change the working directory to code which exists inside Documents, which exists inside user1, which exists inside home, The terminal is currently in the root. /home/ exists in the root so it can find that. Then inside /home/, user1/ exists as a directory, so it can find that. Then inside user1/, it can find Documents/ because that exists there. Finally, inside Documents/ it can find code/ I hope I'm not belaboring this too much, but it is crucial, especially as we move into next week to consider scope. You might know exactly where all of the files are located at. That's how a human brain works. We can create nice conceptual maps that help us infer stuff. Computers do not infer. If try to use a named entity (file or variable) in a different context (like calling a python script from another directory), the computer will only look in the local context unless you give it an explicit path to find that entity. It will never infer that you mean the \"hangman.py\" in /home/user1/Documents/code/3010/ and not the \"hangman.py\" in /home/user1/Desktop/ In short, remember, that you must be really explicit when you leave the comforts of a graphical interface like the Finder or File Explorer. Compiled versus Interpreted Languages Compiled? Interpeted? What the What? Generally when we talk about programming, we are talking about a human readable programming language that is easy for a human to understand. However, if we look at what's actually happening on the processor when the commands are being executed, those commands are in binary, or sets of on and off switches. Here is a miniature example of what addition looks like in human readable form and the binary operation that occurs on the processor when a computer calculates it: Human Readable: 12 + 11 = 23 Assembly Code: Binary Operation: 1100 + 1011 = 10111 I'd recommend that you take a moment to search for the binary representation of 23 and you will find that it is 10111. Why does this matter? A processor can't do anything with 23 until it is converted to binary, which are then converted to a series of charged and uncharged states, or a series of ON or OFF switches. It can, however, do operations with these sequences of electrical charges, and a great deal of work is done by the computer to translate between human readable and machine readable forms. For us, this means that every line of code eventually is converted into binary, and so what matters to us is how our code becomes binary. This leads us to compiled versus interpreted languages. The code we write, whether in Python or Java or C++ is written in human readable form. This means that we can understand it, and Python is particularly understandable. But the code must either be compiled or interpreted for it to run. Assembly and Machine Code I'll discuss the difference between compiled and interpreted in a moment, but there is a crucial intermediary between binary or bytecode and our high level programming languages. This intermediary is called assembly. Assembly is low level programming language that is a little bit human readable, but it is representations of specific commands that are executed by the processor. In other words, for a computer to perform an operation like 12 + 11, it would be one line of code in Python, but would require a number of operations on the processor to complete the summation. For instance, the computer needs to load the binary representation of 12 and 11 into registers (tiny bits of memory) on the processor. It needs to perform the operation on the binary values in each of the registers. The computer needs to write the result to another register and then send the decimal value of the result to the screen (which is a couple more steps). Assembly language contains the series of commands that cause the processor to do this. Assembly has a 1 to 1 relationship between command or line of code and operation performed by the processor. The translation between Assembly and the binary that the processor reads is done by the Assembler, which is processor specific (so an x86 and x64 processor would have different assemblers and different Assembly languages). You don't really need to know anything more about Assembly for our purposes except that all of the code we write is probably going to be converted into Assembly. Interpreted and Compiled is largely a difference in when and how that occurs. Compiled Languages Many programming languages are compiled. C++ and Java would be two examples. This means that a programmer writes their program, and then they run it through a compiler, which is a special program that converts the high level language into either an \"executable\" file of Assembly or some other low level language (often .exe in Windows) or directly into binary as is the case on some mobile phones or single board computers. To run the program, the programmer would not run the code written in the high level language (the source code), but instead would run the compiled executable which is the low level translation of the source code. Compiled languages have the advantage of being much faster to execute because at runtime the computer is reading assembly instead of the high level language (this will make more sense when I talk about interpreted languages). They are also slightly more complicated and often a little more difficult to learn. The communities online that surround C++ and Java, two high-level compiled languages, are also a little more grumpy towards newcomers than Python. Interpreted Languages An interpreted language does not need to be compiled. Instead, the programmer writes in the high level language. Then they run the program using the interpreter (in our case the Python program). At runtime, the interpreter reads the source code, converts the source code to lower level code like assembly. That lower level code is then executed by the processor. Notice, compiled languages are turned into executables and when we want to run the program, we don't run the source code, we run the executable which doesn't need to be interpreted into some lower level language at runtime. Interpreted languages on the other hand must be first interpreted into a lower level language and then executed, all at runtime. This can make things really slow. Python has a few tricks to address this deficiency. First, when we execute any Python script, you'll probably see a pycache folder created. In that folder, Python saves an interpreted version of the program in cache. This way, if Python has to run a program again, it will check to see if the program is the same in the cache first and if so, it will not re-interpret the source code, but run the cached version. If there is no cached version or if changes have been made, Python updates the cache and interprets the source code. Developers have also created Cython, which allows the developer to write Python or Cython code but get performance like that of a compiled language. This is a bit beyond the scope of this class, however. Do I need to know all of this? No, not really. I won't be testing you on it, but hopefully it will help you have some context around programming and programming languages. It is definitely going to be important to know the difference between a compiled and interpreted language, but the details of how they work (how programs are compiled or interpreted) is not something you need to know unless you get really serious about programming or get into computer science. Now Python Python refers to two related things. First, Python refers to a programming language that we use to give commands to our computer. This we'll talk at length about throughout the quarter. Second, Python refers to the program that runs on your computer that interprets the code that you write. Dr. Chuck talks about this to some extent in the book. Python the program converts your code into machine language that causes your computer to do things. Just like any program, Python is regularly updated and has minor and major versions. You'll hear almost immediately when looking at Python that there are two major versions: Python2 and Python3. Python 2.7.14 is the most recent version of Python2, and Python 3.8 is the main version of Python3. When we talk about Python version, we're talking about which version of the Python program we're using to interpret our code (we're also talking about our code, but more on that later). This difference is pretty important because as the language evolves over time, some of the features stop working or the syntax, or the way we write code, changes. For example, if we want to print some text to the screen, we use the \"print\" method. In Python 2 the syntax was this: print \"Hello, Snek!\" and for the same functionality in Python 3 you have to write: print(\"Hello, Snek!\") The Python3 interpreter would throw a Syntax error because it no does not recognizes the \"print\" function without parentheses. In short, as the Python program is updated, the way we write Python code has to change to account for the expectations of the interpreter. Does this mean that we have to update all of our code? Not necessarily. It does mean we need to be concerned with which version of Python we're writing for and which is running our code. In this class you will be writing code for a Python3 interpreter or you will be writing Python3 code, but it is good to be familiar with some of the major differences. We'll talk about them as they come up. What is important, though, is that you will need to make sure the Python3 interpreter is installed on your computer. Python Interpreter When we write Python programs, we're usually writing a series of instructions to a file. When we run the program, we tell the Python interpreter to open the file and read and execute the instructions that are contained therein. However, we can also issue commands to the Python interpreter in the same way we can with Bash. The Python CLI can be opened by launching Python without specifying a script. You'll notice before that I just need to type python in Windows and python3 in Mac/Linux because in the latter I have both Python 2 and Python 3 installed. Windows ~$ python Python 3.8.3 (tags/v3.8.3:6f8c832, May 13 2020, 22:37:02) [MSC v.1924 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Mac/Linux ~$ python3 Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> You know that you're in the Python interpreter because of the three greater than ( >>> ) symbols. Once there, we can play around. I recommend you follow along. >>> 2 + 2 4 >>> 2 * 8 16 >>> 2 * (18 + 72) 180 >>> print(\"Hello, world!\") Hello, world! >>> sorted([18, 27, 2, 9, 6]) [2, 6, 9, 18, 27] >>> type(2.7) <class 'float'> >>> type(2) <class 'int'> >>> type('Puppies') <class 'str'> >>> exit() ~$ What you see here is a sequence of commands that I sent to the Python interpreter in the Python programming language. On the prompt lines (preceded by >>> ), I entered my commands. On the following lines is the response of the Python interpreter. Kind of like a conversation: Me: Python, please add 2 and 2. Python: 4 Me: Python, please multiply 2 and 8. Python: 16 Me: Python, please first add 18 and 72, and then multiply that sum by 2. Python: 180 Me: Python, please print to the console the string \"Hello, world!\" Python: Hello, world! Me: Python, please sort the list of numbers 18, 27, 2, 9, and 6 in ascending order. Python: [2, 6, 9, 18, 27] Me: Python, please tell me what type of data 2.7 is. Python: It is a floating point decimal Me: Python, please tell me what type of data 2 is. Python: It is an integer. Me: Python, please tell me what type of data \"Puppies\" is. Python: It is a string Me: Please exit, python Python: exits and returns to Bash prompt If you followed along with the code above, you just coded your first bit of Python. Congratulations! Generally, when we code Python, we write the commands into a text file and then the interpreter executes them when we tell them to do so, but for now, we have cut out the middleman of the file and written our commands directly to the interpreter. It's important to note that the commands are executed in the order we give them. The same is true when we write our code into a file. The interpreter will execute those commands in order. This is the project for next chapter, so I will leave it at that. You've just gotten your first taste of Python. Virtual Environments You might be wondering, how do we keep all the versions of Python sorted out? That's a good question and it extends to all the other libraries that we install. When we use someone else's code, we're taking on dependencies. As they update their code, we might have used an older version, so we need to make sure that we don't accidentally pull in the newer version of their code because it might no longer be compatible with our code. Also, we ourselves could write a program in 2020, but within the next year probably, Python 4 will be released. This means that if we update to Python 4 on our machine, our code will probably break because there will be changes in how Python is written. We need a way to make sure that the same version of the Python interpreter is always used to execute our code. We manage this and all of our dependencies using what's called Virtual Environments. These allow us to bundle up our code and dependencies at a frozen moment in time, and isolate that project's dependencies from other projects and versions of Python. Managing Virtual Environments has become extremely easy. There are a number of tools to do so including pipenv and venv . We'll be using venv here because it is included when you install Python, and where it stores the virtual environment directory is a bit more obvious. To launch it we simply tell Python to execute the venv module. To tell Python to use a module, we need to use the -m flag. $ python3 -m venv -h usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in. optional arguments: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default) --prompt PROMPT Provides an alternative prompt prefix for this environment. Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory. My command was python3 -m venv -h , which basically means \"Python, execute a module called venv and send the -h command to it.\" You can see from the help article that is returned that when you send the -h command to venv, it displays the help article. Now we can look at the general syntax for using venv . First, it's worth noting that I called python3 rather than python . If you're in Windows and only have Python 3 installed, or if you plan to use Python 2 in Mac or Linux, you would call python . You'll see that there is a required, positional argument. We'll learn about arguments when we talk about functions, but for now, think of it as a bit of extra data that will be used by the program. Specifically, in this case it is an ENV_DIR which probably stands for environment directory. This means we need to give the command a name of a directory where the environment data will be stored. This does not mean the name of the directory for the project, but some other name that we can remember is our virtual environment directory. Let me show you the code first, so maybe it's a bit more clear. $ mkdir my_project $ ls my_project $ cd my_project $ ls $ python3 -m venv env $ ls env Ok, first I made a new directory for my project and changed into that directory. I'm using ls to show you what is there. Next, I used venv and created an environment in a directory called env . This env is arbitrary. I choose to call the directory \"env\" because it's known and makes sense. You could call it \"puppy\" or \"an_environment_directory\" but that would make less sense. Also, it's worth noting that the env directory was created by venv. I didn't need to create it first. Finally, you'll never need to manually change anything inside that env folder. Just create it and leave it alone. The package management tools will manage the environment for you. Our next step after creating the resources for our virtual environment is to activate it. Once the environment is activated, whenever we use Python, we will be using the one in this environment. This means that our commands to call Python will always be python rather than python3 because in THIS environment there is only one version of Python installed. So let's activate our environment: Mac/Linux ~/my_project$ source env/bin/activate (env) ~/my_project$ Windows ~/my_project/~ env\\Scripts\\activate (env) ~/my_project$ In both cases we run the activate script to launch our virtual environment. Pay attention to the (env) bit because that tells you your Bash prompt is working in that virtual environment. If this all seems a little confusing now, that's okay. It becomes much more clear with practice. Now that we have our virtual environment created and activated, we can start working. Pip and Pip Freeze When we use Python, we probably will be installing libraries that other people have created. These libraries give us functionality that allows us to avoid having to write a bunch of stuff. We'll talk about this in detail in a few chapters, but for now, consider the work it would require to connect to a website. First, we'd need to use sockets to get our network card to connect to the internet. Then we'd need to build our requests. Then we'd need to listen for a response and so on. Instead, I can just install the requests library that someone else built and maintains, and all that work is done for me. I just use functionality that is build into requests . We do the same thing when we use a web browser, but a web browser has more functionality built in and is used predominately through a GUI. More on this later. For now, we just need to know how to install and manage our virtual environment and the packages that are installed there. To install a package the command is simply pip install {package name} . We'll again talk about this at length in a few chapters. For now, what is most important is the pip freeze command. If we just type that in our Bash terminal the list of packages and their version numbers will be printed to the screen. In general, we will issue the pip freeze command with the output being written to a file called requirements.txt . This will allow us to track the single file in our git repository rather than the entire env/ directory. Conclusion This chapter was a brief introduction to Python and is designed to prepare you for the next chapter. In the next chapter, we'll discuss the first lessons in Python programming. We'll cover the basic syntax and variables.","title":"A Taste of Python"},{"location":"ch2/#a-taste-of-python","text":"","title":"A Taste of Python"},{"location":"ch2/#file-structures","text":"Before we get too far into Python, there's one thing you need to understand very well. That is file structures. Your files are stored the computer in a hierarchical structure. A good way to think of it is as a tree starting from the root. / or c:\\ [The root directory. Everything is within this directory] /bin /opt /var /home /user1 /Documents /3010 /code my_function.py hangman.py anotherprogram.py /Articles transitions.docx techofhate.docx /Desktop hangman.py /Videos /Pictures If you look at the directory above, in the root I have the directories bin, opt, var, and home. These directories are at the same level, so they are called siblings. Each of these is a directory within the root, so the root is the parent. In Windows, the root is \"c:\\\" and folders will likely have different names, but the structure is similar. If we look at the \"home\" directory, we have a directory called \"user1\", and within that a few directories, including Documents, Desktop, Videos, and Pictures. Documents contains directories 3010 and Articles. user1 would be called a child of home. 3010 contains the code directory. /code and Articles both contain files. When I want to identify a file, I can identify it with its absolute path. This is the path from the root to the file or folder I'm identifying. So to identify the absolute path of hangman.py, I would need to call it /home/user1/Documents/code/3010/hangman.py. Likewise, to identify transitions.docx, I'd need to call it /home/user1/Documents/Articles/transitions.docx. Using the absolute path in a command or in code will guarantee that the computer can find a file I'm looking for. In commands and programming, it's important to note that unless we use a search function, the computer will not be able to \"search\" for a file. So, if I am working in /home/user1/Desktop and I issue the command python hangman.py the computer will look for hangman.py in my current working directory, and since there is no file called \"hangman.py\" in that working directory, it will be unable to find the file, and the terminal will throw a File Not Found error. What's going on here? Why can't the computer just know what file I'm talking about and run it. After all, it's stored in the memory, right? Yes, but there may be multiple files called \"hangman.py\" in different directories. That is totally legal in terms of storage, and maybe even reasonable practice. After all, you might be working on 100 websites on your local server, and each of them will have an \"index.php\" or \"index.html\" file because the web server looks for that. When entering commands or executing programs, don't want your program to stop and say, \"which hangman.py?\" every time you try to reference a file. To address such possible collisions, computers use something called \"namespaces.\" We'll think about this more later, but for now think of it as the \"working context\" in which your program is running. When you type pwd into your terminal, it tells you what the working context is, or where your terminal is focused. When you issue a command or write a line of code that references a named entity like a variable or a file, it looks for that entity or file in the working context unless you specify otherwise. This means that if you're working in /home/user1/Documents/code/3010 and you enter python hangman.py it looks only in the 3010 directory even though there is a hangman.py in Documents (see above). The thing to understand now is that the working context is where the program looks for named entities. If that entity (a file or variable) doesn't exist in that context (in that directory), then the program won't look elsewhere. It will throw an error. This is true for executing code and for changing directories. Let's say I'm working in the root directory (/). If I want to change directories to code/ I can't simply say cd code because there is no \"code\" directory in the root. Instead, I have to explicitly give the terminal the path to that directory with this command cd home/user1/Documents/code Let's break down how this is interpreted: Computer change the working directory to code which exists inside Documents, which exists inside user1, which exists inside home, The terminal is currently in the root. /home/ exists in the root so it can find that. Then inside /home/, user1/ exists as a directory, so it can find that. Then inside user1/, it can find Documents/ because that exists there. Finally, inside Documents/ it can find code/ I hope I'm not belaboring this too much, but it is crucial, especially as we move into next week to consider scope. You might know exactly where all of the files are located at. That's how a human brain works. We can create nice conceptual maps that help us infer stuff. Computers do not infer. If try to use a named entity (file or variable) in a different context (like calling a python script from another directory), the computer will only look in the local context unless you give it an explicit path to find that entity. It will never infer that you mean the \"hangman.py\" in /home/user1/Documents/code/3010/ and not the \"hangman.py\" in /home/user1/Desktop/ In short, remember, that you must be really explicit when you leave the comforts of a graphical interface like the Finder or File Explorer.","title":"File Structures"},{"location":"ch2/#compiled-versus-interpreted-languages","text":"","title":"Compiled versus Interpreted Languages"},{"location":"ch2/#compiled-interpeted-what-the-what","text":"Generally when we talk about programming, we are talking about a human readable programming language that is easy for a human to understand. However, if we look at what's actually happening on the processor when the commands are being executed, those commands are in binary, or sets of on and off switches. Here is a miniature example of what addition looks like in human readable form and the binary operation that occurs on the processor when a computer calculates it: Human Readable: 12 + 11 = 23 Assembly Code: Binary Operation: 1100 + 1011 = 10111 I'd recommend that you take a moment to search for the binary representation of 23 and you will find that it is 10111. Why does this matter? A processor can't do anything with 23 until it is converted to binary, which are then converted to a series of charged and uncharged states, or a series of ON or OFF switches. It can, however, do operations with these sequences of electrical charges, and a great deal of work is done by the computer to translate between human readable and machine readable forms. For us, this means that every line of code eventually is converted into binary, and so what matters to us is how our code becomes binary. This leads us to compiled versus interpreted languages. The code we write, whether in Python or Java or C++ is written in human readable form. This means that we can understand it, and Python is particularly understandable. But the code must either be compiled or interpreted for it to run.","title":"Compiled? Interpeted? What the What?"},{"location":"ch2/#assembly-and-machine-code","text":"I'll discuss the difference between compiled and interpreted in a moment, but there is a crucial intermediary between binary or bytecode and our high level programming languages. This intermediary is called assembly. Assembly is low level programming language that is a little bit human readable, but it is representations of specific commands that are executed by the processor. In other words, for a computer to perform an operation like 12 + 11, it would be one line of code in Python, but would require a number of operations on the processor to complete the summation. For instance, the computer needs to load the binary representation of 12 and 11 into registers (tiny bits of memory) on the processor. It needs to perform the operation on the binary values in each of the registers. The computer needs to write the result to another register and then send the decimal value of the result to the screen (which is a couple more steps). Assembly language contains the series of commands that cause the processor to do this. Assembly has a 1 to 1 relationship between command or line of code and operation performed by the processor. The translation between Assembly and the binary that the processor reads is done by the Assembler, which is processor specific (so an x86 and x64 processor would have different assemblers and different Assembly languages). You don't really need to know anything more about Assembly for our purposes except that all of the code we write is probably going to be converted into Assembly. Interpreted and Compiled is largely a difference in when and how that occurs.","title":"Assembly and Machine Code"},{"location":"ch2/#compiled-languages","text":"Many programming languages are compiled. C++ and Java would be two examples. This means that a programmer writes their program, and then they run it through a compiler, which is a special program that converts the high level language into either an \"executable\" file of Assembly or some other low level language (often .exe in Windows) or directly into binary as is the case on some mobile phones or single board computers. To run the program, the programmer would not run the code written in the high level language (the source code), but instead would run the compiled executable which is the low level translation of the source code. Compiled languages have the advantage of being much faster to execute because at runtime the computer is reading assembly instead of the high level language (this will make more sense when I talk about interpreted languages). They are also slightly more complicated and often a little more difficult to learn. The communities online that surround C++ and Java, two high-level compiled languages, are also a little more grumpy towards newcomers than Python.","title":"Compiled Languages"},{"location":"ch2/#interpreted-languages","text":"An interpreted language does not need to be compiled. Instead, the programmer writes in the high level language. Then they run the program using the interpreter (in our case the Python program). At runtime, the interpreter reads the source code, converts the source code to lower level code like assembly. That lower level code is then executed by the processor. Notice, compiled languages are turned into executables and when we want to run the program, we don't run the source code, we run the executable which doesn't need to be interpreted into some lower level language at runtime. Interpreted languages on the other hand must be first interpreted into a lower level language and then executed, all at runtime. This can make things really slow. Python has a few tricks to address this deficiency. First, when we execute any Python script, you'll probably see a pycache folder created. In that folder, Python saves an interpreted version of the program in cache. This way, if Python has to run a program again, it will check to see if the program is the same in the cache first and if so, it will not re-interpret the source code, but run the cached version. If there is no cached version or if changes have been made, Python updates the cache and interprets the source code. Developers have also created Cython, which allows the developer to write Python or Cython code but get performance like that of a compiled language. This is a bit beyond the scope of this class, however. Do I need to know all of this? No, not really. I won't be testing you on it, but hopefully it will help you have some context around programming and programming languages. It is definitely going to be important to know the difference between a compiled and interpreted language, but the details of how they work (how programs are compiled or interpreted) is not something you need to know unless you get really serious about programming or get into computer science.","title":"Interpreted Languages"},{"location":"ch2/#now-python","text":"Python refers to two related things. First, Python refers to a programming language that we use to give commands to our computer. This we'll talk at length about throughout the quarter. Second, Python refers to the program that runs on your computer that interprets the code that you write. Dr. Chuck talks about this to some extent in the book. Python the program converts your code into machine language that causes your computer to do things. Just like any program, Python is regularly updated and has minor and major versions. You'll hear almost immediately when looking at Python that there are two major versions: Python2 and Python3. Python 2.7.14 is the most recent version of Python2, and Python 3.8 is the main version of Python3. When we talk about Python version, we're talking about which version of the Python program we're using to interpret our code (we're also talking about our code, but more on that later). This difference is pretty important because as the language evolves over time, some of the features stop working or the syntax, or the way we write code, changes. For example, if we want to print some text to the screen, we use the \"print\" method. In Python 2 the syntax was this: print \"Hello, Snek!\" and for the same functionality in Python 3 you have to write: print(\"Hello, Snek!\") The Python3 interpreter would throw a Syntax error because it no does not recognizes the \"print\" function without parentheses. In short, as the Python program is updated, the way we write Python code has to change to account for the expectations of the interpreter. Does this mean that we have to update all of our code? Not necessarily. It does mean we need to be concerned with which version of Python we're writing for and which is running our code. In this class you will be writing code for a Python3 interpreter or you will be writing Python3 code, but it is good to be familiar with some of the major differences. We'll talk about them as they come up. What is important, though, is that you will need to make sure the Python3 interpreter is installed on your computer.","title":"Now Python"},{"location":"ch2/#python-interpreter","text":"When we write Python programs, we're usually writing a series of instructions to a file. When we run the program, we tell the Python interpreter to open the file and read and execute the instructions that are contained therein. However, we can also issue commands to the Python interpreter in the same way we can with Bash. The Python CLI can be opened by launching Python without specifying a script. You'll notice before that I just need to type python in Windows and python3 in Mac/Linux because in the latter I have both Python 2 and Python 3 installed.","title":"Python Interpreter"},{"location":"ch2/#windows","text":"~$ python Python 3.8.3 (tags/v3.8.3:6f8c832, May 13 2020, 22:37:02) [MSC v.1924 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>>","title":"Windows"},{"location":"ch2/#maclinux","text":"~$ python3 Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> You know that you're in the Python interpreter because of the three greater than ( >>> ) symbols. Once there, we can play around. I recommend you follow along. >>> 2 + 2 4 >>> 2 * 8 16 >>> 2 * (18 + 72) 180 >>> print(\"Hello, world!\") Hello, world! >>> sorted([18, 27, 2, 9, 6]) [2, 6, 9, 18, 27] >>> type(2.7) <class 'float'> >>> type(2) <class 'int'> >>> type('Puppies') <class 'str'> >>> exit() ~$ What you see here is a sequence of commands that I sent to the Python interpreter in the Python programming language. On the prompt lines (preceded by >>> ), I entered my commands. On the following lines is the response of the Python interpreter. Kind of like a conversation: Me: Python, please add 2 and 2. Python: 4 Me: Python, please multiply 2 and 8. Python: 16 Me: Python, please first add 18 and 72, and then multiply that sum by 2. Python: 180 Me: Python, please print to the console the string \"Hello, world!\" Python: Hello, world! Me: Python, please sort the list of numbers 18, 27, 2, 9, and 6 in ascending order. Python: [2, 6, 9, 18, 27] Me: Python, please tell me what type of data 2.7 is. Python: It is a floating point decimal Me: Python, please tell me what type of data 2 is. Python: It is an integer. Me: Python, please tell me what type of data \"Puppies\" is. Python: It is a string Me: Please exit, python Python: exits and returns to Bash prompt If you followed along with the code above, you just coded your first bit of Python. Congratulations! Generally, when we code Python, we write the commands into a text file and then the interpreter executes them when we tell them to do so, but for now, we have cut out the middleman of the file and written our commands directly to the interpreter. It's important to note that the commands are executed in the order we give them. The same is true when we write our code into a file. The interpreter will execute those commands in order. This is the project for next chapter, so I will leave it at that. You've just gotten your first taste of Python.","title":"Mac/Linux"},{"location":"ch2/#virtual-environments","text":"You might be wondering, how do we keep all the versions of Python sorted out? That's a good question and it extends to all the other libraries that we install. When we use someone else's code, we're taking on dependencies. As they update their code, we might have used an older version, so we need to make sure that we don't accidentally pull in the newer version of their code because it might no longer be compatible with our code. Also, we ourselves could write a program in 2020, but within the next year probably, Python 4 will be released. This means that if we update to Python 4 on our machine, our code will probably break because there will be changes in how Python is written. We need a way to make sure that the same version of the Python interpreter is always used to execute our code. We manage this and all of our dependencies using what's called Virtual Environments. These allow us to bundle up our code and dependencies at a frozen moment in time, and isolate that project's dependencies from other projects and versions of Python. Managing Virtual Environments has become extremely easy. There are a number of tools to do so including pipenv and venv . We'll be using venv here because it is included when you install Python, and where it stores the virtual environment directory is a bit more obvious. To launch it we simply tell Python to execute the venv module. To tell Python to use a module, we need to use the -m flag. $ python3 -m venv -h usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in. optional arguments: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default) --prompt PROMPT Provides an alternative prompt prefix for this environment. Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory. My command was python3 -m venv -h , which basically means \"Python, execute a module called venv and send the -h command to it.\" You can see from the help article that is returned that when you send the -h command to venv, it displays the help article. Now we can look at the general syntax for using venv . First, it's worth noting that I called python3 rather than python . If you're in Windows and only have Python 3 installed, or if you plan to use Python 2 in Mac or Linux, you would call python . You'll see that there is a required, positional argument. We'll learn about arguments when we talk about functions, but for now, think of it as a bit of extra data that will be used by the program. Specifically, in this case it is an ENV_DIR which probably stands for environment directory. This means we need to give the command a name of a directory where the environment data will be stored. This does not mean the name of the directory for the project, but some other name that we can remember is our virtual environment directory. Let me show you the code first, so maybe it's a bit more clear. $ mkdir my_project $ ls my_project $ cd my_project $ ls $ python3 -m venv env $ ls env Ok, first I made a new directory for my project and changed into that directory. I'm using ls to show you what is there. Next, I used venv and created an environment in a directory called env . This env is arbitrary. I choose to call the directory \"env\" because it's known and makes sense. You could call it \"puppy\" or \"an_environment_directory\" but that would make less sense. Also, it's worth noting that the env directory was created by venv. I didn't need to create it first. Finally, you'll never need to manually change anything inside that env folder. Just create it and leave it alone. The package management tools will manage the environment for you. Our next step after creating the resources for our virtual environment is to activate it. Once the environment is activated, whenever we use Python, we will be using the one in this environment. This means that our commands to call Python will always be python rather than python3 because in THIS environment there is only one version of Python installed. So let's activate our environment:","title":"Virtual Environments"},{"location":"ch2/#maclinux_1","text":"~/my_project$ source env/bin/activate (env) ~/my_project$","title":"Mac/Linux"},{"location":"ch2/#windows_1","text":"~/my_project/~ env\\Scripts\\activate (env) ~/my_project$ In both cases we run the activate script to launch our virtual environment. Pay attention to the (env) bit because that tells you your Bash prompt is working in that virtual environment. If this all seems a little confusing now, that's okay. It becomes much more clear with practice. Now that we have our virtual environment created and activated, we can start working.","title":"Windows"},{"location":"ch2/#pip-and-pip-freeze","text":"When we use Python, we probably will be installing libraries that other people have created. These libraries give us functionality that allows us to avoid having to write a bunch of stuff. We'll talk about this in detail in a few chapters, but for now, consider the work it would require to connect to a website. First, we'd need to use sockets to get our network card to connect to the internet. Then we'd need to build our requests. Then we'd need to listen for a response and so on. Instead, I can just install the requests library that someone else built and maintains, and all that work is done for me. I just use functionality that is build into requests . We do the same thing when we use a web browser, but a web browser has more functionality built in and is used predominately through a GUI. More on this later. For now, we just need to know how to install and manage our virtual environment and the packages that are installed there. To install a package the command is simply pip install {package name} . We'll again talk about this at length in a few chapters. For now, what is most important is the pip freeze command. If we just type that in our Bash terminal the list of packages and their version numbers will be printed to the screen. In general, we will issue the pip freeze command with the output being written to a file called requirements.txt . This will allow us to track the single file in our git repository rather than the entire env/ directory.","title":"Pip and Pip Freeze"},{"location":"ch2/#conclusion","text":"This chapter was a brief introduction to Python and is designed to prepare you for the next chapter. In the next chapter, we'll discuss the first lessons in Python programming. We'll cover the basic syntax and variables.","title":"Conclusion"},{"location":"ch3/","text":"Encoding Identity In this chapter we're going to really begin diving into Python. We'll start with a bit of review of the basic syntax using the Python CLI. Then we will move into writing scripts. As we go, I will try to highlight considerations that humanists might have as we start learning the coding. One of the more interesting things, I believe, about programming is that most programming occurs because someone has a problem. For example, I have a problem that I have to transcribe a bunch of video lectures so that they have subtitles. It is a critical task, but it is also a pain. One solution to the problem is the painful task of manually transcribing the audio with my headphones and a transcription pedal. I type fast, but it is still not fun. Alternatively, I could write some code to pipe my audio files into a speech recognition engine (which itself is code) that will return the text of the speech. I could even maybe write code to put in timestamps automatically. The question that we have to answer, then, is at what point is it worth the effort to write the code to avoid the pain of transcription? How accurate must that automatic transcription system be to be worth implementing? Now, to get to the place where we can solve problems, we need to know a bit about the programming language's syntax and how to run it. That is the work of this program. We also need to be able to consider how our code can translate the real problems that humans encounter into the computations that computers can do. That is, we must figure out how to render the world into code so that the computer can help us. In this chapter, we're focusing on the basic computations that a computer can do along with the kind of data it can store. This is the first step of encoding the world. After that we'll move into more complex stuff. What is Programming? Literally, programming is the process of writing a list of commands that a computer can execute in a programming language. The programmer uses some language that the computer can either interpret or understand directly. The list of instructions is the program. Pretty simple. Most programming languages have a set of known instructions built in. For example, when we write print(\"Hello, World\") we are telling Python to use the instructions that cause the computer to write text to the terminal to write the string \"Hello, World\" to our terminal. Likewise, Python, and most programming languages, knows that 8 * 8 means that it should evaluate the integer 8 multiplied by the integer 8 and the result should be printed to the terminal. As programmers, we are given both these built in instructions and we get the opportunity to build our own sets of instructions by combining the built in ones. We can also overwrite the instructions that are part of the programming language, but for our purposes, we will not be doing that. The built in instructions are a combination of human readable words and math symbols. These words and symbols do specific things. Here is a list of the words that are part of the Python language as \"reserved words\" or words that are part of the language that you cannot use when naming new variables: and del global not with as elif if or yield assert else import pass break except in raise class finally is return continue for lambda try def from nonlocal while Python also has many built in \"functions\" or sets of instructions that accomplish a particular task. print() was an example that I used above. Likewise, the format() function allows us to format and add variables to a string. We'll talk about those in a bit, and I will not list all of the built in functions that are part of Python here as that would be too much. Instead it is better to know that built in functions exists, and when you're trying to do something new it's worth checking to see if there's already a built in function for that. Python also uses a bunch of \"math\" characters. These characters are called operators and they have special functionality in the language. Here are the major operators: +, -, *, / Addition, subtraction, multiplication, and division operators. x + y returns the sum of x and y. x**y Exponent operator. The interpreter returns x raised to the yth power x % y The modulo operator returns the remainder of x divided by y x == y Equality operator. The interpreter returns True if x and y are equal x != y Not equal. Returns True if x is not equal to y >, <, >=, <= Greater than, less than, greater than or equal to, less than or equal to. The same as math. x = y Assignment operator. NOTE: This isn't the same as math. It doesn't evaluate equality, but assigns the value of y to the variable x The first three sets of operators are used to perform calculations. The next 3 sets of operators ask the interpreter to evaluate equality and return True or False based on the evaluation. So 2 == 2 would return True, and 2 > 20 would return False. We use these to evaluate conditions and select which set of instructions to follow. The last operator = is important to pay attention to. In mathmatics, when we say 2 = 2, we are saying that \"it is true that 2 is the same value as 2.\" A statement like \"2 + 2 = 7\" would not be true or valid in Math. In Python, the equals sign is an assignment operator and it means assign the value on the right to the entity on the left. So for example x = 2 is assigning the value 2 to the variable x. When assignment happens, we evaluate the expression on the right of the equals sign before we assign the value to the variable. So, x = input(\"what is your name?\") would first ask the user for input. Then once it receives input, that input would be assigned to the variable x. I would advice against trying to memorize all of these, but instead refer back to this document or the official Python documentation if you run into syntax errors. Variables Variables are a crucial concept in programming worth taking some time to think about. Anytime we have the computer do a calculation or some action, the data that is produced by that action needs to get stored somewhere. If you recall, our computer has two sites for storage: RAM (or system memory) and Long Term Storage (SSDs HDDS, etc). If I entered the following instruction into the python interpeter: >>> 2 * 2 4 >>> input(\"What is your name? \") What is your name? Dylan 'Dylan' >>> I ask it to multiply 2 and 2. The computer complies and prints the value to the screen. Then I ask the computer to prompt me for a name. It does so and I respond with the string 'Dylan.' The interpreter then prints that value to the screen. Each time the interpeter responds, and gives me a new empty prompt, it has forgotten what data has been generated UNLESS I explicitly ask the interpreter to save the value to memory. We do this with variables. A variable is a named location in system memory (RAM). As long as our program is running and the variable is in scope (we'll explain scope later), the computer will remember the data stored in the memory location identified by that name (unless we overwrite it). A quick example: let me capture the result of 2 times two. >>> y = 2 * 2 >>> y 4 >>> A variable can store a lot of different types of data. In a moment we'll look at data types. Python allows you to change the kind of data that is stored in a variable, but don't get in the habit of doing so. In other programming languages--specifically compiled languages--you have to define the data type in advance and then it cannot change. The key thing to remember is that in the context of a script, a variable stores data from line to line. Things get a little more complicated when we build functions, but don't worry about that yet. Likewise, when we use the Python CLI, variables stick around until you close that session. What happens once you close a session? Great question: once a script is finished running our you exit the session, the variables are tagged for deletion and you won't be able to access that data anymore. Likewise, if your computer loses power, the RAM is wiped and you lose anything that was only stored in that volatile memory. So, if you want some data to be retained after a sequence of instructions, you MUST write the data to some form of long term storage: either a file or a database or something else. We still have a ways to go before we get there. You'll see variables in the next chapter, and you by no means need to master them yet. You should start thinking of them as containers for data that can store various values, hence they are variable. For example, 2 is always 2 is always 2. Likewise the string \"Dylan\" is always a series of characters, specifically \"D\" \"y\" \"l\" \"a\" \"n\". They also have a static representation in binary, which is what the computer works with. The integer 2 is equivalent to 00000010 in binary. Likewise, \"Dylan\" is equal to \"01000100 01111001 01101100 01100001 01101110\" in binary when we use the ASCII/UTF-8 encoding (or the system for converting characters into binary). However, the variable x is just a name that you tell Python to remember that points to a particular address in memory that might hold 2 or \"Dylan\" or something else. Variables can be named whatever you like as long as you're not using reserved words, they don't start with anything but letters (upper or lower case), and they don't contain spaces. Generally, the name should have something to do with what kind of data it will store. For example, if I have a variable that will hold a number value, I'll probably call it num or if I have a variable holding a first name, I'd call it first_name or fname . These are arbitrary choices. One of the stylistic rules of Python is that your code should be easy to read, and a major part of that is using logical and descriptive variable names. You can always identify a variable with a comment instead, but it's much better to identify the variable with it's own name and then you don't need a comment. Data Types Python has primitive datatypes and complex. Complex data types are combinations of primitive data types. In this section, I will only discuss primitive data types. Integer: An integer is a whole number. It can be positive or negative. When we do math with integers, like division, for instance, and the result contains a decimal, the numbers after the decimal are dropped. Float: A number with a decimal place. It offers greater precision. 8 as an integer could be anything from 8 to 8.99... whereas 8. is exactly 8. String: This is a sequence of characters. It can contain spaces, and it is always surrounded by single or double quotes (they must match). Boolean: This is the True or False value. We use this regularly when we help teach a computer to make semi-autonomous decisions. Combinging these into groups and we can get complex data types. For now, however, it is simply worth knowing that they exist. Important Note You should know exactly what type of data a variable will contain. Python allows you to create a variable that could hold several different types of data. Other languages like C++ or Java do not. This has to do with how the compiler reserves memory for the variables. While you could allow a variable to contain at times a string and at other times and integer, it is bad practice. Errors You will get errors. Whenever you program, there will be times that you make mistakes. I'm not going to go into the kinds of mistakes right now in detail, but very frequently, the Python interpreter is smart enough to identify the mistake and throw and error message at you. These error messages were written by people and they're usually pretty terse. Let's look at a couple examples: $ python Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> python --version Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'python' is not defined >>> 2 .* 2 File \"<stdin>\", line 1 2 .* 2 ^ SyntaxError: invalid syntax >>> The first error gives us a \"Traceback\" message followed by a \"NameError\". I read errors from bottom to top. The bottom is the error message. From there, the message can be read from bottom to top. If an error gets thrown as a result of a series of instructions, the traceback from the moment of error to initial call will be long. Our first instinct, perhaps, when seeing error messages is to throw our hands up and say, \"OH! It's broken! I got it wrong.\" That's a totally normal instinct but it is not super helpful, and it will leave you feeling stressed out and unhappy. Instead, think of an error message as an invitation to learn. You're trying to do a thing, but Python, as much as it wants to understand you, can't understand you. You get to learn how to make yourself understood by the Python interpreter. I even sometimes read the error messages in a silly voice to make the Python interpreter seem more friendly. Let's look at the first error message. It says, \"NameError: name 'python' is not defined.\" This is telling me that there is a problem with the word that I used. I used a word that the Python interpreter doesn't know. Specifically, the Python interpreter doesn't know the word \"python\" (ironic, I know). Now, I would be left to think, what is this \"Python\" name that I'm calling in the previous command? My command was python --version meaning I want to call the Python interpreter to give me the version number. Well, I can't call the Python interpreter from within the Python interpreter because it's already running. This means I need to make this call from a different environment. I then realize that I call the Python interpreter from Bash and I realize, oh, python --version is a Bash command, not a Python command. I fix this by exiting the Python interpeter and trying again. (env) ~/Books/Python1$ python Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> python --version Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'python' is not defined >>> exit() (env) ~/Books/Python1$ python --version Python 3.8.2 (env) ~/Books/Python1$ The next error says, \"SyntaxError: invalid syntax\" which means that I wrote the code incorrectly. That's what a syntax error means. Python is great because look, it gives us exactly where the error is: 2 .* 2 ^ I accidentally added a period. Probably just a typo. I can fix this and be on my way. >>> 2 * 2 4 >>> I'm going over errors early because you'll encounter them a lot and how you respond will determine how much you struggle and suffer in learning Python. If you panic at error messages, the learning process will be less pleasant. If you take error messages as an opportunity to learn how to communicate with Python better, then it will be a more fun, but still challenging process. Now, you will definitely get error messages that you have no idea what they mean. I usually will then copy the error message and paste it into the Google search engine and see what other people did to solve this problem. Googling for answers is how programs really get written (even by the professionals), but learning how to search and read results on Google takes some time and practice. So practice now and be prepared for that. \"Tech wiz\" types frequently are not any more intelligent than anywone else. They usually just have a bit of experience and more importantly are really good at Googling. Humanities Check-in We've just gone through a good number of basic concepts in Python. We've looked at reserved words, operators, variables, primitive data types and errors. We also discussed how programming exists to solve problems or to train computers to help us solve problems. I want to focus for a while on how this relates to human culture. I want to start at data types. Every computer system has a set of data types it is able to work with. It must because the computer can only process calculations in binary, so the data we can store must be able to be represented in binary. If you remember the UTF-8 encoding of my first name (01000100 01111001 01101100 01100001 01101110) you'll see a series of 8 bit groupings, each grouping is a sequence of 1s and 0s that represent a letter. So \"D\" is encoded into binary as 01000100 using UTF-8 encoding. There are other codes that we might use, but UTF-8 is the common one. In turn, \"Dylan\" is an alphabetic encoding of a particular sequence of sounds that we've decided represent the human sitting here typing these words right now. So you can see, perhaps, that once we start using computers to help us with our lives, we have to be able to encode elements of our lives into the binary that computers store and run operations on. This is all fine, but there are a few things to consider. When I say \"Dylan Medina\" I am using a name that represents a complex organism. Is everything I am represented by that sequence of sounds or letters on a page? Probably not. Consider being a student: one of the major complaints students have at large Universities is that they are frequently treated as a number (a student id number). This complaint stems from the fact that the students feel like they are unique and complicated individuals who have cares and interests, but the administrative system is designed to identify them as a number for registration and finance purposes, etc. The same is true in many complex human systems where we have to deal with a lot of people, and we use ID numbers for the sake of convenience. Computers take this a step further insofar as they can only deal with binary representations of stuff. So, when a student goes to an advisor in the University, the advisor can simply treat them as a number, but they can also choose to listen to the student, empathize with them, understand the possible extenuating circumstances and make moral and ethical situations based on the whole student. That would be a good advisor. A computer cannot do this unless they are explicitly programed to be able to process the data representation of the extenuating circumstances and emotions of the student and then have preprogrammed responses to that \"whole student.\" We'll discuss this further when we get to flow control, but for now, what is important is how the world surrounding any given problem we are trying to solve with a computer gets encoded into something the computer can process. This means that we must be able to render the features of the world that we care about into either primitive data types or collections of primitive data types. Some things are quite easy to encode: things that are already numeric and have regular patterns. Other things are quite difficult to encode: the illocutionary force of a particular utterance--or the implied meaning of something someone says. Likewise, when we design a system, we make decisions on what kind of data we want to store. Strings, for example, require a considerable amount of memory, as do floats. Integers require less memory. Booleans are perhaps the most memory efficient because they can be stored in one bit (0 or 1). I want to consider an example that I think is interesting. Platforms that allow users to create profiles (e.g. social media) often have a field for gender. Early in social media days, they provided two options: male and female. This is because the people designing the system probably were not versed in or concerned about the notion of gender as a spectrum or non-binary or gender non-conforming individuals. Having a binary is convenient for developers because if I were designing a system that had to store data for billions of people, I would want to be as memory efficient as possible, and if we consider gender as a binary, the logical thing to do would be to store gender not as a string (male or female) but as a bit of binary (0 for male and 1 for female, for instance). Such a storage system then would only allow for a 0 or 1 and not any other option. Of course, people reasonably got upset by these kinds of systems and public outcry has forced change in interfaces and platforms to account for a more representative set of options, but that change required a redesign of both the frontend user interface (the website) AND the database structure. That is a considerable revision. This is not so say it isn't worth doing, but the most important point is that computers have limitations in how data can be represented and developers make choices based on the various strengths and limitations of their systems on which way to represent a particular kind of data. <soapbox> Our job as Digital Humanists is to be at the table when systems are being designed because we have some sense of how computers can encode human life and the world and because we are trained in humanities and social theories. One of the major roles of digital humanitists, I believe is to participate in design and development discussions to help make sure the technology that we build is just and equitable and humane. </soapbox>","title":"Encoding Identity"},{"location":"ch3/#encoding-identity","text":"In this chapter we're going to really begin diving into Python. We'll start with a bit of review of the basic syntax using the Python CLI. Then we will move into writing scripts. As we go, I will try to highlight considerations that humanists might have as we start learning the coding. One of the more interesting things, I believe, about programming is that most programming occurs because someone has a problem. For example, I have a problem that I have to transcribe a bunch of video lectures so that they have subtitles. It is a critical task, but it is also a pain. One solution to the problem is the painful task of manually transcribing the audio with my headphones and a transcription pedal. I type fast, but it is still not fun. Alternatively, I could write some code to pipe my audio files into a speech recognition engine (which itself is code) that will return the text of the speech. I could even maybe write code to put in timestamps automatically. The question that we have to answer, then, is at what point is it worth the effort to write the code to avoid the pain of transcription? How accurate must that automatic transcription system be to be worth implementing? Now, to get to the place where we can solve problems, we need to know a bit about the programming language's syntax and how to run it. That is the work of this program. We also need to be able to consider how our code can translate the real problems that humans encounter into the computations that computers can do. That is, we must figure out how to render the world into code so that the computer can help us. In this chapter, we're focusing on the basic computations that a computer can do along with the kind of data it can store. This is the first step of encoding the world. After that we'll move into more complex stuff.","title":"Encoding Identity"},{"location":"ch3/#what-is-programming","text":"Literally, programming is the process of writing a list of commands that a computer can execute in a programming language. The programmer uses some language that the computer can either interpret or understand directly. The list of instructions is the program. Pretty simple. Most programming languages have a set of known instructions built in. For example, when we write print(\"Hello, World\") we are telling Python to use the instructions that cause the computer to write text to the terminal to write the string \"Hello, World\" to our terminal. Likewise, Python, and most programming languages, knows that 8 * 8 means that it should evaluate the integer 8 multiplied by the integer 8 and the result should be printed to the terminal. As programmers, we are given both these built in instructions and we get the opportunity to build our own sets of instructions by combining the built in ones. We can also overwrite the instructions that are part of the programming language, but for our purposes, we will not be doing that. The built in instructions are a combination of human readable words and math symbols. These words and symbols do specific things. Here is a list of the words that are part of the Python language as \"reserved words\" or words that are part of the language that you cannot use when naming new variables: and del global not with as elif if or yield assert else import pass break except in raise class finally is return continue for lambda try def from nonlocal while Python also has many built in \"functions\" or sets of instructions that accomplish a particular task. print() was an example that I used above. Likewise, the format() function allows us to format and add variables to a string. We'll talk about those in a bit, and I will not list all of the built in functions that are part of Python here as that would be too much. Instead it is better to know that built in functions exists, and when you're trying to do something new it's worth checking to see if there's already a built in function for that. Python also uses a bunch of \"math\" characters. These characters are called operators and they have special functionality in the language. Here are the major operators: +, -, *, / Addition, subtraction, multiplication, and division operators. x + y returns the sum of x and y. x**y Exponent operator. The interpreter returns x raised to the yth power x % y The modulo operator returns the remainder of x divided by y x == y Equality operator. The interpreter returns True if x and y are equal x != y Not equal. Returns True if x is not equal to y >, <, >=, <= Greater than, less than, greater than or equal to, less than or equal to. The same as math. x = y Assignment operator. NOTE: This isn't the same as math. It doesn't evaluate equality, but assigns the value of y to the variable x The first three sets of operators are used to perform calculations. The next 3 sets of operators ask the interpreter to evaluate equality and return True or False based on the evaluation. So 2 == 2 would return True, and 2 > 20 would return False. We use these to evaluate conditions and select which set of instructions to follow. The last operator = is important to pay attention to. In mathmatics, when we say 2 = 2, we are saying that \"it is true that 2 is the same value as 2.\" A statement like \"2 + 2 = 7\" would not be true or valid in Math. In Python, the equals sign is an assignment operator and it means assign the value on the right to the entity on the left. So for example x = 2 is assigning the value 2 to the variable x. When assignment happens, we evaluate the expression on the right of the equals sign before we assign the value to the variable. So, x = input(\"what is your name?\") would first ask the user for input. Then once it receives input, that input would be assigned to the variable x. I would advice against trying to memorize all of these, but instead refer back to this document or the official Python documentation if you run into syntax errors.","title":"What is Programming?"},{"location":"ch3/#variables","text":"Variables are a crucial concept in programming worth taking some time to think about. Anytime we have the computer do a calculation or some action, the data that is produced by that action needs to get stored somewhere. If you recall, our computer has two sites for storage: RAM (or system memory) and Long Term Storage (SSDs HDDS, etc). If I entered the following instruction into the python interpeter: >>> 2 * 2 4 >>> input(\"What is your name? \") What is your name? Dylan 'Dylan' >>> I ask it to multiply 2 and 2. The computer complies and prints the value to the screen. Then I ask the computer to prompt me for a name. It does so and I respond with the string 'Dylan.' The interpreter then prints that value to the screen. Each time the interpeter responds, and gives me a new empty prompt, it has forgotten what data has been generated UNLESS I explicitly ask the interpreter to save the value to memory. We do this with variables. A variable is a named location in system memory (RAM). As long as our program is running and the variable is in scope (we'll explain scope later), the computer will remember the data stored in the memory location identified by that name (unless we overwrite it). A quick example: let me capture the result of 2 times two. >>> y = 2 * 2 >>> y 4 >>> A variable can store a lot of different types of data. In a moment we'll look at data types. Python allows you to change the kind of data that is stored in a variable, but don't get in the habit of doing so. In other programming languages--specifically compiled languages--you have to define the data type in advance and then it cannot change. The key thing to remember is that in the context of a script, a variable stores data from line to line. Things get a little more complicated when we build functions, but don't worry about that yet. Likewise, when we use the Python CLI, variables stick around until you close that session. What happens once you close a session? Great question: once a script is finished running our you exit the session, the variables are tagged for deletion and you won't be able to access that data anymore. Likewise, if your computer loses power, the RAM is wiped and you lose anything that was only stored in that volatile memory. So, if you want some data to be retained after a sequence of instructions, you MUST write the data to some form of long term storage: either a file or a database or something else. We still have a ways to go before we get there. You'll see variables in the next chapter, and you by no means need to master them yet. You should start thinking of them as containers for data that can store various values, hence they are variable. For example, 2 is always 2 is always 2. Likewise the string \"Dylan\" is always a series of characters, specifically \"D\" \"y\" \"l\" \"a\" \"n\". They also have a static representation in binary, which is what the computer works with. The integer 2 is equivalent to 00000010 in binary. Likewise, \"Dylan\" is equal to \"01000100 01111001 01101100 01100001 01101110\" in binary when we use the ASCII/UTF-8 encoding (or the system for converting characters into binary). However, the variable x is just a name that you tell Python to remember that points to a particular address in memory that might hold 2 or \"Dylan\" or something else. Variables can be named whatever you like as long as you're not using reserved words, they don't start with anything but letters (upper or lower case), and they don't contain spaces. Generally, the name should have something to do with what kind of data it will store. For example, if I have a variable that will hold a number value, I'll probably call it num or if I have a variable holding a first name, I'd call it first_name or fname . These are arbitrary choices. One of the stylistic rules of Python is that your code should be easy to read, and a major part of that is using logical and descriptive variable names. You can always identify a variable with a comment instead, but it's much better to identify the variable with it's own name and then you don't need a comment.","title":"Variables"},{"location":"ch3/#data-types","text":"Python has primitive datatypes and complex. Complex data types are combinations of primitive data types. In this section, I will only discuss primitive data types. Integer: An integer is a whole number. It can be positive or negative. When we do math with integers, like division, for instance, and the result contains a decimal, the numbers after the decimal are dropped. Float: A number with a decimal place. It offers greater precision. 8 as an integer could be anything from 8 to 8.99... whereas 8. is exactly 8. String: This is a sequence of characters. It can contain spaces, and it is always surrounded by single or double quotes (they must match). Boolean: This is the True or False value. We use this regularly when we help teach a computer to make semi-autonomous decisions. Combinging these into groups and we can get complex data types. For now, however, it is simply worth knowing that they exist. Important Note You should know exactly what type of data a variable will contain. Python allows you to create a variable that could hold several different types of data. Other languages like C++ or Java do not. This has to do with how the compiler reserves memory for the variables. While you could allow a variable to contain at times a string and at other times and integer, it is bad practice.","title":"Data Types"},{"location":"ch3/#errors","text":"You will get errors. Whenever you program, there will be times that you make mistakes. I'm not going to go into the kinds of mistakes right now in detail, but very frequently, the Python interpreter is smart enough to identify the mistake and throw and error message at you. These error messages were written by people and they're usually pretty terse. Let's look at a couple examples: $ python Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> python --version Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'python' is not defined >>> 2 .* 2 File \"<stdin>\", line 1 2 .* 2 ^ SyntaxError: invalid syntax >>> The first error gives us a \"Traceback\" message followed by a \"NameError\". I read errors from bottom to top. The bottom is the error message. From there, the message can be read from bottom to top. If an error gets thrown as a result of a series of instructions, the traceback from the moment of error to initial call will be long. Our first instinct, perhaps, when seeing error messages is to throw our hands up and say, \"OH! It's broken! I got it wrong.\" That's a totally normal instinct but it is not super helpful, and it will leave you feeling stressed out and unhappy. Instead, think of an error message as an invitation to learn. You're trying to do a thing, but Python, as much as it wants to understand you, can't understand you. You get to learn how to make yourself understood by the Python interpreter. I even sometimes read the error messages in a silly voice to make the Python interpreter seem more friendly. Let's look at the first error message. It says, \"NameError: name 'python' is not defined.\" This is telling me that there is a problem with the word that I used. I used a word that the Python interpreter doesn't know. Specifically, the Python interpreter doesn't know the word \"python\" (ironic, I know). Now, I would be left to think, what is this \"Python\" name that I'm calling in the previous command? My command was python --version meaning I want to call the Python interpreter to give me the version number. Well, I can't call the Python interpreter from within the Python interpreter because it's already running. This means I need to make this call from a different environment. I then realize that I call the Python interpreter from Bash and I realize, oh, python --version is a Bash command, not a Python command. I fix this by exiting the Python interpeter and trying again. (env) ~/Books/Python1$ python Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> python --version Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'python' is not defined >>> exit() (env) ~/Books/Python1$ python --version Python 3.8.2 (env) ~/Books/Python1$ The next error says, \"SyntaxError: invalid syntax\" which means that I wrote the code incorrectly. That's what a syntax error means. Python is great because look, it gives us exactly where the error is: 2 .* 2 ^ I accidentally added a period. Probably just a typo. I can fix this and be on my way. >>> 2 * 2 4 >>> I'm going over errors early because you'll encounter them a lot and how you respond will determine how much you struggle and suffer in learning Python. If you panic at error messages, the learning process will be less pleasant. If you take error messages as an opportunity to learn how to communicate with Python better, then it will be a more fun, but still challenging process. Now, you will definitely get error messages that you have no idea what they mean. I usually will then copy the error message and paste it into the Google search engine and see what other people did to solve this problem. Googling for answers is how programs really get written (even by the professionals), but learning how to search and read results on Google takes some time and practice. So practice now and be prepared for that. \"Tech wiz\" types frequently are not any more intelligent than anywone else. They usually just have a bit of experience and more importantly are really good at Googling.","title":"Errors"},{"location":"ch3/#humanities-check-in","text":"We've just gone through a good number of basic concepts in Python. We've looked at reserved words, operators, variables, primitive data types and errors. We also discussed how programming exists to solve problems or to train computers to help us solve problems. I want to focus for a while on how this relates to human culture. I want to start at data types. Every computer system has a set of data types it is able to work with. It must because the computer can only process calculations in binary, so the data we can store must be able to be represented in binary. If you remember the UTF-8 encoding of my first name (01000100 01111001 01101100 01100001 01101110) you'll see a series of 8 bit groupings, each grouping is a sequence of 1s and 0s that represent a letter. So \"D\" is encoded into binary as 01000100 using UTF-8 encoding. There are other codes that we might use, but UTF-8 is the common one. In turn, \"Dylan\" is an alphabetic encoding of a particular sequence of sounds that we've decided represent the human sitting here typing these words right now. So you can see, perhaps, that once we start using computers to help us with our lives, we have to be able to encode elements of our lives into the binary that computers store and run operations on. This is all fine, but there are a few things to consider. When I say \"Dylan Medina\" I am using a name that represents a complex organism. Is everything I am represented by that sequence of sounds or letters on a page? Probably not. Consider being a student: one of the major complaints students have at large Universities is that they are frequently treated as a number (a student id number). This complaint stems from the fact that the students feel like they are unique and complicated individuals who have cares and interests, but the administrative system is designed to identify them as a number for registration and finance purposes, etc. The same is true in many complex human systems where we have to deal with a lot of people, and we use ID numbers for the sake of convenience. Computers take this a step further insofar as they can only deal with binary representations of stuff. So, when a student goes to an advisor in the University, the advisor can simply treat them as a number, but they can also choose to listen to the student, empathize with them, understand the possible extenuating circumstances and make moral and ethical situations based on the whole student. That would be a good advisor. A computer cannot do this unless they are explicitly programed to be able to process the data representation of the extenuating circumstances and emotions of the student and then have preprogrammed responses to that \"whole student.\" We'll discuss this further when we get to flow control, but for now, what is important is how the world surrounding any given problem we are trying to solve with a computer gets encoded into something the computer can process. This means that we must be able to render the features of the world that we care about into either primitive data types or collections of primitive data types. Some things are quite easy to encode: things that are already numeric and have regular patterns. Other things are quite difficult to encode: the illocutionary force of a particular utterance--or the implied meaning of something someone says. Likewise, when we design a system, we make decisions on what kind of data we want to store. Strings, for example, require a considerable amount of memory, as do floats. Integers require less memory. Booleans are perhaps the most memory efficient because they can be stored in one bit (0 or 1). I want to consider an example that I think is interesting. Platforms that allow users to create profiles (e.g. social media) often have a field for gender. Early in social media days, they provided two options: male and female. This is because the people designing the system probably were not versed in or concerned about the notion of gender as a spectrum or non-binary or gender non-conforming individuals. Having a binary is convenient for developers because if I were designing a system that had to store data for billions of people, I would want to be as memory efficient as possible, and if we consider gender as a binary, the logical thing to do would be to store gender not as a string (male or female) but as a bit of binary (0 for male and 1 for female, for instance). Such a storage system then would only allow for a 0 or 1 and not any other option. Of course, people reasonably got upset by these kinds of systems and public outcry has forced change in interfaces and platforms to account for a more representative set of options, but that change required a redesign of both the frontend user interface (the website) AND the database structure. That is a considerable revision. This is not so say it isn't worth doing, but the most important point is that computers have limitations in how data can be represented and developers make choices based on the various strengths and limitations of their systems on which way to represent a particular kind of data. <soapbox> Our job as Digital Humanists is to be at the table when systems are being designed because we have some sense of how computers can encode human life and the world and because we are trained in humanities and social theories. One of the major roles of digital humanitists, I believe is to participate in design and development discussions to help make sure the technology that we build is just and equitable and humane. </soapbox>","title":"Humanities Check-in"},{"location":"ch4/","text":"Really getting into Python Now In the last chapter we discussed Python in pretty abstract terms. In this chapter, we are going to start using it and applying some of those abstract concepts. I'm going to first show you a bit about the interpreter. Then I'm going to show you the anatomy of a Python script, and finally, we'll build a simple Python program that helps us convert speed limits. I recommend you follow along as we go. Start in the interpreter I like to start playing with Python in the interpreter. This section will be pretty short, but I'll give you a bunch of lines in Python, which you should try for yourself. Then I'll translate those lines into plain English. >>> print(\"Hello, Dylan\") Hello, Dylan >>> 2 * 2 4 >>> 2 + 2 * 27 56 >>> 2 - 2 0 >>> 12 % 5 2 >>> 12 % 2 0 >>> 13 % 2 1 >>> 12 % 2 == 0 True >>> x = 27 >>> x % 2 == 0 False >>> input(\"What is your name\") What is your nameDylan 'Dylan' >>> n = input(\"What is your name? \") What is your name? Dylan >>> n 'Dylan' >>> print(\"Hello, \" + n) Hello, Dylan >>> n == \"Dylan\" True Me: Please print \"Hello, Dylan\" Python Interpreter (PI): Hello, Dylan Me: Calculate the product of 2 and 2 PI: 4 Me: Calculate the sum of 2 and 2 times 27 ( Note: Order of operations is PEMDAS just like in math). PI: 56 (Not 108) Me: Calculate 2 minus 2 PI: 0 Me: Calculate the remainder of 12 divided by 5 PI: 2 Me: Calculate the remainder of 12 divided by 2 PI: 0 Me: Calculate the remainder of 13 divided by 2 PI: 1 Me: Evaluate if the remainder of 12 divided by 2 is 0 PI: True (The remainder of 12 divided by 2 is 0) Me: Create a variable called 'x' and assign the value 27 to it PI: (Done) Me: Evaluate if the remainder of the value stored in the variable x divided by 2 is 0 ( Note: This is a really cool way to check if a number is even or not) PI: False Me: Prompt the user for some input with the prompt \"What is your name\" PI: What is your name (Waits for a response) Me: Dylan PI: Your input was Dylan Me: Create a variable called 'n' and prompt the user for input with the prompt \"What is your name? \" and when they respond store that response to the variable n. PI: *What is your name? * (Waits for a response) Me: Dylan PI: (Stores 'Dylan' to the variable n) Me: What's n? PI: Dylan Me: Print the string \"Hello, \" plus whatever value is stored in 'n' PI: Hello, Dylan Me: *Evaluate if the value stored in 'n' is 'Dylan' PI: 'True' That's all pretty much straightforward. You'll notice I added some notes in the parentheses to explain what's going on. Of course, the Python CLI is cool, but once we exit out of it, all the work we did was lost unless we explicitly saved stuff to a file. Wouldn't it be nice if we could write a set of commands that could be run over and over again without having to type them in manually each time? Yes, indeed! That's where Python scripts come in to play. The Anatomy of a Python Script While we can issue Python commands directly to the Python interpreter in the Python Terminal, we can also write Python to a file that the interpreter will execute. A few things to know: Python files are text files with the file extension .py. A file extension is like .docx or .pdf. They tell the computer what type of file this is. Python files contain a sequence of instructions that are executed in the order they are written. When we execute a Python program, we call the file in Bash using the Python program. Next, the general layout of a Python program is as follows: test.py #!/usr/bin/env python3 # This is a comment. Any line beginning with a hashtag is # ignored by the interpreter. # At the top of our file we usually have import statements # if any. import requests # Next we will have our instructions. In more complicated # programs these will usually reside in Functions, or # reusible bundles of code. I'll give you an example of # that here. def website_checker(url): r = requests.get(url) if r.status_code == 200: return True return False # The instructions section is usually quite long. # Finally, we *might* have a driver section, or the section # that calls the functions if there are functions. if __name__ == \"__main__\": print(website_checker('https://www.google.com')) In the above program, I have demonstrated the general format of a python script. The very first line is the shebang line. It is not required, but frequently is included in standalone scripts. It serves two purposes: It allows you to run the script without invoking Python first. Instead of typing $ python3 my_script.py the shebang line allows you to simply type $ ./my_script.py to run the script. The Shebang line tells Bash which program to use to interpret the code. It tells someone who reads your code what interpreter this code was written for. The shebang line is not usually included in multifile programs, and I usually only include it in small, utility scripts that I write. Also, if we use the virtual environment, we can run into trouble because if you look closely, the shebang line tries to use the most recent Python 3 executable in the global environment. Support for pointing to the executable in the virtual environment in the shebang line ( #!env/bin/ python3 ) is not recommended practice. So likewise, if I'm writing a program that uses a virtual environment, I'll usually also leave off the shebang. Next, we import any libraries at the top. In this case, I've imported the library that allows me to request data from websites. Note: Sometimes we wait to import libraries until later. We'll discuss this later. The second section is where we have the instructions of our program. This is the code that tells the computer what we want it to do. Frequently the instruction section will contain functions, which we discuss in a couple chapters. Sometimes, the instructions are executed on the fly rather than stored in a function. Finally, the driver section exists if you need to call those functions. In larger programs, the driver section is frequently a separate file, and you might actually have a bunch of different files that are make up different parts of your program, but more on that later. Building a Python Program For this chapter, we're going to start with a script that just contains the instructions section without any imports. For my example, I'm going to create a calculator that will allow the user to convert between Kilometers per hour (KPH) and Miles per hour (MPH). Now this is a real problem, perhaps for someone who is accustomed to driving in the USA and is moving to Canada or Europe. How fast is 100KPH really? The first step is to break down the problem. This is called decomposition . I will decompose the problem into a series of steps that the computer needs to help me solve. The program needs to know the original unit and the converted unit. So, I need to know if we're going from MPH to KPH or KPH to MPH. The program needs to know the original value. Is it 60? 100? 80? The program needs to contain the calculations in both directions. I'll look those up on Google. Based on the information the program needs to know, it will have two variables: the original unit and the original value. Now I'm going to write up what is called a user story. This is part of the Agile software development paradigm, and it is the story of a user interacting with the program. My name is John, and I occasionally drive my vehicle from the United States to Canada. When I am there, I have a hard time with the speed limit conversion. So, I open the program, and it prompts me whether I want to convert FROM KPH or MPH. I am in Canada, so I need to convert from KPH to MPH. The program then prompts me for the speed limit. I enter it, and it prints out the speed limit in MPH. I really don't want to worry about decimals, so I need to make sure it rounds. Ok, now that I have a sense of what the program needs to do, I need to create a file to hold this script. First I create a project directory and a file to hold my code. I'm not going to worry about a virtual environment because I don't anticipate this is going to be a very large project. Then I need to open the directory with VS Code. ~$ mkdir speed && cd speed ~/speed/$ touch speed_converter.py ~/speed/$ ls speed_converter.py ~/speed/$ code . The first command, again, creates a directory and changes into that directory. The second command creates the file called speed_converter.py. It is a python script. The name is arbitrary but logical. Next, I use the ls command to show you that the file was created. I wouldn't probably actually do this in real life, and it's not necessary to check every time you create a file. You can always do it if you want, but not required. Finally, I open VS Code with the code command. I pass that command an argument: . which means open the local directory. A VS Code window opens and I click on my python script in the file explorer pane to open it in the text editor pane. You'll see it is empty, so I'm going to start writing in a bunch of comments to help me code. speed_converter.py #!/usr/bin/env python3 # Prompt user for original limit and save to variable. # Prompt user for original value and save to variable. # If the original limit is KPH use this expression. # output = value * 0.62137 # If the original limit is MPH use this expression. # output = value * 1.60934 # convert output to integer # print output Okay, so I now have all the steps that I need my program to take. I will walk through each of these and turn them into code. For the book here, I will do them all at once, but in practice, I go through step by step. If I don't know how to do something, I will search for it on Google. For instance, if I don't know how to get input from a user, I might search for \"get user input in python3\". speed_converter.py #!/usr/bin/env python3 # Prompt user for original units and save to variable. units = input(\"Are you converting from KPH to MPH? (Y/n)\") # Prompt user for original value and save to variable. value = input(\"What is the original speed limit? \") # If the original limit is KPH use this expression. if units != \"n\" or units != \"N\": output = value * 0.62137 # If the original limit is MPH use this expression. if units == \"n\" or units == \"N\": output = value * 1.60934 # convert output to integer output = int(output) # print output print(output) Okay, so I have workable code. I can run it now and see how it works. $python3 speed_converter.py Are you converting from KPH to MPH? (Y/n)Y What is the original speed limit? 100 Traceback (most recent call last): File \"speed_converter.py\", line 9, in <module> output = value * 0.62137 TypeError: can't multiply sequence by non-int of type 'float' Ok, so I have an error. I need to look at the error. I see that I have a type error, which means that my data in the expression output = value * 0.62137 is the wrong type. The issue is either with value or the floating point number. I'm guessing it is probably the value because I know that I can multiply integers with floats. I need to look at the input() function and see what kind of data is getting stored in value when I get data from the user. You can look it up if you like. Welcome back. The problem, of course, is that input() returns a string. This means that the data type stored in value is a string. I know that strings cannot be multiplied by decimals. Instead, I need to convert whatever I'm getting from the input function from a string to a float or integer. Let's do some revision, or refactoring of the code. I'm also going to adjust a couple other things with my logic checks at the same time. speed_converter.py #!/usr/bin/env python3 # Prompt user for original units and save to variable. units = input(\"Are you converting from KPH to MPH? (Y/n)\") # Prompt user for original value and save to variable. value = int(input(\"What is the original speed limit? \")) # If the original limit is MPH use this expression. if units == \"n\" or units == \"N\": output = value * 1.60934 # If the original limit is KPH use this expression. else: output = value * 0.62137 # convert output to integer output = int(output) # print output print(output) Now we run it again and see that it works this time. $ python3 speed_converter.py Are you converting from KPH to MPH? (Y/n)y What is the original speed limit? 100 62 I'll quickly walk through the code. Line one is the shebang line, but since I run the script with the python interpreter from my command, I don't need this. Line two prompts the user for input. I let them know that the default is \"Y\" for KPH to MPH. Line three prompts the user for the original speed limit and immediately converts their response to an integer. Line four checks if the user entered either \"n\" or \"N\" into the prompt on line two. If so, we're converting from MPH to KPH. The calculation is run. Line 6 is \"else\" which is the default condition if the user didn't enter \"n\" or \"N\". In that case, we calculate from KPH to MPH. Finally, regardless we convert from the floating point value in output to an integer so that we don't have to worry about a decimal, and print out the results. So that's your first Python script that does some decision making. In the next chapters we'll dive into decision making, but for now, you can see we have already built a pretty cool program that could be applied to any sort of conversion problem. In the next section, as we discuss conditions there will be a great deal to say regarding concerns of the Humanities and human culture. Until then, practice and enjoy! Can you maybe modify our code to convert for something else (currency? temperature? etc.)","title":"Anatomy of a Script"},{"location":"ch4/#really-getting-into-python-now","text":"In the last chapter we discussed Python in pretty abstract terms. In this chapter, we are going to start using it and applying some of those abstract concepts. I'm going to first show you a bit about the interpreter. Then I'm going to show you the anatomy of a Python script, and finally, we'll build a simple Python program that helps us convert speed limits. I recommend you follow along as we go.","title":"Really getting into Python Now"},{"location":"ch4/#start-in-the-interpreter","text":"I like to start playing with Python in the interpreter. This section will be pretty short, but I'll give you a bunch of lines in Python, which you should try for yourself. Then I'll translate those lines into plain English. >>> print(\"Hello, Dylan\") Hello, Dylan >>> 2 * 2 4 >>> 2 + 2 * 27 56 >>> 2 - 2 0 >>> 12 % 5 2 >>> 12 % 2 0 >>> 13 % 2 1 >>> 12 % 2 == 0 True >>> x = 27 >>> x % 2 == 0 False >>> input(\"What is your name\") What is your nameDylan 'Dylan' >>> n = input(\"What is your name? \") What is your name? Dylan >>> n 'Dylan' >>> print(\"Hello, \" + n) Hello, Dylan >>> n == \"Dylan\" True Me: Please print \"Hello, Dylan\" Python Interpreter (PI): Hello, Dylan Me: Calculate the product of 2 and 2 PI: 4 Me: Calculate the sum of 2 and 2 times 27 ( Note: Order of operations is PEMDAS just like in math). PI: 56 (Not 108) Me: Calculate 2 minus 2 PI: 0 Me: Calculate the remainder of 12 divided by 5 PI: 2 Me: Calculate the remainder of 12 divided by 2 PI: 0 Me: Calculate the remainder of 13 divided by 2 PI: 1 Me: Evaluate if the remainder of 12 divided by 2 is 0 PI: True (The remainder of 12 divided by 2 is 0) Me: Create a variable called 'x' and assign the value 27 to it PI: (Done) Me: Evaluate if the remainder of the value stored in the variable x divided by 2 is 0 ( Note: This is a really cool way to check if a number is even or not) PI: False Me: Prompt the user for some input with the prompt \"What is your name\" PI: What is your name (Waits for a response) Me: Dylan PI: Your input was Dylan Me: Create a variable called 'n' and prompt the user for input with the prompt \"What is your name? \" and when they respond store that response to the variable n. PI: *What is your name? * (Waits for a response) Me: Dylan PI: (Stores 'Dylan' to the variable n) Me: What's n? PI: Dylan Me: Print the string \"Hello, \" plus whatever value is stored in 'n' PI: Hello, Dylan Me: *Evaluate if the value stored in 'n' is 'Dylan' PI: 'True' That's all pretty much straightforward. You'll notice I added some notes in the parentheses to explain what's going on. Of course, the Python CLI is cool, but once we exit out of it, all the work we did was lost unless we explicitly saved stuff to a file. Wouldn't it be nice if we could write a set of commands that could be run over and over again without having to type them in manually each time? Yes, indeed! That's where Python scripts come in to play.","title":"Start in the interpreter"},{"location":"ch4/#the-anatomy-of-a-python-script","text":"While we can issue Python commands directly to the Python interpreter in the Python Terminal, we can also write Python to a file that the interpreter will execute. A few things to know: Python files are text files with the file extension .py. A file extension is like .docx or .pdf. They tell the computer what type of file this is. Python files contain a sequence of instructions that are executed in the order they are written. When we execute a Python program, we call the file in Bash using the Python program. Next, the general layout of a Python program is as follows: test.py #!/usr/bin/env python3 # This is a comment. Any line beginning with a hashtag is # ignored by the interpreter. # At the top of our file we usually have import statements # if any. import requests # Next we will have our instructions. In more complicated # programs these will usually reside in Functions, or # reusible bundles of code. I'll give you an example of # that here. def website_checker(url): r = requests.get(url) if r.status_code == 200: return True return False # The instructions section is usually quite long. # Finally, we *might* have a driver section, or the section # that calls the functions if there are functions. if __name__ == \"__main__\": print(website_checker('https://www.google.com')) In the above program, I have demonstrated the general format of a python script. The very first line is the shebang line. It is not required, but frequently is included in standalone scripts. It serves two purposes: It allows you to run the script without invoking Python first. Instead of typing $ python3 my_script.py the shebang line allows you to simply type $ ./my_script.py to run the script. The Shebang line tells Bash which program to use to interpret the code. It tells someone who reads your code what interpreter this code was written for. The shebang line is not usually included in multifile programs, and I usually only include it in small, utility scripts that I write. Also, if we use the virtual environment, we can run into trouble because if you look closely, the shebang line tries to use the most recent Python 3 executable in the global environment. Support for pointing to the executable in the virtual environment in the shebang line ( #!env/bin/ python3 ) is not recommended practice. So likewise, if I'm writing a program that uses a virtual environment, I'll usually also leave off the shebang. Next, we import any libraries at the top. In this case, I've imported the library that allows me to request data from websites. Note: Sometimes we wait to import libraries until later. We'll discuss this later. The second section is where we have the instructions of our program. This is the code that tells the computer what we want it to do. Frequently the instruction section will contain functions, which we discuss in a couple chapters. Sometimes, the instructions are executed on the fly rather than stored in a function. Finally, the driver section exists if you need to call those functions. In larger programs, the driver section is frequently a separate file, and you might actually have a bunch of different files that are make up different parts of your program, but more on that later.","title":"The Anatomy of a Python Script"},{"location":"ch4/#building-a-python-program","text":"For this chapter, we're going to start with a script that just contains the instructions section without any imports. For my example, I'm going to create a calculator that will allow the user to convert between Kilometers per hour (KPH) and Miles per hour (MPH). Now this is a real problem, perhaps for someone who is accustomed to driving in the USA and is moving to Canada or Europe. How fast is 100KPH really? The first step is to break down the problem. This is called decomposition . I will decompose the problem into a series of steps that the computer needs to help me solve. The program needs to know the original unit and the converted unit. So, I need to know if we're going from MPH to KPH or KPH to MPH. The program needs to know the original value. Is it 60? 100? 80? The program needs to contain the calculations in both directions. I'll look those up on Google. Based on the information the program needs to know, it will have two variables: the original unit and the original value. Now I'm going to write up what is called a user story. This is part of the Agile software development paradigm, and it is the story of a user interacting with the program. My name is John, and I occasionally drive my vehicle from the United States to Canada. When I am there, I have a hard time with the speed limit conversion. So, I open the program, and it prompts me whether I want to convert FROM KPH or MPH. I am in Canada, so I need to convert from KPH to MPH. The program then prompts me for the speed limit. I enter it, and it prints out the speed limit in MPH. I really don't want to worry about decimals, so I need to make sure it rounds. Ok, now that I have a sense of what the program needs to do, I need to create a file to hold this script. First I create a project directory and a file to hold my code. I'm not going to worry about a virtual environment because I don't anticipate this is going to be a very large project. Then I need to open the directory with VS Code. ~$ mkdir speed && cd speed ~/speed/$ touch speed_converter.py ~/speed/$ ls speed_converter.py ~/speed/$ code . The first command, again, creates a directory and changes into that directory. The second command creates the file called speed_converter.py. It is a python script. The name is arbitrary but logical. Next, I use the ls command to show you that the file was created. I wouldn't probably actually do this in real life, and it's not necessary to check every time you create a file. You can always do it if you want, but not required. Finally, I open VS Code with the code command. I pass that command an argument: . which means open the local directory. A VS Code window opens and I click on my python script in the file explorer pane to open it in the text editor pane. You'll see it is empty, so I'm going to start writing in a bunch of comments to help me code. speed_converter.py #!/usr/bin/env python3 # Prompt user for original limit and save to variable. # Prompt user for original value and save to variable. # If the original limit is KPH use this expression. # output = value * 0.62137 # If the original limit is MPH use this expression. # output = value * 1.60934 # convert output to integer # print output Okay, so I now have all the steps that I need my program to take. I will walk through each of these and turn them into code. For the book here, I will do them all at once, but in practice, I go through step by step. If I don't know how to do something, I will search for it on Google. For instance, if I don't know how to get input from a user, I might search for \"get user input in python3\". speed_converter.py #!/usr/bin/env python3 # Prompt user for original units and save to variable. units = input(\"Are you converting from KPH to MPH? (Y/n)\") # Prompt user for original value and save to variable. value = input(\"What is the original speed limit? \") # If the original limit is KPH use this expression. if units != \"n\" or units != \"N\": output = value * 0.62137 # If the original limit is MPH use this expression. if units == \"n\" or units == \"N\": output = value * 1.60934 # convert output to integer output = int(output) # print output print(output) Okay, so I have workable code. I can run it now and see how it works. $python3 speed_converter.py Are you converting from KPH to MPH? (Y/n)Y What is the original speed limit? 100 Traceback (most recent call last): File \"speed_converter.py\", line 9, in <module> output = value * 0.62137 TypeError: can't multiply sequence by non-int of type 'float' Ok, so I have an error. I need to look at the error. I see that I have a type error, which means that my data in the expression output = value * 0.62137 is the wrong type. The issue is either with value or the floating point number. I'm guessing it is probably the value because I know that I can multiply integers with floats. I need to look at the input() function and see what kind of data is getting stored in value when I get data from the user. You can look it up if you like. Welcome back. The problem, of course, is that input() returns a string. This means that the data type stored in value is a string. I know that strings cannot be multiplied by decimals. Instead, I need to convert whatever I'm getting from the input function from a string to a float or integer. Let's do some revision, or refactoring of the code. I'm also going to adjust a couple other things with my logic checks at the same time. speed_converter.py #!/usr/bin/env python3 # Prompt user for original units and save to variable. units = input(\"Are you converting from KPH to MPH? (Y/n)\") # Prompt user for original value and save to variable. value = int(input(\"What is the original speed limit? \")) # If the original limit is MPH use this expression. if units == \"n\" or units == \"N\": output = value * 1.60934 # If the original limit is KPH use this expression. else: output = value * 0.62137 # convert output to integer output = int(output) # print output print(output) Now we run it again and see that it works this time. $ python3 speed_converter.py Are you converting from KPH to MPH? (Y/n)y What is the original speed limit? 100 62 I'll quickly walk through the code. Line one is the shebang line, but since I run the script with the python interpreter from my command, I don't need this. Line two prompts the user for input. I let them know that the default is \"Y\" for KPH to MPH. Line three prompts the user for the original speed limit and immediately converts their response to an integer. Line four checks if the user entered either \"n\" or \"N\" into the prompt on line two. If so, we're converting from MPH to KPH. The calculation is run. Line 6 is \"else\" which is the default condition if the user didn't enter \"n\" or \"N\". In that case, we calculate from KPH to MPH. Finally, regardless we convert from the floating point value in output to an integer so that we don't have to worry about a decimal, and print out the results. So that's your first Python script that does some decision making. In the next chapters we'll dive into decision making, but for now, you can see we have already built a pretty cool program that could be applied to any sort of conversion problem. In the next section, as we discuss conditions there will be a great deal to say regarding concerns of the Humanities and human culture. Until then, practice and enjoy! Can you maybe modify our code to convert for something else (currency? temperature? etc.)","title":"Building a Python Program"},{"location":"ch5/","text":"Conditionals Introduction to Flow Control Thus far, we've basically told the computer what to do and it has done it basically as we requested. However, in programming, one of our goals is to turn over more of the work to computers. We saw this a little bit with our speed conversion program. Instead of writing two different programs, one for MPH to KPH and another for KPH to MPH, we wrote one program with a decision in it that allowed the computer to decide which calculation to perform based on the user's input. This ability of a computer to make decisions based on input is a central part of flow control . Flow control refers to the controls that we build into our program that tell the computer when and how many times to execute a particular group of instructions. There are two separate parts of flow control: conditionals, which tell the computer to execute instructions based on a set of conditions, and iterators or loops, which tell the computer to execute instructions while a particular condition is true or for a particular number of times. Generally, a flow control structure involves a few parts. There will be the reserved word in Python like if\\else\\while\\for\\try and then there will be a condition that is evaluated. Finally, there will be one or more blocks of code that could potentially be executed depending on the evaluation of the condition. Here is an example of the general format: {reserved word} {condition}: {code block} {other reserved word} A small example in Python: if x == 0: print(\"X is zero\") The reserved word defines what kind of flow control is being executed. The flow of the program will either branch with one block of instructions being conditionally executed or not, or it will loop with a sequence of instructions being repeted a number of times until some condition is met. In this chapter, we'll look at the first. In the next chapter we'll look at the second. Conditionals: If/Else To set the stage, let's say my user wants to figure out if one number is a factor of another number. A number is a factor if the second number can be divided evenly by the first. So, 4 is a factor of 12 because 12 can be evenly divided by 4. Programming languages give us the % (mod) operator to help us out with that. This kind of flow control is a branching flow control because there are two branches of instructions that will be executed conditionally. One branch is executed if the number is a factor. The other branch is executed if not. So let me write the program. It will prompt the user for two numbers. It will print \"x is a factor of y\" if the second number is a factor, and \"Is not a factor\" if not. mult = int(input(\"What is the multiple? \")) fact = int(input(\"What is the factor to check? \")) if mult % fact == 0: print(\"{} is a factor of {}\".format(fact, mult)) else: print(\"{} is NOT a factor of {}\".format(fact, mult)) When we run this program from our bash terminal we get something like this: ~$ python factor.py What is the multiple? 12 What is the factor to check? 4 4 is a factor of 12 ~$ Then we can run it again with something we know should be false: ~$ python factor.py What is the multiple? 12 What is the factor to check? 5 5 is NOT a factor of 12 ~$ What's going on here? On our first two lines, we're prompting the user for input and storing those values to two separate variables. Then we use an \"if\" statement to check to see if the remainder of multi / fact is zero. If this is true, then we execute the code on the next line (line 5). Otherwise, we skip down to the \"else\" statement and execute that instruction. We can see, then, the first time we run the code, 12 / 4 has a remainder of 0, so the condition in the \"if\" statement is True. So you see the appropriate instruction is executed. On the other hand, in the second run of our code, 12 / 5 does have a remainder that is not equal to zero (it is equal to 2 specifically). As a result, the statement evaluates to False and we do not execute the code within the \"if\" block. Instead, we go down to the \"else\" and execute that code instead. Notice the instructions on the lines after if and else are indented one level. This signifies to the Python interpreter that they are part of the if or else block. A code block is a collection of code that only gets executed if some condition is met. In this case, the if block only gets executed when the condition we defined for if is True. Otherwise, the else block is executed. Regardless of the input (as long as it is valid input), either the if block will execute or the else block, but never both. We can also set up conditions with only an if block. Let's say we want a program to print \"Happy Birthday\" on a user's Birthday and not print anything else if it is not. That code would look like this: BIRTHDAY = \"05/02\" today = input(\"What is the date today (mm/dd)? \") if BIRTHDAY == today: print(\"Happy Birthday!\") Once again, I'll show you what it looks like when we run this code: ~$ python birthday.py What is the date today (mm/dd)? 05/02 Happy Birthday! ~$ python birthday.py What is the date today (mm/dd)? 03/12 ~$ I set BIRTHDAY as a constant value. Then the program prompts the user for the date with a hint at the format. I check to see if what the user entered matches or is equal to the value stored in BIRTHDAY . If it is, then the program prints \"Happy Birthday!\" and if it is not, then it does nothing. Once again, I show you what that looks like when we run the program in both cases. Sometimes it is useful to have code that only runs when a condition is satisfied. We can also use negative conditions, so if we wanted to congratulate the user that it's not their birthday, we'd need to change our condition to be if BIRTHDAY != today: . Finally, we can set a series of conditions. Perhaps we want to help someone who is trying to decide whether to wear a jacket or not based on the temperature: temp = int(input(\"What is the temperature? \")) if temp > 70: print(\"Wear Shorts\") elif temp > 50: print(\"Pants and a wind breaker\") elif temp > 40: print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") In the above example, we have 4 conditions: warmer than 70 degrees, warmer than 50 degrees, warmer than 40 degrees, or colder than 40 degrees. This leads us to a cool design decision. In the if/elif/else or if/else structure only one of the blocks will be executed. Specifically, the first time the condition is True, the corresponding block is executed and the rest are skipped. So, in the above example, if the user inputs 75, only the first block will execute. It is true that 75 is also greater than 50 and 40, but Python stops at the first True condition and once we have a True condition none of the other blocks are executed. As a design decision, this allows us to check for warmer than 70, 50, and 40 without having to say elif temp > 50 and temp <= 70: for the second condition. We know that if the Python interpreter is even evaluating that condition, then the first condition failed and the temperature is 70 or less. The else acts as a fall through condition. If none of the specific cases is True, then the else block is executed. As you design your conditionals, you will find clever ways to short circuit the way you test truthiness that can make your code more efficient. Related to this, we can also test multiple conditions at the same time. For example, let's take our code from the last example and add a prompt for the rain. temp = int(input(\"What is the temperature? \")) rain = input(\"Are you expecting it to precipitate?(y/n) \") if temp > 70 and rain == \"n\": print(\"Wear Shorts\") elif temp > 50 and rain == \"n\": print(\"Pants and a wind breaker\") elif temp > 40 or rain == \"y\": print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") You can see that we are testing two conditions each time. In the first two cases we use the key word and which means that the whole test or condition is True if--and only if--both conditions are true. In the third case, we use the key word or which means that at least one of the conditions must evaluate to True. So if it is warmer than 40 or it's raining or both, the code block is executed. There are other logical operators that can be used but mainly if we are testing truthiness for bits. I'll have a section at the end of this chapter discussing bitwise operations, but you can skip it if you're not interested. Finally, we can \"nest\" our conditions within conditions. Sometimes this is more efficient than having a bunch of conditions with multiple logic tests. For example, I might like to refactor my code again so there are fewer logic tests: temp = int(input(\"What is the temperature? \")) rain = input(\"Are you expecting it to precipitate?(y/n) \") if rain == \"y\": print(\"Maybe a raincoat\") else: if temp > 70: print(\"Wear Shorts\") elif temp > 50: print(\"Pants and a wind breaker\") elif temp > 40: print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") You hopefully notice that there are several different ways to do things. Generally the way that is the most clear is the best in Python. In this case, we know that regardless, if it is raining, the program should tell the user to wear a raincoat, so there's no point in wasting the processing power checking the rest of the conditions. We simply short circuit the if/else structure if it happens to be raining. Now that you have a sense of these structures, I'm going to talk a bit about Booleans. Conditionals: Try/Except This section is going to be a bit more advanced, and we will not be looking at errors and exceptions to any great length in this book. However, a common kind of forking flow control is the kind we use to catch errors. In the previous chapters, we talked about syntax errors and other sorts of errors. One type is the ValueError. This is an error that occurs when we try to do an operation that is not possible on a particular data type. For example, we cannot add a string to an integer and we cannot directly convert an alphabetic string to an integer. The following would throw an error: >>> int(\"Fish\") Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: invalid literal for int() with base 10: 'Fish' >>> That's annoying, of course. Now, we've prompted users to input numbers into our programs before. So far, we've trusted them to input a number. However, if they chose to input a string instead, our program would throw an error message and not work. Generally, it is much better for us to manage catch those errors rather than allow them to fail to the user or silently. Let's just look at a quick temperature conversion program that converts fahrenheit to celsius. temp = int(input(\"What is the temperature in Fahrenheit? \")) cels = (temp - 32) * (5/9) print(\"The temperature is {} degrees celsius\".format(cels)) This works perfectly if the user inputs some number value when they are prompted, but if they type a string like \"twenty five\", the conversion to an integer that happens on the first line would throw a ValueError because \"twenty five\" is sequence of letters that cannot be converted into an integer by the computer. To deal with this error, I will put in a forking flow control that \"Tries\" to execute a particular operation, and if it fails, it catches the error message and does what I want it to do instead of just having the program break. Let me show you the code and I'll explain further: try: temp = int(input(\"What is the temperature in Fahrenheit? \")) cels = (temp - 32) * (5/9) print(\"it is {} degrees celsius\".format(cels)) except ValueError as err: print(\"I'm sorry, you need to enter a number:\", err) Now, the flow fork begins with the key word try which tells the Python Interpreter to be prepared for a possible error. Then the try block is executed and if there is an error, the Interpreter looks to the except block. In this case, I have told the interpreter to prepare for a particular type of error, and I have given it a block of code to execute instead of just throwing the error message back to the user. Instead of the messy error message that reveals my code, I have a nice neat error message that is printed to the screen. I could also set this up to log the error to a log file so the user doesn't see any details. Once again, we're not going to be using this in this book, but knowing that there is the type of forking flow control that is designed to handle errors is good. Booleans Booleans are a primitive data type that is either True or False. Whenever we use a conditional, the condition returns a True or a False value. So 9 == 10 in Python asks the interpreter to assess whether nine equals ten. Obviously, this is not true so Python will return False. This is a particular type of data and False is not the same as the string \"False\". This data type is important to understand because it is the fundamental operation of the computer. At the level of the hardware, all of the operations of the computer are computed through boolean logic comparing binary bits. We can manipulate bits directly with Python using bitwise operators, and frequently the operation is much faster, but for our purposes here, we're not going to worry too much about that. Instead, we're going to focus on True and False and expressions that evaluate to True and False. True and False are the primitive data type for booleans, but other things can be evaluated by True and False through Truthiness tests. Here is a table of some examples: Expression Boolean True True False False 1 == 1 True 1 == 2 False 1 != 2 True \"\" False (empty strings are false) \"a\" True 0 False 1 True 8 > 6 True And so on. As you design your programs and work with control, you will write code that evaluates conditions. These conditions will evaluate to True or False, and the code will execute the block that corresponds to the passing test. The key take away besides the syntax is to recognize that you'll want to spend some time thinking about what conditions you want to evaluate and then what should happen when those conditions evaluate to a certain boolean value.","title":"Branching Flow Control"},{"location":"ch5/#conditionals","text":"","title":"Conditionals"},{"location":"ch5/#introduction-to-flow-control","text":"Thus far, we've basically told the computer what to do and it has done it basically as we requested. However, in programming, one of our goals is to turn over more of the work to computers. We saw this a little bit with our speed conversion program. Instead of writing two different programs, one for MPH to KPH and another for KPH to MPH, we wrote one program with a decision in it that allowed the computer to decide which calculation to perform based on the user's input. This ability of a computer to make decisions based on input is a central part of flow control . Flow control refers to the controls that we build into our program that tell the computer when and how many times to execute a particular group of instructions. There are two separate parts of flow control: conditionals, which tell the computer to execute instructions based on a set of conditions, and iterators or loops, which tell the computer to execute instructions while a particular condition is true or for a particular number of times. Generally, a flow control structure involves a few parts. There will be the reserved word in Python like if\\else\\while\\for\\try and then there will be a condition that is evaluated. Finally, there will be one or more blocks of code that could potentially be executed depending on the evaluation of the condition. Here is an example of the general format: {reserved word} {condition}: {code block} {other reserved word} A small example in Python: if x == 0: print(\"X is zero\") The reserved word defines what kind of flow control is being executed. The flow of the program will either branch with one block of instructions being conditionally executed or not, or it will loop with a sequence of instructions being repeted a number of times until some condition is met. In this chapter, we'll look at the first. In the next chapter we'll look at the second.","title":"Introduction to Flow Control"},{"location":"ch5/#conditionals-ifelse","text":"To set the stage, let's say my user wants to figure out if one number is a factor of another number. A number is a factor if the second number can be divided evenly by the first. So, 4 is a factor of 12 because 12 can be evenly divided by 4. Programming languages give us the % (mod) operator to help us out with that. This kind of flow control is a branching flow control because there are two branches of instructions that will be executed conditionally. One branch is executed if the number is a factor. The other branch is executed if not. So let me write the program. It will prompt the user for two numbers. It will print \"x is a factor of y\" if the second number is a factor, and \"Is not a factor\" if not. mult = int(input(\"What is the multiple? \")) fact = int(input(\"What is the factor to check? \")) if mult % fact == 0: print(\"{} is a factor of {}\".format(fact, mult)) else: print(\"{} is NOT a factor of {}\".format(fact, mult)) When we run this program from our bash terminal we get something like this: ~$ python factor.py What is the multiple? 12 What is the factor to check? 4 4 is a factor of 12 ~$ Then we can run it again with something we know should be false: ~$ python factor.py What is the multiple? 12 What is the factor to check? 5 5 is NOT a factor of 12 ~$ What's going on here? On our first two lines, we're prompting the user for input and storing those values to two separate variables. Then we use an \"if\" statement to check to see if the remainder of multi / fact is zero. If this is true, then we execute the code on the next line (line 5). Otherwise, we skip down to the \"else\" statement and execute that instruction. We can see, then, the first time we run the code, 12 / 4 has a remainder of 0, so the condition in the \"if\" statement is True. So you see the appropriate instruction is executed. On the other hand, in the second run of our code, 12 / 5 does have a remainder that is not equal to zero (it is equal to 2 specifically). As a result, the statement evaluates to False and we do not execute the code within the \"if\" block. Instead, we go down to the \"else\" and execute that code instead. Notice the instructions on the lines after if and else are indented one level. This signifies to the Python interpreter that they are part of the if or else block. A code block is a collection of code that only gets executed if some condition is met. In this case, the if block only gets executed when the condition we defined for if is True. Otherwise, the else block is executed. Regardless of the input (as long as it is valid input), either the if block will execute or the else block, but never both. We can also set up conditions with only an if block. Let's say we want a program to print \"Happy Birthday\" on a user's Birthday and not print anything else if it is not. That code would look like this: BIRTHDAY = \"05/02\" today = input(\"What is the date today (mm/dd)? \") if BIRTHDAY == today: print(\"Happy Birthday!\") Once again, I'll show you what it looks like when we run this code: ~$ python birthday.py What is the date today (mm/dd)? 05/02 Happy Birthday! ~$ python birthday.py What is the date today (mm/dd)? 03/12 ~$ I set BIRTHDAY as a constant value. Then the program prompts the user for the date with a hint at the format. I check to see if what the user entered matches or is equal to the value stored in BIRTHDAY . If it is, then the program prints \"Happy Birthday!\" and if it is not, then it does nothing. Once again, I show you what that looks like when we run the program in both cases. Sometimes it is useful to have code that only runs when a condition is satisfied. We can also use negative conditions, so if we wanted to congratulate the user that it's not their birthday, we'd need to change our condition to be if BIRTHDAY != today: . Finally, we can set a series of conditions. Perhaps we want to help someone who is trying to decide whether to wear a jacket or not based on the temperature: temp = int(input(\"What is the temperature? \")) if temp > 70: print(\"Wear Shorts\") elif temp > 50: print(\"Pants and a wind breaker\") elif temp > 40: print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") In the above example, we have 4 conditions: warmer than 70 degrees, warmer than 50 degrees, warmer than 40 degrees, or colder than 40 degrees. This leads us to a cool design decision. In the if/elif/else or if/else structure only one of the blocks will be executed. Specifically, the first time the condition is True, the corresponding block is executed and the rest are skipped. So, in the above example, if the user inputs 75, only the first block will execute. It is true that 75 is also greater than 50 and 40, but Python stops at the first True condition and once we have a True condition none of the other blocks are executed. As a design decision, this allows us to check for warmer than 70, 50, and 40 without having to say elif temp > 50 and temp <= 70: for the second condition. We know that if the Python interpreter is even evaluating that condition, then the first condition failed and the temperature is 70 or less. The else acts as a fall through condition. If none of the specific cases is True, then the else block is executed. As you design your conditionals, you will find clever ways to short circuit the way you test truthiness that can make your code more efficient. Related to this, we can also test multiple conditions at the same time. For example, let's take our code from the last example and add a prompt for the rain. temp = int(input(\"What is the temperature? \")) rain = input(\"Are you expecting it to precipitate?(y/n) \") if temp > 70 and rain == \"n\": print(\"Wear Shorts\") elif temp > 50 and rain == \"n\": print(\"Pants and a wind breaker\") elif temp > 40 or rain == \"y\": print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") You can see that we are testing two conditions each time. In the first two cases we use the key word and which means that the whole test or condition is True if--and only if--both conditions are true. In the third case, we use the key word or which means that at least one of the conditions must evaluate to True. So if it is warmer than 40 or it's raining or both, the code block is executed. There are other logical operators that can be used but mainly if we are testing truthiness for bits. I'll have a section at the end of this chapter discussing bitwise operations, but you can skip it if you're not interested. Finally, we can \"nest\" our conditions within conditions. Sometimes this is more efficient than having a bunch of conditions with multiple logic tests. For example, I might like to refactor my code again so there are fewer logic tests: temp = int(input(\"What is the temperature? \")) rain = input(\"Are you expecting it to precipitate?(y/n) \") if rain == \"y\": print(\"Maybe a raincoat\") else: if temp > 70: print(\"Wear Shorts\") elif temp > 50: print(\"Pants and a wind breaker\") elif temp > 40: print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") You hopefully notice that there are several different ways to do things. Generally the way that is the most clear is the best in Python. In this case, we know that regardless, if it is raining, the program should tell the user to wear a raincoat, so there's no point in wasting the processing power checking the rest of the conditions. We simply short circuit the if/else structure if it happens to be raining. Now that you have a sense of these structures, I'm going to talk a bit about Booleans.","title":"Conditionals: If/Else"},{"location":"ch5/#conditionals-tryexcept","text":"This section is going to be a bit more advanced, and we will not be looking at errors and exceptions to any great length in this book. However, a common kind of forking flow control is the kind we use to catch errors. In the previous chapters, we talked about syntax errors and other sorts of errors. One type is the ValueError. This is an error that occurs when we try to do an operation that is not possible on a particular data type. For example, we cannot add a string to an integer and we cannot directly convert an alphabetic string to an integer. The following would throw an error: >>> int(\"Fish\") Traceback (most recent call last): File \"<stdin>\", line 1, in <module> ValueError: invalid literal for int() with base 10: 'Fish' >>> That's annoying, of course. Now, we've prompted users to input numbers into our programs before. So far, we've trusted them to input a number. However, if they chose to input a string instead, our program would throw an error message and not work. Generally, it is much better for us to manage catch those errors rather than allow them to fail to the user or silently. Let's just look at a quick temperature conversion program that converts fahrenheit to celsius. temp = int(input(\"What is the temperature in Fahrenheit? \")) cels = (temp - 32) * (5/9) print(\"The temperature is {} degrees celsius\".format(cels)) This works perfectly if the user inputs some number value when they are prompted, but if they type a string like \"twenty five\", the conversion to an integer that happens on the first line would throw a ValueError because \"twenty five\" is sequence of letters that cannot be converted into an integer by the computer. To deal with this error, I will put in a forking flow control that \"Tries\" to execute a particular operation, and if it fails, it catches the error message and does what I want it to do instead of just having the program break. Let me show you the code and I'll explain further: try: temp = int(input(\"What is the temperature in Fahrenheit? \")) cels = (temp - 32) * (5/9) print(\"it is {} degrees celsius\".format(cels)) except ValueError as err: print(\"I'm sorry, you need to enter a number:\", err) Now, the flow fork begins with the key word try which tells the Python Interpreter to be prepared for a possible error. Then the try block is executed and if there is an error, the Interpreter looks to the except block. In this case, I have told the interpreter to prepare for a particular type of error, and I have given it a block of code to execute instead of just throwing the error message back to the user. Instead of the messy error message that reveals my code, I have a nice neat error message that is printed to the screen. I could also set this up to log the error to a log file so the user doesn't see any details. Once again, we're not going to be using this in this book, but knowing that there is the type of forking flow control that is designed to handle errors is good.","title":"Conditionals: Try/Except"},{"location":"ch5/#booleans","text":"Booleans are a primitive data type that is either True or False. Whenever we use a conditional, the condition returns a True or a False value. So 9 == 10 in Python asks the interpreter to assess whether nine equals ten. Obviously, this is not true so Python will return False. This is a particular type of data and False is not the same as the string \"False\". This data type is important to understand because it is the fundamental operation of the computer. At the level of the hardware, all of the operations of the computer are computed through boolean logic comparing binary bits. We can manipulate bits directly with Python using bitwise operators, and frequently the operation is much faster, but for our purposes here, we're not going to worry too much about that. Instead, we're going to focus on True and False and expressions that evaluate to True and False. True and False are the primitive data type for booleans, but other things can be evaluated by True and False through Truthiness tests. Here is a table of some examples: Expression Boolean True True False False 1 == 1 True 1 == 2 False 1 != 2 True \"\" False (empty strings are false) \"a\" True 0 False 1 True 8 > 6 True And so on. As you design your programs and work with control, you will write code that evaluates conditions. These conditions will evaluate to True or False, and the code will execute the block that corresponds to the passing test. The key take away besides the syntax is to recognize that you'll want to spend some time thinking about what conditions you want to evaluate and then what should happen when those conditions evaluate to a certain boolean value.","title":"Booleans"},{"location":"ch6/","text":"Flow Control: Loops In the last chapter we looked at how we can create forks in the flow of our code that allow some instructions to be executed only if certain conditions are met. This means that we turned some of the decision making over to the computer and to our program. More complex programs can make more complex decisions, but those decisions are based on some condition or some data conforming to some condition. For example, a sentiment analysis program that detects the sentiment of a text (is it happy, angry, neutral, etc), looks at the input text and compares features of it to a model of what various texts look like. It predicts the sentiment of the text based on how much it fits the pattern. More complicated, certainly, than if user_input == \"Yes\" , but the similar decision making principle. In this section, we are looking at how to have our program perform an action many times. Loops are incredibly useful in making our program more efficient. For example, if I had a list of student profiles and wanted to increment the age by one for each student, I'd need to either write an instruction for each profile, or I'd need to write the instruction once and set it to loop through all of the profiles automatically. There are two types of loops: indeterminate and determinate. Indeterminate loops are loops that repeat for an indeterminate number of iterations. Perhaps we have a guessing game that we want to continue playing until the user gets the answer right or exits the game. We don't know how many guesses the user will make, so we have the loop continue an indeterminate number of times until one of the end game conditions is met. Determinate loops iterate a known number of times. The example above with student profiles would be a determinate loop because there is a known set of iterations (one for each student). Indeterminate loops are controlled by the while keyword. Determinate loops are controlled by the for keyword. Loops: While loop \"While\" loops are loops that execute a block of code ntil a particular condition is met. A good problem that might use a while loop is finding if a number is prime using one of the brute force methods. A prime number is a number that is only divisible by 1 and itself. So 7 is prime. One way to test if a number is prime is to divide that number by all the whole numbers beneath it, and if one of those divisions does not yield a remainder, the number is not prime. Here's our code to do this: num = int(input(\"Enter a whole number: \")) factor = num - 1 while factor > 1: if num % factor == 0: print(\"Not prime\") break factor -= 1 What's happening here is I'm getting a number from the user. Then I'm setting the first factor to test. Then we enter a while loop that will continue going until factor is 1. Then we try and see if factor is a factor of number. If so, we print \"Not prime\" and exit the while loop with the break keyword. Otherwise, if the value stored in factor is not a factor of num we decrease it by 1 and return to the condition. I'm going to write out the steps that occur when we run this script with the number six and the number 5. The lines in quotation marks are printed to the screen. The other lines are processes that the Python Interpreter performs. Python Interpreter (PI): \"Enter a whole number\" Me: \"6\" PI: store 6 in the variable num. PI: store 6 - 1 in the variable factor PI: Is factor greater than 1? 5 > 1 is True PI: Enter while block. PI: Is the remainder of 6 / 5 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 4 > 1 is True PI: Enter while block. PI: Is the remainder of 6 / 4 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 3 > 1 is True PI: Enter while block. PI: Is the remainder of 6 / 3 equal to 0? True PI: Enter if block PI: \"Not Prime\" PI: Exit while loop at \"break\", end of program. You'll notice that the while condition was tested exactly 3 times when factor what 5, 4, and 3. Once factor became 3, the if condition passed and the while loop was exited with break . Let's try again, when the while condition fails and the loop is exited that way. Python Interpreter (PI): \"Enter a whole number\" Me: \"5\" PI: store 5 in the variable num. PI: store 5 - 1 in the variable factor PI: Is factor greater than 1? 4 > 1 is True PI: Enter while block. PI: Is the remainder of 5 / 4 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 3 > 1 is True PI: Enter while block. PI: Is the remainder of 5 / 3 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 2 > 1 is True PI: Enter while block. PI: Is the remainder of 5 / 2 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 1 > 1 is False PI: Skip while loop. End of file, end of program. The while condition was tested 4 times and failed on the last time because the factor was decreased to 1. The if condition was also tested 4 times and failed each time so the print() and the break were never executed. This, of course, is not the best way to find primacy of numbers, but it does illustrate that the while loop execution count is indeterminate. The action of the user or some external condition that the programmer does not have control of defines how many times the while loop runs. In fact, this leads us to an important consideration: what happens if the while condition never evaluates to False ? The loop will continue forever until the computer runs out of resources and freezes or the power is cut. Have you ever landed on a website that made your web browser freeze? Sometimes this is because there is a bug like this in the web page. Modern web browsers have become more sensitive to scripts that cause the page to slow down, but it used to happen sometimes. When you write a loop that has a condition that may never be satisfied, it is called an infinite loop and that is something to avoid. As a result, it is good to determine what has to occur to get the loop to end, and frequently it is a good idea to add a fail safe. So maybe the loop should run indefinitely, but less than one million times. I'd add a counter that will stop the loop automatically after one million revolutions if it hasn't stopped by then. x = 27 count = 0 while x == 27 and count < 1000000: print(\"I could be an invinite loop\") count += 1 In the loop above, since I'm not doing anything to change the value of x and it is set to 27 by default, the loop would never end. Fortunately, I've also added a counter variable that increases each time the loop runs. Eventually count will get to one million, at which point the loop will exit. This is a silly example, because the loop doesn't do anything, but sometimes you might create a loop like this: while True: print(\"I am infinite\") We can add a counter to make sure that the while loop ends eventually like this: i = 0 while True and i < 1000000: print(\"I'm less than infinite\") i += 1 The failsafe is not required, and sometimes it doesn't make sense, but as you solve problems with code, you should be trying to think of all the potential cases that could occur. Avoiding infinite loops is part of this concern. Loops: For Loop The other type of loop is a definite loop. A definite loop is one that repeats a known number of times. For example, perhaps you have a list of values that you want to print. This list has a specific length, and so the loop will only continue for the length of the list. We will talk about definite loops more when we start looking at more complex data types, but for now you just need to know that a definite loop has a predetermined end. These loops use the for keyword in Python. I don't feel like the syntax is particularly clear; however, so I want to show you how these loops work in another language first that is a bit more obvious. This example is Java: for (int i = 0; i < 10; i++) { println(i); } The condition says create a variable called i and set it equal to zero, repeate the loop until i is ten and then stop, increment or increase i by one each time. The same loop in Python would look like this: for i in range(10): print(i) Both the Java and the Python for loops will execute 10 times because i is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and then when i is 10, the the for block of code is skipped. For Java, we create an integer variable that holds a whole number that is increased with each iteration. Python creates a range object, which is a list of numbers from 0 to (but not including) the number that we pass to range() inside the parentheses. Then the for loop walks through each number in the list, assigns that number to i, and performs the instructions inside the for block. In this case, it will print the value stored in i to the screen. I'll give you a more extended example that tells Python to print the song 99 Bottles of Beer . for i in range(99, 0, -1): print(\"{} bottles of beer on the wall\".format(i)) print(\"{} bottles of beer\".format(i)) print(\"take one down, pass it around\") print(\"{} bottles of beer on the wall\\n\\n\".format(i - 1)) print(\"No more bottles of beer on the wall\") print(\"No more bottles of beer\") print(\"There's nothing else to fall\") print(\"Because there's no more bottles of beer on the wall.\") Forgive the extra print statements. We could probably be a bit more efficient in our code, but let's look at the for condition. We have a range that starts with 99, ends with but does not include 0, and decreases by 1 each time. So the list would look like [99, 98, 97, ..., 2, 1]. For each value in that list, the for block is executed. Once the iterations of the for loop reach the end of the list, the loop is stopped, and we move on to the final sequence of 4 print statements. As we move on to more complex data structures next chapter, you'll see that these flow control structures become extremely useful.","title":"Looping Flow Control"},{"location":"ch6/#flow-control-loops","text":"In the last chapter we looked at how we can create forks in the flow of our code that allow some instructions to be executed only if certain conditions are met. This means that we turned some of the decision making over to the computer and to our program. More complex programs can make more complex decisions, but those decisions are based on some condition or some data conforming to some condition. For example, a sentiment analysis program that detects the sentiment of a text (is it happy, angry, neutral, etc), looks at the input text and compares features of it to a model of what various texts look like. It predicts the sentiment of the text based on how much it fits the pattern. More complicated, certainly, than if user_input == \"Yes\" , but the similar decision making principle. In this section, we are looking at how to have our program perform an action many times. Loops are incredibly useful in making our program more efficient. For example, if I had a list of student profiles and wanted to increment the age by one for each student, I'd need to either write an instruction for each profile, or I'd need to write the instruction once and set it to loop through all of the profiles automatically. There are two types of loops: indeterminate and determinate. Indeterminate loops are loops that repeat for an indeterminate number of iterations. Perhaps we have a guessing game that we want to continue playing until the user gets the answer right or exits the game. We don't know how many guesses the user will make, so we have the loop continue an indeterminate number of times until one of the end game conditions is met. Determinate loops iterate a known number of times. The example above with student profiles would be a determinate loop because there is a known set of iterations (one for each student). Indeterminate loops are controlled by the while keyword. Determinate loops are controlled by the for keyword.","title":"Flow Control: Loops"},{"location":"ch6/#loops-while-loop","text":"\"While\" loops are loops that execute a block of code ntil a particular condition is met. A good problem that might use a while loop is finding if a number is prime using one of the brute force methods. A prime number is a number that is only divisible by 1 and itself. So 7 is prime. One way to test if a number is prime is to divide that number by all the whole numbers beneath it, and if one of those divisions does not yield a remainder, the number is not prime. Here's our code to do this: num = int(input(\"Enter a whole number: \")) factor = num - 1 while factor > 1: if num % factor == 0: print(\"Not prime\") break factor -= 1 What's happening here is I'm getting a number from the user. Then I'm setting the first factor to test. Then we enter a while loop that will continue going until factor is 1. Then we try and see if factor is a factor of number. If so, we print \"Not prime\" and exit the while loop with the break keyword. Otherwise, if the value stored in factor is not a factor of num we decrease it by 1 and return to the condition. I'm going to write out the steps that occur when we run this script with the number six and the number 5. The lines in quotation marks are printed to the screen. The other lines are processes that the Python Interpreter performs. Python Interpreter (PI): \"Enter a whole number\" Me: \"6\" PI: store 6 in the variable num. PI: store 6 - 1 in the variable factor PI: Is factor greater than 1? 5 > 1 is True PI: Enter while block. PI: Is the remainder of 6 / 5 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 4 > 1 is True PI: Enter while block. PI: Is the remainder of 6 / 4 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 3 > 1 is True PI: Enter while block. PI: Is the remainder of 6 / 3 equal to 0? True PI: Enter if block PI: \"Not Prime\" PI: Exit while loop at \"break\", end of program. You'll notice that the while condition was tested exactly 3 times when factor what 5, 4, and 3. Once factor became 3, the if condition passed and the while loop was exited with break . Let's try again, when the while condition fails and the loop is exited that way. Python Interpreter (PI): \"Enter a whole number\" Me: \"5\" PI: store 5 in the variable num. PI: store 5 - 1 in the variable factor PI: Is factor greater than 1? 4 > 1 is True PI: Enter while block. PI: Is the remainder of 5 / 4 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 3 > 1 is True PI: Enter while block. PI: Is the remainder of 5 / 3 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 2 > 1 is True PI: Enter while block. PI: Is the remainder of 5 / 2 equal to 0? False PI: Skip if block PI: Decrement factor by 1 PI: Return to top of while loop. PI: Is factor greater than 1? 1 > 1 is False PI: Skip while loop. End of file, end of program. The while condition was tested 4 times and failed on the last time because the factor was decreased to 1. The if condition was also tested 4 times and failed each time so the print() and the break were never executed. This, of course, is not the best way to find primacy of numbers, but it does illustrate that the while loop execution count is indeterminate. The action of the user or some external condition that the programmer does not have control of defines how many times the while loop runs. In fact, this leads us to an important consideration: what happens if the while condition never evaluates to False ? The loop will continue forever until the computer runs out of resources and freezes or the power is cut. Have you ever landed on a website that made your web browser freeze? Sometimes this is because there is a bug like this in the web page. Modern web browsers have become more sensitive to scripts that cause the page to slow down, but it used to happen sometimes. When you write a loop that has a condition that may never be satisfied, it is called an infinite loop and that is something to avoid. As a result, it is good to determine what has to occur to get the loop to end, and frequently it is a good idea to add a fail safe. So maybe the loop should run indefinitely, but less than one million times. I'd add a counter that will stop the loop automatically after one million revolutions if it hasn't stopped by then. x = 27 count = 0 while x == 27 and count < 1000000: print(\"I could be an invinite loop\") count += 1 In the loop above, since I'm not doing anything to change the value of x and it is set to 27 by default, the loop would never end. Fortunately, I've also added a counter variable that increases each time the loop runs. Eventually count will get to one million, at which point the loop will exit. This is a silly example, because the loop doesn't do anything, but sometimes you might create a loop like this: while True: print(\"I am infinite\") We can add a counter to make sure that the while loop ends eventually like this: i = 0 while True and i < 1000000: print(\"I'm less than infinite\") i += 1 The failsafe is not required, and sometimes it doesn't make sense, but as you solve problems with code, you should be trying to think of all the potential cases that could occur. Avoiding infinite loops is part of this concern.","title":"Loops: While loop"},{"location":"ch6/#loops-for-loop","text":"The other type of loop is a definite loop. A definite loop is one that repeats a known number of times. For example, perhaps you have a list of values that you want to print. This list has a specific length, and so the loop will only continue for the length of the list. We will talk about definite loops more when we start looking at more complex data types, but for now you just need to know that a definite loop has a predetermined end. These loops use the for keyword in Python. I don't feel like the syntax is particularly clear; however, so I want to show you how these loops work in another language first that is a bit more obvious. This example is Java: for (int i = 0; i < 10; i++) { println(i); } The condition says create a variable called i and set it equal to zero, repeate the loop until i is ten and then stop, increment or increase i by one each time. The same loop in Python would look like this: for i in range(10): print(i) Both the Java and the Python for loops will execute 10 times because i is 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and then when i is 10, the the for block of code is skipped. For Java, we create an integer variable that holds a whole number that is increased with each iteration. Python creates a range object, which is a list of numbers from 0 to (but not including) the number that we pass to range() inside the parentheses. Then the for loop walks through each number in the list, assigns that number to i, and performs the instructions inside the for block. In this case, it will print the value stored in i to the screen. I'll give you a more extended example that tells Python to print the song 99 Bottles of Beer . for i in range(99, 0, -1): print(\"{} bottles of beer on the wall\".format(i)) print(\"{} bottles of beer\".format(i)) print(\"take one down, pass it around\") print(\"{} bottles of beer on the wall\\n\\n\".format(i - 1)) print(\"No more bottles of beer on the wall\") print(\"No more bottles of beer\") print(\"There's nothing else to fall\") print(\"Because there's no more bottles of beer on the wall.\") Forgive the extra print statements. We could probably be a bit more efficient in our code, but let's look at the for condition. We have a range that starts with 99, ends with but does not include 0, and decreases by 1 each time. So the list would look like [99, 98, 97, ..., 2, 1]. For each value in that list, the for block is executed. Once the iterations of the for loop reach the end of the list, the loop is stopped, and we move on to the final sequence of 4 print statements. As we move on to more complex data structures next chapter, you'll see that these flow control structures become extremely useful.","title":"Loops: For Loop"},{"location":"ch7/","text":"Data Types Any given program has two major components, whether that program is a web application, a simple website, a complex machine learning program, etc. The program will have data, and it will have procedures. Data is the \"stuff\" of the program. It might be text, numbers, file locations, and so on. These are the \"values\" that are stored in memory that you have access to throughout the program (depending on their scope). Every time you declare a variable, you're creating space in memory (RAM) to store some sort of data. When you run out of storage space (RAM), your program will freeze. So, if you're running a machine learning program on a small Digital Ocean droplet that gives you 500MB of RAM, and your program calls into memory a model that is 700MB, the program will freeze because there isn't enough space in memory. Procedures on the other hand are the actions that are done by the program. If you want to compare programming to language, you might think of data as the nouns and actions as the verbs. Procedures can either be written out in a procedural style, bundled into functions, encapsulated into objects (next week), or a combination of the three. So far, we've looked at some data types, but have focused more on the procedures. Now we can pause and look at some of the data types that Python provides you with. Data types are ways to hold information based on what that information is. These are either Primitive or Abstract. Primitive Data Types You've encountered all of the primitive data types in Python. Primitive data types are whole pieces of data rather than collections of smaller pieces. So a number might be a single piece of data, and therefore it is a primitive data type. Integers--Whole numbers with no decimal points. Floats -- Non-whole numbers or numbers with decimal points (17.5, 17.0, etc.) Boolean -- This data type represents True or False and is what is returned when conditions from conditionals are evaluated Strings (sort of) -- Strings are weird in Python. They are kind of primitive in the sense that we can treat them as whole units, but in reality they are lists of characters. Abstract Data Types: Abstract Data types are generally larger storage structures that contain collections of smaller data types. These include lists , tuples , sets , and dictionaries . The reason we have abstract data types is because sometimes we have more than one datum that should be aggregated together in a logical way. For example, if you are looking at, say, a whole bunch of temperature readings for the month of March, you could save each one in it's own variable: that would look like this: m1 = 56 m2 = 57 m3 = 62 ... m30 = 68 m31 = 65 But that looks really inefficient and accessing all of those temperatures requires you to explicitly reference each individual variable. Wouldn't it be nice if we could put all of those temperatures in a list to hold all of the March temperatures? What if we could then get the temperature for a particular day by referencing the day number in the list? Well, we can. The data structure--a list--allows us to do exactly that. march_temps = [56, 57, 62, ... , 68, 65] To get the temperature from March 5th, you'd just need to access march_temps[4] , which will give us the 5th element in the list. Abstract data types allow us to store data in larger structures in meaningful ways. Lists--ordered, heterogenous, sequences of data We've touched on lists briefly with strings. Unlike primitive data types that hold one piece of data (a number or a string or a boolean or an integer), lists hold a series of data. By heterogenous, I mean that each piece of data need not be the same, so you could have a list that contains integers, strings, lists, and so on. Though, I think this is not a great practice. For instance, what if I have a bunch of student names that I want to store. It doesn't make much sense to store them all in individual variables or else I'd have a bunch of variables to manage. Instead, I can use a list that will help me manage these names in one single variable. students = ['Joseph', 'Omar', 'Sue', 'Wendy', 'Natasha'] A list gives me a useful way to organize all those pieces of data. There are a few keys to remember about lists. Lists are ordered by index. This means that each value corresponds to a particular position in the list. The first item in a list is index 0. The last is the n-1 where n is the length of the list. They never get out of order unless you explicitly change them. Lists can contain different types of data at each index. Lists can be sliced (you can grab a chunk of the list by index number), iterated over, and so on. Lists are mutable. This means their values at each index can be changed. Also, they can be shrunk or expanded as you like. You may have guessed, but all strings are lists of characters. This is not the same in all programming languages, but in Python, all of the list methods (see #6) can be used on strings. Lists have many built-in methods. To read all about them, check out this link . Tuples--ordered, heterogenous, ummutable sequences of data uples are one of the more confusing features for those new to Python. In form, a tuple looks very much like a list. Let's compare: List: names = ['Sylvia', 'Eric', 'Bobby', 'Cassandra'] Tuple: names = ('Sylvia', 'Eric', 'Bobby', 'Cassandra') I can iterate through both in the same way. They are both indexed and the order is constant. So what's the difference? The major difference is that lists can change, and tuples cannot. If I want to change the list names, I can run the append() method on it to add another item, or I can replace the values in any index, or I can pop off a value from my list without creating a new list. Tuples cannot change. They are what we call immutable. Once I've created a tuple, it will always retain the same length and values in the same indices. What's the point? There are a few big reasons we might use a tuple rather than a list. First, a tuple, being immutable, provides substantial optimization for your code. Check this out: user1@DESKTOP-61VJ97U:~$ python3 -m timeit \"['Sylvia', 'Eric', 'Bobby', 'Cassandra']\" 10000000 loops, best of 5: 34.3 nsec per loop user1@DESKTOP-61VJ97U:~$ python3 -m timeit \"['Sylvia', 'Eric', 'Bobby', 'Cassandra']\" 10000000 loops, best of 5: 34.2 nsec per loop user1@DESKTOP-61VJ97U:~$ python3 -m timeit \"('Sylvia', 'Eric', 'Bobby', 'Cassandra')\" 50000000 loops, best of 5: 4.87 nsec per loop user1@DESKTOP-61VJ97U:~$ python3 -m timeit \"('Sylvia', 'Eric', 'Bobby', 'Cassandra')\" 50000000 loops, best of 5: 4.9 nsec per loop Timeit runs the code for n loops 5 times and gives you the best average. So, we created the list 10 million times and found the average per loop time was 34.3 nanoseconds and 34.2 nanoseconds. In the second case, we created the same series as a tuple, but this time we did it 50 million times and found that the average loop time was 4.87 adn 4.9 nanoseconds per loop. For a small list, this isn't a bit difference, but imagine if our sequence had a million items in it. Tuples provide a great performance boost, but they can't be changed, so if you want to alter the values stored in them, you can't. Tuples are most often used to store a sequence of related values, like a sequence of values pulled from a database. Additionally, tuples are hashable, so we can compare two tuples or use them as keys in a dictionary. Sets--unordered collections of unique values Sets are also collections of values like a list or a tuple, but they differ in a few important ways. First, they are unordered. This means that if you add a value to a set, you cannot know what index that value might be found at. Second, every value in a set must be unique. To create a set we use curly brackets: my_set = {'apples', 'bananas', 'grapefruits'} Sets are useful for getting unique values. If I wanted to get unique values in a list, maybe the fastest way would be to add the elements in the list to a set. The resulting set would only keep the unique elements. Sets are also extremely fast for lookups to see if a particular value is present in the collection. Dictionaries--collections of key value pairs A dictionary is another compound data type. It is used to store data in what's called key-value pairs. What this means is that each value has an identifying key or name that you can use to find that value easily. Remember with lists to find an item, you had to know its index, but with a dictionary, you just need to know its key. The basic syntax for a dictionary is {'key': 'value', 'key2': 'value2'...} This means each key and value are paired with each other. Let's take a quick look. classes = {'name': 'everyday coding', 'students': 'Matt', 'day': 'Wednesday', 'location': 'Admn 306'} So, my classes dictionary keys are 'name', 'students', 'day', and 'location'. Each of these has a corresponding value. If I want to get the name of the class, I just need to call classes['name']. This is very useful for larger complex data sets where you want to be able to pluck out a specific value. Here are some keys to dictionaries: Like lists, dictionaries are mutable. They can change length and any value in them can change. Unlike lists, dictionaries are not strictly ordered. There's no guarantee that the first item in the list will always be first. Maybe it will, maybe it won't. So it's totally unreliable to try to grab an item by its index like you did with lists. Dictionaries can hold any types of data as long as they are in key-value pairs. Keys are generally memorable strings. the value could be any type including lists, dictionaries, and tuples. In fact, I'd probably create the dictionary above as more complex. classes = {'everyday' : {'students':['Matt'], 'location': 'Admn 306', 'day': 'Wednesday'}, 'intro': {...}} Please read the following to learn more about dictionaries You'll also notice that dictionaries look like data structures in other languages. In Javascript, they are similar to objects and in PHP they are the same as associative arrays. Be aware, if you're using Python to process JSON objects you need to parse the object into a dictionary before you can work with it.","title":"Primitive and Compound"},{"location":"ch7/#data-types","text":"Any given program has two major components, whether that program is a web application, a simple website, a complex machine learning program, etc. The program will have data, and it will have procedures. Data is the \"stuff\" of the program. It might be text, numbers, file locations, and so on. These are the \"values\" that are stored in memory that you have access to throughout the program (depending on their scope). Every time you declare a variable, you're creating space in memory (RAM) to store some sort of data. When you run out of storage space (RAM), your program will freeze. So, if you're running a machine learning program on a small Digital Ocean droplet that gives you 500MB of RAM, and your program calls into memory a model that is 700MB, the program will freeze because there isn't enough space in memory. Procedures on the other hand are the actions that are done by the program. If you want to compare programming to language, you might think of data as the nouns and actions as the verbs. Procedures can either be written out in a procedural style, bundled into functions, encapsulated into objects (next week), or a combination of the three. So far, we've looked at some data types, but have focused more on the procedures. Now we can pause and look at some of the data types that Python provides you with. Data types are ways to hold information based on what that information is. These are either Primitive or Abstract.","title":"Data Types"},{"location":"ch7/#primitive-data-types","text":"You've encountered all of the primitive data types in Python. Primitive data types are whole pieces of data rather than collections of smaller pieces. So a number might be a single piece of data, and therefore it is a primitive data type. Integers--Whole numbers with no decimal points. Floats -- Non-whole numbers or numbers with decimal points (17.5, 17.0, etc.) Boolean -- This data type represents True or False and is what is returned when conditions from conditionals are evaluated Strings (sort of) -- Strings are weird in Python. They are kind of primitive in the sense that we can treat them as whole units, but in reality they are lists of characters.","title":"Primitive Data Types"},{"location":"ch7/#abstract-data-types","text":"Abstract Data types are generally larger storage structures that contain collections of smaller data types. These include lists , tuples , sets , and dictionaries . The reason we have abstract data types is because sometimes we have more than one datum that should be aggregated together in a logical way. For example, if you are looking at, say, a whole bunch of temperature readings for the month of March, you could save each one in it's own variable: that would look like this: m1 = 56 m2 = 57 m3 = 62 ... m30 = 68 m31 = 65 But that looks really inefficient and accessing all of those temperatures requires you to explicitly reference each individual variable. Wouldn't it be nice if we could put all of those temperatures in a list to hold all of the March temperatures? What if we could then get the temperature for a particular day by referencing the day number in the list? Well, we can. The data structure--a list--allows us to do exactly that. march_temps = [56, 57, 62, ... , 68, 65] To get the temperature from March 5th, you'd just need to access march_temps[4] , which will give us the 5th element in the list. Abstract data types allow us to store data in larger structures in meaningful ways.","title":"Abstract Data Types:"},{"location":"ch7/#lists-ordered-heterogenous-sequences-of-data","text":"We've touched on lists briefly with strings. Unlike primitive data types that hold one piece of data (a number or a string or a boolean or an integer), lists hold a series of data. By heterogenous, I mean that each piece of data need not be the same, so you could have a list that contains integers, strings, lists, and so on. Though, I think this is not a great practice. For instance, what if I have a bunch of student names that I want to store. It doesn't make much sense to store them all in individual variables or else I'd have a bunch of variables to manage. Instead, I can use a list that will help me manage these names in one single variable. students = ['Joseph', 'Omar', 'Sue', 'Wendy', 'Natasha'] A list gives me a useful way to organize all those pieces of data. There are a few keys to remember about lists. Lists are ordered by index. This means that each value corresponds to a particular position in the list. The first item in a list is index 0. The last is the n-1 where n is the length of the list. They never get out of order unless you explicitly change them. Lists can contain different types of data at each index. Lists can be sliced (you can grab a chunk of the list by index number), iterated over, and so on. Lists are mutable. This means their values at each index can be changed. Also, they can be shrunk or expanded as you like. You may have guessed, but all strings are lists of characters. This is not the same in all programming languages, but in Python, all of the list methods (see #6) can be used on strings. Lists have many built-in methods. To read all about them, check out this link .","title":"Lists--ordered, heterogenous, sequences of data"},{"location":"ch7/#tuples-ordered-heterogenous-ummutable-sequences-of-data","text":"uples are one of the more confusing features for those new to Python. In form, a tuple looks very much like a list. Let's compare: List: names = ['Sylvia', 'Eric', 'Bobby', 'Cassandra'] Tuple: names = ('Sylvia', 'Eric', 'Bobby', 'Cassandra') I can iterate through both in the same way. They are both indexed and the order is constant. So what's the difference? The major difference is that lists can change, and tuples cannot. If I want to change the list names, I can run the append() method on it to add another item, or I can replace the values in any index, or I can pop off a value from my list without creating a new list. Tuples cannot change. They are what we call immutable. Once I've created a tuple, it will always retain the same length and values in the same indices. What's the point? There are a few big reasons we might use a tuple rather than a list. First, a tuple, being immutable, provides substantial optimization for your code. Check this out: user1@DESKTOP-61VJ97U:~$ python3 -m timeit \"['Sylvia', 'Eric', 'Bobby', 'Cassandra']\" 10000000 loops, best of 5: 34.3 nsec per loop user1@DESKTOP-61VJ97U:~$ python3 -m timeit \"['Sylvia', 'Eric', 'Bobby', 'Cassandra']\" 10000000 loops, best of 5: 34.2 nsec per loop user1@DESKTOP-61VJ97U:~$ python3 -m timeit \"('Sylvia', 'Eric', 'Bobby', 'Cassandra')\" 50000000 loops, best of 5: 4.87 nsec per loop user1@DESKTOP-61VJ97U:~$ python3 -m timeit \"('Sylvia', 'Eric', 'Bobby', 'Cassandra')\" 50000000 loops, best of 5: 4.9 nsec per loop Timeit runs the code for n loops 5 times and gives you the best average. So, we created the list 10 million times and found the average per loop time was 34.3 nanoseconds and 34.2 nanoseconds. In the second case, we created the same series as a tuple, but this time we did it 50 million times and found that the average loop time was 4.87 adn 4.9 nanoseconds per loop. For a small list, this isn't a bit difference, but imagine if our sequence had a million items in it. Tuples provide a great performance boost, but they can't be changed, so if you want to alter the values stored in them, you can't. Tuples are most often used to store a sequence of related values, like a sequence of values pulled from a database. Additionally, tuples are hashable, so we can compare two tuples or use them as keys in a dictionary.","title":"Tuples--ordered, heterogenous, ummutable sequences of data"},{"location":"ch7/#sets-unordered-collections-of-unique-values","text":"Sets are also collections of values like a list or a tuple, but they differ in a few important ways. First, they are unordered. This means that if you add a value to a set, you cannot know what index that value might be found at. Second, every value in a set must be unique. To create a set we use curly brackets: my_set = {'apples', 'bananas', 'grapefruits'} Sets are useful for getting unique values. If I wanted to get unique values in a list, maybe the fastest way would be to add the elements in the list to a set. The resulting set would only keep the unique elements. Sets are also extremely fast for lookups to see if a particular value is present in the collection.","title":"Sets--unordered collections of unique values"},{"location":"ch7/#dictionaries-collections-of-key-value-pairs","text":"A dictionary is another compound data type. It is used to store data in what's called key-value pairs. What this means is that each value has an identifying key or name that you can use to find that value easily. Remember with lists to find an item, you had to know its index, but with a dictionary, you just need to know its key. The basic syntax for a dictionary is {'key': 'value', 'key2': 'value2'...} This means each key and value are paired with each other. Let's take a quick look. classes = {'name': 'everyday coding', 'students': 'Matt', 'day': 'Wednesday', 'location': 'Admn 306'} So, my classes dictionary keys are 'name', 'students', 'day', and 'location'. Each of these has a corresponding value. If I want to get the name of the class, I just need to call classes['name']. This is very useful for larger complex data sets where you want to be able to pluck out a specific value. Here are some keys to dictionaries: Like lists, dictionaries are mutable. They can change length and any value in them can change. Unlike lists, dictionaries are not strictly ordered. There's no guarantee that the first item in the list will always be first. Maybe it will, maybe it won't. So it's totally unreliable to try to grab an item by its index like you did with lists. Dictionaries can hold any types of data as long as they are in key-value pairs. Keys are generally memorable strings. the value could be any type including lists, dictionaries, and tuples. In fact, I'd probably create the dictionary above as more complex. classes = {'everyday' : {'students':['Matt'], 'location': 'Admn 306', 'day': 'Wednesday'}, 'intro': {...}} Please read the following to learn more about dictionaries You'll also notice that dictionaries look like data structures in other languages. In Javascript, they are similar to objects and in PHP they are the same as associative arrays. Be aware, if you're using Python to process JSON objects you need to parse the object into a dictionary before you can work with it.","title":"Dictionaries--collections of key value pairs"},{"location":"ch8/","text":"Introduction to functions Making it Generic Programmers are inherently lazy. By this I mean, programmers write as little code as they possibly can. This is useful for a few reasons. First, the fewer lines of code you write, the less likely you are to have an error. Second, if you refactor your code, you have fewer places to make changes. Third, you get to spend less time writing code and more time working on other things. How do we make something generic? Think about making a peanut butter and jelly sandwich. If I were to give you instructions they might include these steps (I've cut out a lot to not waste your time): Use hand and turn peanut butter jar lid until the lid is loose. Lift lid off jar. Place the lid on the counter. Use hand and turn jelly jar lid until the lid is loose. Lift lid off jar. Place the lid on the counter. Notice that I have two series of steps that are basically the same, but are done on different kinds of jars. A much simpler way would be to first make sure you know what the generic sequence of steps is \"Use hand to turn, lift lid, place lid on counter.\" We do this in our own language. Instead of telling someone all those steps, we'd say, \"open the jar.\" The human audience would know that openning the jar involves more smaller actions, but they group those actions into openning the jar. The general activity of opening jars can be done on any sort of jar as long as it has a lid and is opened by turning. Computers give us the same thing, but we need to teach them what a group of general actions are called. What I would do is create a collection of actions called, \"open ____ jar\" and then my program becomes: Open the jelly jar. Open the peanut butter jar. I cut the steps down from 6 to 2, and if I want to change the process, I just need to redefine what I mean by \"Open.\" I took a series of steps and made them general enough to be applied to various types of jars. Generalization in programming works very much like this. Let's say I want to test if a series of lists of numbers are even, and if they are add them to a list of numbers. I could do something like this where I write out the instructions for each list: my_nums1 = [5, 2, 7, 8, 0] my_nums2 = [10, 15, 8, 8, 4] my_nums3 = [1, 7, 4, 5, 3, 6] evenNums = [] for num in my_nums1: if num % 2 == 0: evenNums.append(num) for num in my_nums2: if num % 2 == 0: evenNums.append(num) for num in my_nums3: if num % 2 == 0: evenNums.append(num) After Python executes these instructions evenNums will contain the even values from all three lists. However, it's not particularly efficient. Notice the code is exactly the same except for the name of the list that is to be iterated through. Wouldn't it be easier to write the instructions once in my code and then call the instructions on each of the lists? Totally. I'm going to build what is called a function that makes the instructions work on any list. evenNums = [] my_nums1 = [5, 2, 7, 8, 0] my_nums2 = [10, 15, 8, 8, 4] my_nums3 = [1, 7, 4, 5, 3, 6] def get_even(my_list): for num in my_list: if num % 2 == 0: evenNums.append(num) # now I call the function on each of the lists. get_even(my_nums1) get_even(my_nums2) get_even(my_nums3) This is cool because I took a specific set of instructions that were repeated, figured out how the action could be generalized, and finally wrote those instructions into a general function that can operate on many input values. Also, if I wanted to tweak this slightly, then I could change the 2 to a 3 or any other multiple to find the numbers that are multiples of that number. In fact, I could even generalize further expanding the functionality of my function. evenNums = [] my_nums1 = [5, 2, 7, 8, 0] my_nums2 = [10, 15, 8, 8, 4] my_nums3 = [1, 7, 4, 5, 3, 6] def get_mulitple(my_list, multiple): for num in my_list: if num % multiple == 0: evenNums.append(num) # add to evenNums multiples of 5 from list 1 get_multiple(my_nums1, 5) # add to evenNums multiples of 2 from list 1 get_multiple(my_nums2, 2) # add to evenNums multiples of 3 from list 1 get_multiple(my_nums3, 3) Building functions is about taking instructions, identifying what variables you want to generalize out, and turning those into arguments that the function can receive from the user or another program calling this function. Anatomy of a function Now that you've seen some functions in action, I want to point out the anatomy of a function. A function has three main parts: the input , the output , and the block . The input is anything that the function takes in from outside. This could be an argument or parameter--the things that go between the parentheses in the function definition and call. It could also be user input using the input() function, although I generally try to reserve this for a separate user interface unless the program is very small and single-purposed. Finally, the input could also come from files or other data streams that get opened in the body of the function. The output is whatever the function returns to the scope outside the function. This could be printing or writing to some user interface or file. More commonly, the output is whatever is after the return statement. This keyword is the instruction that sends data from inside the function to outside. Think of it like a vending machine. You put money and data into the machine. The machine does some stuff internally (usually you can see that stuff through the window) and finally, it returns a candy bar to you. Once again, just like the input, I like to use the return statement for the output and create a separate user interface to print the data to the screen or otherwise share it with other processes or the user. Finally, the block is the set of instructions that are executed every time the function is called. Notice that there might be variables, operations, logic checks, branches, etc. within the function. Another thing to notice is that I might have a variable with the same name inside the function, inside the parameter of the function and in the instructions outside of the function. See search_words in the next chapter as an example. The variable, even if it has the same name, refers to a different space in memory. So if I have x as a variable outside of the function, and then I have x as the parameter of the function, and I have an x in the body of the function, you should think of them as three different variables that might hold different values. Here is the explanation again in code: # Here's a function with it's parts identified: def my_crazy_function(x): # \"def\" is a keyword that means you're making a function. def is followed by the name of the function. It can either be camelCase or snake_case. Following the function name you have parentheses which contain all of the parameters for the function. # The block--all the instructions that are part of the function. x = x ** x return x # This is what the function outputs to the rest of the program. # Whenever you want to call a function, you simply include the function name with any parameters. x = 7 output = my_crazy_function(x) #in this line, the program will do the instructions in the function. The x in the parameter ( my_crazy_function(x) ) is a different variable than the x = 7 variable. Finally, the line x = x ** x means \"create a new variable called x that is local to the function (only exists inside the function) and save to it the value of the parameter x to the power of the parameter x . I know this is confusing, perhaps, but it is worth taking some time to consider this and pay attention to it because it is very common for a program to have the same variable name used for different variables in different scopes. Scope Not the mouthwash, scope refers to where different data is accessible. This is a complicated topic that leads to a lot of grief. We will spend a good deal of time discussing scope in class and in next week's module. For now, think of it as what container or block does a piece of data live in. If I have a variable \"my_var\" inside a function, I the program can only access that variable inside of the function. It cannot access the if I try to use it outside, or it would be a different variable.","title":"Introduction to Functions"},{"location":"ch8/#introduction-to-functions","text":"","title":"Introduction to functions"},{"location":"ch8/#making-it-generic","text":"Programmers are inherently lazy. By this I mean, programmers write as little code as they possibly can. This is useful for a few reasons. First, the fewer lines of code you write, the less likely you are to have an error. Second, if you refactor your code, you have fewer places to make changes. Third, you get to spend less time writing code and more time working on other things. How do we make something generic? Think about making a peanut butter and jelly sandwich. If I were to give you instructions they might include these steps (I've cut out a lot to not waste your time): Use hand and turn peanut butter jar lid until the lid is loose. Lift lid off jar. Place the lid on the counter. Use hand and turn jelly jar lid until the lid is loose. Lift lid off jar. Place the lid on the counter. Notice that I have two series of steps that are basically the same, but are done on different kinds of jars. A much simpler way would be to first make sure you know what the generic sequence of steps is \"Use hand to turn, lift lid, place lid on counter.\" We do this in our own language. Instead of telling someone all those steps, we'd say, \"open the jar.\" The human audience would know that openning the jar involves more smaller actions, but they group those actions into openning the jar. The general activity of opening jars can be done on any sort of jar as long as it has a lid and is opened by turning. Computers give us the same thing, but we need to teach them what a group of general actions are called. What I would do is create a collection of actions called, \"open ____ jar\" and then my program becomes: Open the jelly jar. Open the peanut butter jar. I cut the steps down from 6 to 2, and if I want to change the process, I just need to redefine what I mean by \"Open.\" I took a series of steps and made them general enough to be applied to various types of jars. Generalization in programming works very much like this. Let's say I want to test if a series of lists of numbers are even, and if they are add them to a list of numbers. I could do something like this where I write out the instructions for each list: my_nums1 = [5, 2, 7, 8, 0] my_nums2 = [10, 15, 8, 8, 4] my_nums3 = [1, 7, 4, 5, 3, 6] evenNums = [] for num in my_nums1: if num % 2 == 0: evenNums.append(num) for num in my_nums2: if num % 2 == 0: evenNums.append(num) for num in my_nums3: if num % 2 == 0: evenNums.append(num) After Python executes these instructions evenNums will contain the even values from all three lists. However, it's not particularly efficient. Notice the code is exactly the same except for the name of the list that is to be iterated through. Wouldn't it be easier to write the instructions once in my code and then call the instructions on each of the lists? Totally. I'm going to build what is called a function that makes the instructions work on any list. evenNums = [] my_nums1 = [5, 2, 7, 8, 0] my_nums2 = [10, 15, 8, 8, 4] my_nums3 = [1, 7, 4, 5, 3, 6] def get_even(my_list): for num in my_list: if num % 2 == 0: evenNums.append(num) # now I call the function on each of the lists. get_even(my_nums1) get_even(my_nums2) get_even(my_nums3) This is cool because I took a specific set of instructions that were repeated, figured out how the action could be generalized, and finally wrote those instructions into a general function that can operate on many input values. Also, if I wanted to tweak this slightly, then I could change the 2 to a 3 or any other multiple to find the numbers that are multiples of that number. In fact, I could even generalize further expanding the functionality of my function. evenNums = [] my_nums1 = [5, 2, 7, 8, 0] my_nums2 = [10, 15, 8, 8, 4] my_nums3 = [1, 7, 4, 5, 3, 6] def get_mulitple(my_list, multiple): for num in my_list: if num % multiple == 0: evenNums.append(num) # add to evenNums multiples of 5 from list 1 get_multiple(my_nums1, 5) # add to evenNums multiples of 2 from list 1 get_multiple(my_nums2, 2) # add to evenNums multiples of 3 from list 1 get_multiple(my_nums3, 3) Building functions is about taking instructions, identifying what variables you want to generalize out, and turning those into arguments that the function can receive from the user or another program calling this function.","title":"Making it Generic"},{"location":"ch8/#anatomy-of-a-function","text":"Now that you've seen some functions in action, I want to point out the anatomy of a function. A function has three main parts: the input , the output , and the block . The input is anything that the function takes in from outside. This could be an argument or parameter--the things that go between the parentheses in the function definition and call. It could also be user input using the input() function, although I generally try to reserve this for a separate user interface unless the program is very small and single-purposed. Finally, the input could also come from files or other data streams that get opened in the body of the function. The output is whatever the function returns to the scope outside the function. This could be printing or writing to some user interface or file. More commonly, the output is whatever is after the return statement. This keyword is the instruction that sends data from inside the function to outside. Think of it like a vending machine. You put money and data into the machine. The machine does some stuff internally (usually you can see that stuff through the window) and finally, it returns a candy bar to you. Once again, just like the input, I like to use the return statement for the output and create a separate user interface to print the data to the screen or otherwise share it with other processes or the user. Finally, the block is the set of instructions that are executed every time the function is called. Notice that there might be variables, operations, logic checks, branches, etc. within the function. Another thing to notice is that I might have a variable with the same name inside the function, inside the parameter of the function and in the instructions outside of the function. See search_words in the next chapter as an example. The variable, even if it has the same name, refers to a different space in memory. So if I have x as a variable outside of the function, and then I have x as the parameter of the function, and I have an x in the body of the function, you should think of them as three different variables that might hold different values. Here is the explanation again in code: # Here's a function with it's parts identified: def my_crazy_function(x): # \"def\" is a keyword that means you're making a function. def is followed by the name of the function. It can either be camelCase or snake_case. Following the function name you have parentheses which contain all of the parameters for the function. # The block--all the instructions that are part of the function. x = x ** x return x # This is what the function outputs to the rest of the program. # Whenever you want to call a function, you simply include the function name with any parameters. x = 7 output = my_crazy_function(x) #in this line, the program will do the instructions in the function. The x in the parameter ( my_crazy_function(x) ) is a different variable than the x = 7 variable. Finally, the line x = x ** x means \"create a new variable called x that is local to the function (only exists inside the function) and save to it the value of the parameter x to the power of the parameter x . I know this is confusing, perhaps, but it is worth taking some time to consider this and pay attention to it because it is very common for a program to have the same variable name used for different variables in different scopes.","title":"Anatomy of a function"},{"location":"ch8/#scope","text":"Not the mouthwash, scope refers to where different data is accessible. This is a complicated topic that leads to a lot of grief. We will spend a good deal of time discussing scope in class and in next week's module. For now, think of it as what container or block does a piece of data live in. If I have a variable \"my_var\" inside a function, I the program can only access that variable inside of the function. It cannot access the if I try to use it outside, or it would be a different variable.","title":"Scope"},{"location":"ch9/","text":"Decomposition You've seen in the last couple weeks the way in which we need to divide up a particular task into steps if we want to make a computer program. This is crucial because the program can only perform one command at a time (unless we're multi-threading, but that's a topic for another class), and that one command has to be a single specific action. As a result, if we want to create computer programs that solve real-life problems, we need to be able to break those problems into a series of parts, and our solution needs to be a series of steps that the computer can perform sequentially. This process of breaking a process down into its component steps is called Decomposition. In terms of programming, it's impossible to solve complex problems or build systems without doing this. In terms of general problem solving, decomposition can help us make complex situations and tasks more approachable. For instance, if I say, \"write a 30 page essay that argues that technological capital is a better lens to understand technological inequality than the digital divide\" you could just start writing, but that would be overwhelming. Instead, you'd be better to divide that problem into a bunch of individual components. For instance, you'll need a section that defines technological inequality, another set of sections that look at individual elements of that problem, another section that defines technological capital, and so on. Each of those sections is an approachable task. But I digress... Let's think about a process that we might want to solve: I want to create a process that reads text and finds occurrences of particular words in a text. This could be useful for looking for jargon words or dog-whistles and slurs or vocabulary words in use. Look below at the way I've broken this process into some functions. For this example, I've set myself up with the project of creating a program that reads a text, identifies if keywords are in the text, and returns a score based on frequency of those words. I might use this to score texts for the presence of racist or sexist language. First I need to get the list of search words. This should either be passed as an argument or parameter, OR it could be entered directly from the terminal. I'll write this into my program in pseudocode, first. myprogram.py # function called get_search_words that takes a parameter, or it prompts the user in the cli. # check and see if there's a parameter. # if not prompt the user for a file or for direct input # if file, open the file and read it in # if not file, prompt user for a list of words. I better make sure there's a maximum number. # if the user changes their mind, give them a way to quit. You'll notice that I start with a list of steps that I need to do. If I have no idea how to do any given step, I'll isolate that step and try to figure out how to do that one instruction. Let's start with the first bit. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input # if file, open the file and read it in # if not file, prompt user for a list of words. I better make sure there's a maximum number. # if the user changes their mind, give them a way to quit. return search_words Okay, so I have my function defined and the case where the search words are passed as a parameter. That's great news. Now I need to think about the instructions to prompt a user for how they want to enter the search words. I can do this next. Notice, if there are search words in the parameter, the parameter is returned and the function will exit. The only way the program ever gets to the line search_words = [] is if search_words in the parameter is empty. So, let's get to prompting the user. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file pass elif user_in.lower == \"m\": # do a manual entry instructions # make sure we have a maximum number. pass # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words You can see that now my program has 4 potential forks. The first tong is if there is a parameter. Then we just return that list. The second is if the user enters \"f\" or \"F\" for a file entry. We have used pass as a placeholder for now. The third is if the user enters \"m\" or \"M\" for manual entry. Again, we have a placeholder. The fourth condition is default, so if the user enters anything besides \"f\", \"F\", \"m\", or \"M\", the program will exit with a None value returned. That I create a default rather than check for \"Q\" is a design decision. I designed it that way so that the program exits if, say, the user enters a typo or a wrong letter. I use this default case to catch everything except the specific values I'm looking for. That is a good design strategy because now I don't have to worry about what happens if the user enters \"X\" or \"47\" or anything else. The program will just exit. Next, I'll do a big chunk, and create instructions for manual text entry. I'm going to limit the list arbitrarily to 10 search words. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file pass elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words Okay, so that's pretty swell. Now I have a counter that limits my manual prompting to 10 words. I also have a variable more which is set to False if the user decides they want to quit. Then the word is added to the search_words list. If I needed to look at how to add to a list, I'd search for something on Google like, \"Python3 add element to list.\" Now, I need to figure out how to open a file. I'm going to do that by searching \"Python 3 open and read files.\" I'll find the open() function that's built in to Python that opens files. I see that it is a function that takes a file name as a parameter. By default, it will only read files, but I can change the mode to 'w' for writing. The function returns a file object, so if I store the output of the open() function to a variable, the variable will contain a handle to that file object. I'll start by playing around and seeing if I can write \"Good Morning\" to a file. I'll do this playing in the Python CLI before I return to my program. Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> f = open(\"test.txt\") Traceback (most recent call last): File \"<stdin>\", line 1, in <module> FileNotFoundError: [Errno 2] No such file or directory: 'test.txt' >>> f = open(\"test.txt\", 'w') >>> f.write(\"Good Morning\") 12 >>> f.read() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> io.UnsupportedOperation: not readable >>> f.close() >>> f = open(\"test.txt\") >>> f.read() 'Good Morning' >>> I see that I can open a new file in write mode. I can write some text to the file. Then I need to close the file and open it again before I can read from it. I do that, and when I read the file, I see that 'Good Morning' was added to the file. Next I do a little research and read about the with {} as {}: syntax. This allows me to open a file and close it with fewer lines of code. Let's test it out. >>> with open('test.txt', 'w') as f: ... f.write('Good Evening') ... 12 >>> with open('test.txt') as f: ... f.read() ... 'Good Evening' >>> Cool, so now I have a bit of a sense of how to open, write, and read from files. I might go on and test how to read multiple lines of a file or how to iterate through a file line by line. I'll learn that by using readlines() instead of read() on the file, I can read each line into a list. Now I'll jump back to the code and add what I learned: myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file file_name = input(\"Enter the name of the file: \") with open(file_name) as f: search_words = f.readlines() elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words This is all well and good. I'm going to read the lines of the file. This will basically work. My next step will be to write a driver that tests the function. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file file_name = input(\"Enter the name of the file: \") with open(file_name) as f: search_words = f.readlines() elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words if __name__ == \"__main__\": words = ['apple', 'blueberry', 'mango'] s_words = get_search_words(words) print(\"Original words: \") for w in words: print(w) print(\"Search Words\") for w in s_words: print(w) s_words2 = get_seard_words() for w in s_words2: print(w) I can run this and see what happens. Now to finish out my program, and I'll need to write a second function that uses the output from get_search_words that will take a block of text and list of search words, and return the total number of search words found, the total number of words, and percentage of total words the search words make up. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file file_name = input(\"Enter the name of the file: \") with open(file_name) as f: search_words = f.readlines() elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words def text_scorer(text, search_words): # iterate through search_words and get the frequency of each # in the text. Also create a variable to store the count. word_counter = 0 total_words = len(text.split(\" \")) for word in search_words: word_counter += text.count(word) output = (word_counter, total_words) if __name__ == \"__main__\": words = ['apple', 'blueberry', 'mango'] s_words = get_search_words(words) print(\"Original words: \") for w in words: print(w) print(\"Search Words\") for w in s_words: print(w) s_words2 = get_seard_words() for w in s_words2: print(w) That was pretty easy. I just use the built in count() function and keep a running total. Now I just need to modify the driver so that we can get it working as we like: myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file file_name = input(\"Enter the name of the file: \") with open(file_name) as f: search_words = f.readlines() elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words def text_scorer(text, search_words): # iterate through search_words and get the frequency of each # in the text. Also create a variable to store the count. word_counter = 0 total_words = len(text.split(\" \")) for word in search_words: word_counter += text.count(word) output = (word_counter, total_words) if __name__ == \"__main__\": words = ['apple', 'blueberry', 'mango'] search_words = get_search_words(words) text = \"I like to eat apple, blueberry, and mango, but I don't like to eat them together. Apple is good. Blueberry is good, but blueberry and apple, not so good.\" scores = text_scorer(text, search_words) print(\"Search word frequency: {}\".format(output[0])) print(\"Total words: {}\".format(output[1])) print(\"Score: {}\".format((output[0]/output[1] * 100), 2)) This is a fairly small program, but hopefully you can see the process we go through to break down the larger problem into a sequence of steps that can be solved by the computer. That is the essence of decomposition. Approaches to Decomposition Procedural decomposition Procedural decomposition looks at a complex tasks and sees it as a series of procedures or steps. One you're probably familiar with is cooking. Imagine you want to make a cake. If you read a cookbook like the Joy of Cooking, you'll see recipes that are a series of steps with the appropriate ingredients and actions listed with their corresponding step. So, to make, say, spaghetti carbonara, you'd begin by starting some water boiling then dice some bacon and start cooking it then add pasta to the boiling water then skim off some of the oil from the bacon pan then when the pasta is done, reserve some cooking water and strain the pasta then mix the cooking water with eggs and cheese (carefully so as to not curdle the eggs). then, add pasta to the bacon pan finally, pour egg and cheese mixture over pasta serve with grated parmesan Most early programming was procedural, and many of the onboard programs for things like watches, printers, and so on remain to some extent procedural. Procedural programming is useful for systems where one task is going to be performed over and over again. It is also useful because you don't need a ton of memory to store complex objects or functions. You just have a list of commands that the machine operates. Likewise, you might use procedural approaches in utility scripts that you write for your own purposes. Let's say you work in IT for a university department and you're tasked with helping faculty members clean up their file naming conventions. You could go through and manually rename all these files, but it would be much better to spend a bit of time writing a script and letting the computer do the work for you. That said, instead of writing a huge program with functions and objects, all you'd need is a short set of procedures that walks through the file tree and renames files ending with .docx or .pdf. Of course, procedural programming is less effective if you have a complex program that requires a lot of different kinds of activities. In this case, you might move over to functional programming. Functional Programming Last week I mentioned that programmers are lazy. In procedural programming, if I wanted to read through and open 100 files, read their content, and find the occurrences of the word \"fish,\" I'd need to write with open(\"fileName\") as f: fish_counter += f.read().count(\"fish\") 100 times in my program. I'm lazy and I don't want to do all that typing. Plus, I don't like copy-and-pasting. If one of the copied items is wrong, I'd have to go through and fix 100 occurrences. Instead, I'm going to create a function to generalize that task of opening and reading a file. def count_fishes(file_list): fish_counter = 0 for f in file_list: with open(f) as fhandle: fish_counter += f.read().count(\"fish\") return fish_counter Functional programming decomposes problems into a series of procedures, but then it takes those procedures and attempts to identify redundancies or general tasks. We take these redundant tasks and turn them into functions, or a set of commands that takes some input and returns some output after performing some process. The general function for a recipe looks something like this: I see that in a recipe, I have a measure and add task that is repeated. I would probably want to create a function that can be used. In this case, I'd pass three parameters: 1. the ingredient to add, 2. how much to add, 3. when to add (this would interact with a global timer) Object-Oriented Object-oriented programming goes a step further towards generalization and encapsulation. I don't want to introduce OO programming to much yet, because we're spending two weeks on it starting next week, but in short, an Object is a way to group a set of attributes or features with a set of actions.","title":"Decomposition"},{"location":"ch9/#decomposition","text":"You've seen in the last couple weeks the way in which we need to divide up a particular task into steps if we want to make a computer program. This is crucial because the program can only perform one command at a time (unless we're multi-threading, but that's a topic for another class), and that one command has to be a single specific action. As a result, if we want to create computer programs that solve real-life problems, we need to be able to break those problems into a series of parts, and our solution needs to be a series of steps that the computer can perform sequentially. This process of breaking a process down into its component steps is called Decomposition. In terms of programming, it's impossible to solve complex problems or build systems without doing this. In terms of general problem solving, decomposition can help us make complex situations and tasks more approachable. For instance, if I say, \"write a 30 page essay that argues that technological capital is a better lens to understand technological inequality than the digital divide\" you could just start writing, but that would be overwhelming. Instead, you'd be better to divide that problem into a bunch of individual components. For instance, you'll need a section that defines technological inequality, another set of sections that look at individual elements of that problem, another section that defines technological capital, and so on. Each of those sections is an approachable task. But I digress... Let's think about a process that we might want to solve: I want to create a process that reads text and finds occurrences of particular words in a text. This could be useful for looking for jargon words or dog-whistles and slurs or vocabulary words in use. Look below at the way I've broken this process into some functions. For this example, I've set myself up with the project of creating a program that reads a text, identifies if keywords are in the text, and returns a score based on frequency of those words. I might use this to score texts for the presence of racist or sexist language. First I need to get the list of search words. This should either be passed as an argument or parameter, OR it could be entered directly from the terminal. I'll write this into my program in pseudocode, first. myprogram.py # function called get_search_words that takes a parameter, or it prompts the user in the cli. # check and see if there's a parameter. # if not prompt the user for a file or for direct input # if file, open the file and read it in # if not file, prompt user for a list of words. I better make sure there's a maximum number. # if the user changes their mind, give them a way to quit. You'll notice that I start with a list of steps that I need to do. If I have no idea how to do any given step, I'll isolate that step and try to figure out how to do that one instruction. Let's start with the first bit. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input # if file, open the file and read it in # if not file, prompt user for a list of words. I better make sure there's a maximum number. # if the user changes their mind, give them a way to quit. return search_words Okay, so I have my function defined and the case where the search words are passed as a parameter. That's great news. Now I need to think about the instructions to prompt a user for how they want to enter the search words. I can do this next. Notice, if there are search words in the parameter, the parameter is returned and the function will exit. The only way the program ever gets to the line search_words = [] is if search_words in the parameter is empty. So, let's get to prompting the user. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file pass elif user_in.lower == \"m\": # do a manual entry instructions # make sure we have a maximum number. pass # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words You can see that now my program has 4 potential forks. The first tong is if there is a parameter. Then we just return that list. The second is if the user enters \"f\" or \"F\" for a file entry. We have used pass as a placeholder for now. The third is if the user enters \"m\" or \"M\" for manual entry. Again, we have a placeholder. The fourth condition is default, so if the user enters anything besides \"f\", \"F\", \"m\", or \"M\", the program will exit with a None value returned. That I create a default rather than check for \"Q\" is a design decision. I designed it that way so that the program exits if, say, the user enters a typo or a wrong letter. I use this default case to catch everything except the specific values I'm looking for. That is a good design strategy because now I don't have to worry about what happens if the user enters \"X\" or \"47\" or anything else. The program will just exit. Next, I'll do a big chunk, and create instructions for manual text entry. I'm going to limit the list arbitrarily to 10 search words. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file pass elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words Okay, so that's pretty swell. Now I have a counter that limits my manual prompting to 10 words. I also have a variable more which is set to False if the user decides they want to quit. Then the word is added to the search_words list. If I needed to look at how to add to a list, I'd search for something on Google like, \"Python3 add element to list.\" Now, I need to figure out how to open a file. I'm going to do that by searching \"Python 3 open and read files.\" I'll find the open() function that's built in to Python that opens files. I see that it is a function that takes a file name as a parameter. By default, it will only read files, but I can change the mode to 'w' for writing. The function returns a file object, so if I store the output of the open() function to a variable, the variable will contain a handle to that file object. I'll start by playing around and seeing if I can write \"Good Morning\" to a file. I'll do this playing in the Python CLI before I return to my program. Python 3.8.5 (default, Jul 28 2020, 12:59:40) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> f = open(\"test.txt\") Traceback (most recent call last): File \"<stdin>\", line 1, in <module> FileNotFoundError: [Errno 2] No such file or directory: 'test.txt' >>> f = open(\"test.txt\", 'w') >>> f.write(\"Good Morning\") 12 >>> f.read() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> io.UnsupportedOperation: not readable >>> f.close() >>> f = open(\"test.txt\") >>> f.read() 'Good Morning' >>> I see that I can open a new file in write mode. I can write some text to the file. Then I need to close the file and open it again before I can read from it. I do that, and when I read the file, I see that 'Good Morning' was added to the file. Next I do a little research and read about the with {} as {}: syntax. This allows me to open a file and close it with fewer lines of code. Let's test it out. >>> with open('test.txt', 'w') as f: ... f.write('Good Evening') ... 12 >>> with open('test.txt') as f: ... f.read() ... 'Good Evening' >>> Cool, so now I have a bit of a sense of how to open, write, and read from files. I might go on and test how to read multiple lines of a file or how to iterate through a file line by line. I'll learn that by using readlines() instead of read() on the file, I can read each line into a list. Now I'll jump back to the code and add what I learned: myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file file_name = input(\"Enter the name of the file: \") with open(file_name) as f: search_words = f.readlines() elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words This is all well and good. I'm going to read the lines of the file. This will basically work. My next step will be to write a driver that tests the function. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file file_name = input(\"Enter the name of the file: \") with open(file_name) as f: search_words = f.readlines() elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words if __name__ == \"__main__\": words = ['apple', 'blueberry', 'mango'] s_words = get_search_words(words) print(\"Original words: \") for w in words: print(w) print(\"Search Words\") for w in s_words: print(w) s_words2 = get_seard_words() for w in s_words2: print(w) I can run this and see what happens. Now to finish out my program, and I'll need to write a second function that uses the output from get_search_words that will take a block of text and list of search words, and return the total number of search words found, the total number of words, and percentage of total words the search words make up. myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file file_name = input(\"Enter the name of the file: \") with open(file_name) as f: search_words = f.readlines() elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words def text_scorer(text, search_words): # iterate through search_words and get the frequency of each # in the text. Also create a variable to store the count. word_counter = 0 total_words = len(text.split(\" \")) for word in search_words: word_counter += text.count(word) output = (word_counter, total_words) if __name__ == \"__main__\": words = ['apple', 'blueberry', 'mango'] s_words = get_search_words(words) print(\"Original words: \") for w in words: print(w) print(\"Search Words\") for w in s_words: print(w) s_words2 = get_seard_words() for w in s_words2: print(w) That was pretty easy. I just use the built in count() function and keep a running total. Now I just need to modify the driver so that we can get it working as we like: myprogram.py # fuction called search words with a parameter def get_search_words(search_words): # check and see if there's a parameter, and if so return it. if search_words: return search words # this is the end of function in this branch # if we get to this point, the user is entering the words manually search_words = [] # if not prompt the user for a file or for direct input user_in = input(\"Entry method: (f)ile, (m)anual, (Q)uit\") # if file, open the file and read it in if user_in.lower == \"f\": #do stuff for the file file_name = input(\"Enter the name of the file: \") with open(file_name) as f: search_words = f.readlines() elif user_in.lower == \"m\": # do a manual entry instructions count = 1 more = True while count < 11 and more: word = input(\"Enter word # {}: (q to exit)\".format(count)) # make sure we have a maximum number. if word.lower() == \"q\": more = False else: search_words.append(word) count += 1 # I'm using Q as the default case. So if the user doesn't enter # \"f\", \"F\", \"m\", or \"M\", then the program quits. else: return None return search_words def text_scorer(text, search_words): # iterate through search_words and get the frequency of each # in the text. Also create a variable to store the count. word_counter = 0 total_words = len(text.split(\" \")) for word in search_words: word_counter += text.count(word) output = (word_counter, total_words) if __name__ == \"__main__\": words = ['apple', 'blueberry', 'mango'] search_words = get_search_words(words) text = \"I like to eat apple, blueberry, and mango, but I don't like to eat them together. Apple is good. Blueberry is good, but blueberry and apple, not so good.\" scores = text_scorer(text, search_words) print(\"Search word frequency: {}\".format(output[0])) print(\"Total words: {}\".format(output[1])) print(\"Score: {}\".format((output[0]/output[1] * 100), 2)) This is a fairly small program, but hopefully you can see the process we go through to break down the larger problem into a sequence of steps that can be solved by the computer. That is the essence of decomposition.","title":"Decomposition"},{"location":"ch9/#approaches-to-decomposition","text":"","title":"Approaches to Decomposition"},{"location":"ch9/#procedural-decomposition","text":"Procedural decomposition looks at a complex tasks and sees it as a series of procedures or steps. One you're probably familiar with is cooking. Imagine you want to make a cake. If you read a cookbook like the Joy of Cooking, you'll see recipes that are a series of steps with the appropriate ingredients and actions listed with their corresponding step. So, to make, say, spaghetti carbonara, you'd begin by starting some water boiling then dice some bacon and start cooking it then add pasta to the boiling water then skim off some of the oil from the bacon pan then when the pasta is done, reserve some cooking water and strain the pasta then mix the cooking water with eggs and cheese (carefully so as to not curdle the eggs). then, add pasta to the bacon pan finally, pour egg and cheese mixture over pasta serve with grated parmesan Most early programming was procedural, and many of the onboard programs for things like watches, printers, and so on remain to some extent procedural. Procedural programming is useful for systems where one task is going to be performed over and over again. It is also useful because you don't need a ton of memory to store complex objects or functions. You just have a list of commands that the machine operates. Likewise, you might use procedural approaches in utility scripts that you write for your own purposes. Let's say you work in IT for a university department and you're tasked with helping faculty members clean up their file naming conventions. You could go through and manually rename all these files, but it would be much better to spend a bit of time writing a script and letting the computer do the work for you. That said, instead of writing a huge program with functions and objects, all you'd need is a short set of procedures that walks through the file tree and renames files ending with .docx or .pdf. Of course, procedural programming is less effective if you have a complex program that requires a lot of different kinds of activities. In this case, you might move over to functional programming.","title":"Procedural decomposition"},{"location":"ch9/#functional-programming","text":"Last week I mentioned that programmers are lazy. In procedural programming, if I wanted to read through and open 100 files, read their content, and find the occurrences of the word \"fish,\" I'd need to write with open(\"fileName\") as f: fish_counter += f.read().count(\"fish\") 100 times in my program. I'm lazy and I don't want to do all that typing. Plus, I don't like copy-and-pasting. If one of the copied items is wrong, I'd have to go through and fix 100 occurrences. Instead, I'm going to create a function to generalize that task of opening and reading a file. def count_fishes(file_list): fish_counter = 0 for f in file_list: with open(f) as fhandle: fish_counter += f.read().count(\"fish\") return fish_counter Functional programming decomposes problems into a series of procedures, but then it takes those procedures and attempts to identify redundancies or general tasks. We take these redundant tasks and turn them into functions, or a set of commands that takes some input and returns some output after performing some process. The general function for a recipe looks something like this: I see that in a recipe, I have a measure and add task that is repeated. I would probably want to create a function that can be used. In this case, I'd pass three parameters: 1. the ingredient to add, 2. how much to add, 3. when to add (this would interact with a global timer)","title":"Functional Programming"},{"location":"ch9/#object-oriented","text":"Object-oriented programming goes a step further towards generalization and encapsulation. I don't want to introduce OO programming to much yet, because we're spending two weeks on it starting next week, but in short, an Object is a way to group a set of attributes or features with a set of actions.","title":"Object-Oriented"}]}