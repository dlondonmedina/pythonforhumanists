{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python for Humanists Digital Humanists are individuals with technical skills and critical awareness. By combining the critical thinking and social consciousness rooted in social theory and humanist thougth with the technical know-how rooted in computer science and software development, digital humanists can help make our technologically saturated society more just, humane, and good. This text is designed to help digital humanists learn the Python programming language from a humanist perspective. Along with learning the syntax and design patterns, readers will be encouraged to consider what the software they develop does to the human society that it serves. This is very much a survey text, and I would strongly encourage readers to also visit Python for Everybody For the exercises in this text, starter-code is available. Please feel free to clone it here . About the Author I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids. Acknowledgements This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License .","title":"Home"},{"location":"#python-for-humanists","text":"Digital Humanists are individuals with technical skills and critical awareness. By combining the critical thinking and social consciousness rooted in social theory and humanist thougth with the technical know-how rooted in computer science and software development, digital humanists can help make our technologically saturated society more just, humane, and good. This text is designed to help digital humanists learn the Python programming language from a humanist perspective. Along with learning the syntax and design patterns, readers will be encouraged to consider what the software they develop does to the human society that it serves. This is very much a survey text, and I would strongly encourage readers to also visit Python for Everybody For the exercises in this text, starter-code is available. Please feel free to clone it here .","title":"Python for Humanists"},{"location":"#about-the-author","text":"I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids.","title":"About the Author"},{"location":"#acknowledgements","text":"This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License .","title":"Acknowledgements"},{"location":"ch1/","text":"Computers and You Welcome to Python for Humanists. This first chapter will introduce you to basic architecture of computers and the basics of setting up your development environment. By the end of this chapter, you'll have exercises that will ask you to walk through getting your development environment set up and ready to go. Computer Architecture If you were to open up your computer, and I do recommend that you do so someday, you'll see a bunch of silicone chips and wires and tower looking things. Whenever we use our computer, regardless of how fancy and complex the output on our screen might be or the calculations that the machine can accomplish, all that is happening inside the computer is a bunch of electricity flowing across the metal in particular patterns that are meaningful and useful. The various components work together to create patterns that achieve whatever commands we or some developer have provided to the machine. To understand how Python is working and to understand Concepts in Computing, it is useful to know the anatomy of a computer. There are very many types of computers from the system in your car to your smartphone to your desktop to your digital watch. In a nutshell, computers are machines that take some sort of input, do some calculations on those input, and finally return some sort of output. A simple calculator, for instance, takes numbers and operators as inputs, processes those inputs by performing the input operators, and finally returns the result of that operation as an output. More complicated computers, like a smartphone, just take different types of inputs and perform more complicated processes. Since all computers fundamentally do the same thing in varying degrees of complexities, they all have a basic set of components: Input and Output devices Processing Device Memory (Optional) Storage Let's start with the Input and Output (I/O) devices. I/O devices are the features that allow the computer to interact with the world. Input devices include keyboards, mice, touch screens, and so on. Each input device takes a specific type of data. Output devices include printers, monitors, speakers, and so on. Each output device returns a specific type of data. Computers might have various I/O devices, sometimes built in, sometimes peripheral, but they all will have some sort of I/O otherwise they won't be able to take data and return results. Memory is the next step. Memory is the space where data is stored when it is not immediately being processed. For instance, when you work in a Word document, your document is read from the long term storage to the memory. As you make changes, those changes are written to the memory, and when you \"Save\" the version of the document is written back to the long term storage medium. Memory is volatile, which means that when the computer shuts down or loses power, the memory is erased. The solution to this is long term storage, which will be covered below. If you've ever had the experience of working on a file and losing unsaved changes, it happened because those changes had not yet been written to long term storage. Processing devices are the processor. Processors come in various flavors and functionality, but they are responsible for managing all of the components of the computer (the memory and the I/O devices), and for running calculations. Every operation in a computer is the result of calculations done in binary. The processor is doing that constantly, often several calculations at once if you have a processor capable of multi-threading. (Optional) Most computers also have some form of long term storage. This might be a hard disk drive, a solid state drive, or a memory card. These are physical media of various sorts that can have data written to them in a permanent or semi-permanent state. In the case of hard disk drives, data is stored as charges written to magnetic platters. On larger computers like laptops and desktops, these components are usually connected through a motherboard that helps orchestrate the processes. When we begin programming, it is useful to consider what part of the physical machine is performing a particular thing because it perhaps will help you visualize and make sense of what's going on. This is especially true when we get to variables and files. Interacting with variables means we are interacting with memory and interacting with files we are interacting usually with long term storage. Beyond the Graphical User Interface Most of the time when you interact with a computer, you probably are doing so through what is called a Graphical User Interface (GUI). When you open your web browser, for instance, you have a window with URL bar and menus and a main pane where the website code is rendered for your enjoyment. Likewise, when you search for files, you are probably using File Explorer or Finder, both of which are GUIs for interacting with the file system. GUIs allow you to use your mouse and keyboard to interact with the computer through visual icons and fields. I cannot overstate the importance of GUIs to the proliferation of computers. Without a GUI, you would either have to use a command line interface or punch cards to use a computer. GUI's allow non-experts to gain access without facing the steep learning curve of learning commands or code or punch card patterns. Instead, you can issue commands to the computer through an intuitive interface of icons, labelled fields, and so on. That being said, GUIs limit the efficiency at which you can work and frequently limit your ability to issue commands to the computer. This means that if you want to move from being a user towards being a maker or developer (one who uses the computer as is, to one who might explore what the computer can be made to do) is to become familiar with what is called a Command Line Interface (CLI). There are numerous CLIs ranging from DOS Prompt, Windows Command LIne, Powershell, Bash, etc. Even Python has a CLI, which allows you to issue Python commands directly to the Python interpreter (this will make more sense next chapter). CLIs allow the user to issue text based commands to the system (whichever system reads and interprets the commands). So, just as I could use a GUI to view, create, open, move, and delete files and folders in the above example by clicking on buttons and icons in the GUI to issue commands to the Operating System, so too can I use the CLI to view, create, open, move, and delete files and folders by entering commands as text via the keyboard into the CLI. The particular CLI we will be using in this class is BASH . We are learning Bash instead of Command Prompt or Powershell because it is a very powerful \"shell\" that is built into all unix operating systems (Mac and Linux); however, at the time of writing, Mac is beginning to use Zsh instead, but the commands are largely the same so no worries. It is the standard CLI that you will encounter on nearly all web servers and will give you the most bang for your buck. Plus, it can be installed on Windows, and many bash commands are the saem in Powershell. Learning a CLI involves learning a set of commands (or \"magic words\") that are available. You won't need to memorize them all, but by spending time using the CLI, you will gradually pick them up. Why would we take the time to learn a CLI when you're already proficient at using a GUI? Great question! GUIs are limited to the set of actions that the GUI designer thinks that most users will need. The actions are usually triggered by a mouse click, but advanced users will likely learn Hotkeys or keyboard shortcuts to make their work faster. However, the program often has a number of other commands or actions that are difficult to access via the GUI. Using a CLI often gives you more power and control over what the program is doing. GUIs involve using a mouse or tabbing through buttons with the keyboard. This means that they are much slower to do complicated tasks. Once you become familiar with a CLI, you will be much faster at doing the same kinds of tasks, and many tasks are less complicated using a CLI than they are using a graphical interface. Let's say you decide to set up an application on a web server. First, that server exists in some server farm somewhere and the company that provides it allows you to access it remotely over a secure connection. That web server probably will not have a Desktop environment (a GUI for an operating system). Instead, it will have a CLI environment, and you will access it through a secure shell (ssh). Let's ignore the fact that the server will require that you use the CLI and think about how we might connect to that server remotely. To connect to that server, you set up an ssh connection. There are GUI programs that allow you to do this, like Putty, for instance. To do this, you must first install the program, then set up a connection through the form that the GUI provides and finally click the connect button. In Bash, however, all you have to do is type ssh username@server.com with any additional settings that might be necessary (e.g. you might need to type ssh -p 5257 username@server.com if you want to specify a particular port to connect to) and then hit enter. Likewise, many coding related applications have poor GUIs. Python's package manager (pip) for example only works in CLI. One word of caution: CLIs give you greater power and control over the machine, but that means you can mess things up pretty severely. I recommend knowing what a command will do before you execute it. This is particularly important if you are reading advice from StackOverflow or some other online forum that answers questions. Likewise, if you are not already practicing good backup habits, not would be an ideal time to start because it is possible to break things or lose data (e.g. rm -rf /home/ would delete all files installed by users without asking if you're sure). Installing Bash So if you're a Mac or Linux User, you can skip this section. You already have Bash or Zsh installed on your computer. In Mac, you'll need to locate the application called Terminal. In Linux, usually the hotkeys to open a terminal is CTRL+ALT+T. If you're a Windows 10 user, you have two options. You can set up Windows Subsystem Linux. Since developers frequently prefer developing in a Unix environment like Mac or Linux (for many reasons which I won't go into here), Windows has built a subsystem that allows you to use Linux within your Windows operating system. I use this personally when I'm using my Windows computer, but it is a little bit fiddly and permissions can be weird. The option I will walk you through here is using Git Bash. Git is a version control program that we'll talk about in a little bit, but they have created a version of Bash that works on Windows. It's lovely. head over to Git's download page and select the appropriate version of Git Bash to download. Run the installer that you just downloaded. I use the default settings, but if you want to customize the installation, feel free. Open Git Bash and a terminal will open up. Hooray. A taste of Bash If you want a great tutorial on how to use Bash and even write scripts in the Bash scripting language, check out Bash Academy for a really detailed tutorial of Bash. I strongly recommend this because knowing your way around a CLI will make the work of this program much easier. I will give you a quick overview here of Bash. I'd encourage you to follow along on your computer. When you open a Bash terminal, you will see a window with a black background and some text. Mine lookes like this: user1@DESKTOP-61VJ97U:~$ _ This is the prompt, and you'll see a cursor blinking right after the dollar sign. You can type commands here. Throughout this program, I will share code snippets and when I do, I will simply start with either ~$ or (env) ~$ So if you are following along and it looks slightly different, just know I'm cutting out the username and host for brevity sake. The first thing to learn about the CLI is how to navigate. Wherever the prompt is \"located\" in your file tree is where you will execute your commands. For example, if I am in a directory called \"projects\" and my prompt is set in that directory, then when I create a file it will be created within that directory. The first command we need to learn is pwd which stands for \"print working directory.\" The working directory is where my terminal is currently working. For example, when I open a terminal, it automatically opens to the home directory, represented by the tilda (~). So when I issue the command: ~$ pwd /home/user1 This means that my current working directory is /home/user1 and any command I issue, unless I specify otherwise, will be executed in that directory. Next, I will use the ls command to show you what directories reside within my home directory: ~$ ls Books Projects dylanmedina experiments Within my home directory I have Books, Projects, dylanmedina, and experiments. These are all directories that I can navigate into. These first two commands are crucial because they give me the location and context in which my CLI is operating. Now, let's say we're starting a new project, like this lesson. I might make a new directory for that project. To do so, I need to create a new directory and give it a name. The command is mkdir for \"make directory.\" You follow that by the name of the directory. One word on names: spaces don't work because each word of a command is separated by a space. So if I wanted to create a directory called Python for Humanists, and I issued the command ~$ mkdir Python for Humanists it would create three directories. One workaround is surround the name with quotation marks, but it's easier to just use names that don't have spaces. So let's go: ~$ mkdir pythonHumanist ~$ ls Books Projects dylanmedina experiments pythonHumanist You'll see, I created a directory called pythonHumanist and then I listed out the contents of my home directory, and you can see that my command worked. Now let's say we want to create our first Python script inside of the pythonHumanist directory. First, we can move into that directory and then we can create the file. To change directories we type cd followed by the absolute or relative path of the directory we want to visit. ~$ cd pythonHumanist ~/pythonHumanist$ You'll notice that the tilda is now followed by the directory name in my prompt showing me conveniently where I am (my working directory). Next, we create a file in that directory called hello.py and add some text to that file. We can do this in one step, but I'm doing two so you can see two different commands: ~/pythonHumanist$ touch hello.py ~/pythonHumanist$ ls hello.py ~/pythonHumanist$ echo \"print('Hello World')\" >> hello.py A few notes. First, we used the touch command to create a file. The general syntax is touch {filename} where {filename} is replaced by the name of the file you want to create. If you want to create multiple files, you can list them with a space separating each file name. Again, the same \"no spaces\" rule applies. Second, I listed out the contents of the directory to show that the file was created. If you opened the file at this point, it will be empty. Finally, I used the echo command followed by two >> greater than signs. The echo command prints some text. The greater than symbols writes the output of the echo command to the file. If I use 2 greater than signs, the output is appended to the end of the file. If I use one greater than sign, the file is overwritten with the new content. After this command, you'll see that the file hello.py contains the text print('Hello World') , which is Python code. More on that later. You can send the output of commands to other commands in Bash, and that ends up being a powerful feature. Next, let's say I want to copy files. This is really easy in Bash. The command is cp for copy and the syntax is cp {source} {destination} ~/pythonHumanist$ cp hello.py hello2.py ~/pythonHumanist$ ls hello.py hello2.py If you want to copy directories, you do so with the -r flag. Many commands have flags. These flags change the behavior of the command. In this case, I mean \"copy recursively\" or go through the contained directories and files and copy those as well as the outer directory that I named. The final command I want to cover here is rm which deletes files. BE CAREFUL WITH THIS COMMAND BECAUSE THERE WILL NOT BE A PROMPT ASKING IF YOU'RE SURE YOU WANT TO DELETE A FILE ~/pythonHumanist$ rm hello.py ~/pythonHumanist$ cd .. ~$ rm -r pythonHumanist First, I remove the file hello.py using the rm command. Then I change directories up one level ( .. signifies up one level) so I change the working directory to home. Then I remove the pythonHumanist directory using the -r flag. Again, many commands in Bash have flags that you can add that change the behavior. -r means recursive and it is what we use to remove directories. It means go into the directory, recursively delete all the files and then remove the directory. So if I had wanted to, I could have skipped removing the hello.py file first and just removed the directory and the file would have been deleted, too. There are many other commands that you will want to use, but I just wanted to give you a brief overview. We will encounter others that you'll have to learn as you go. If you have the time and energy, I strongly suggest spending a few hours and going further into Bash, as some of the concepts will make learning Python a bit easier. Setup our Environment We've done a bit of set up already and introduced you to the CLI. Now we need to finish getting things set up so that we can dive into Python next chapter. There are a few things we'll need. First, we need to get a good text editor. Python, as all code, is a bunch of human readable text that some program on the computer can understand and translate into the appropriate machine language that the computer can understand. There are tons of text editors out there and technically we could use Notepad for our code, but we want to use something with a few more features. KEY: do not use a word processor like Word to write code. When you use a word processor it adds extra markup to your file to display the formatting of the text and this will make your code non-functional. We will be using Visual Studio Code, but Atom is another good free option. I like Visual Studio Code because it gives you a file explorer and a terminal all built into one. Head over to the Visual Studio Code download page Download the installer for your operating system and run the installer. Check the installation by opening Git Bash (or Bash if you're in Mac) and typing code --version Set up User Settings in Visual Studio Code VS Code allows you to customize settings for all projects (User Settings) or for a single project (Workspace settings). To modify default settings select Code | Preferences for the Mac or File | Preferences for Windows and then Settings. You will see 2 files side by side. On the left are the default settings and on the right are the User setting overrides. To change a default setting find the setting on the left and then copy it to the right with your desired setting. For example, if you don't want to see the minimap on the right hand side of the application, you can make the following entry in the file on the right. Notice that options are key : value pairs and that they are commas separated. { \"editor.minimap.enabled\":false } Make \"Git Bash\" the default command line in VS Code terminal by adding the following to your User Settings: \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\" Install Python You'll also need to install Python. Python has a number of versions, and Python 3 is the one we will be using. If you are on Windows, you don't have Python. If you're on Mac or Linux, you have Python 2 so you need to add Python 3. Installing Python on Windows Head to the Python downloads page and select the Python 3 installer. Run the installer, and allow it to add Python3 to the Path. This is important, so make sure you pay attention to the option for adding Python3 to your PATH. Once you've installed Python3, open Git Bash and type python --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. If it still doesn't work, probably Python was not added to the PATH. You can Google adding Python to the PATH in Windows. Installing Python 3 on Mac Macs come with Python2 installed, so you will need to install Python3. Note, DO NOT UNINSTALL OR OTHERWISE REMOVE PYTHON 2 . It will break your operating system. Head to the Python downloads page and select the Python 3 installer. Run the installer. (Don't worry about the PATH, as that's not an issue we deal with in UNIX in the same way.) Once you've installed Python3, open Git Bash and type python3 --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. Also, if you type python --version it will say python 2.7 or something like that. By default on Mac and Linux, Python 2 is installed so the python command will use Python 2. We need to use python3 instead until we setup virtual environments. Set up Github Github is awesome! It is a place where you can share code and manage version control. Please do not get confused between Github and Git. Git is a CLI program that manages version control. Every time you \"commit\" changes with git, you create a new version. Behind the scenes, git manages a set of diff files that keep track of the changes that were made to the repository (or collection of code) since the last commit. Github is an online storage service that integrates with git and allows you to push your code to this service and share it both with teams and publicly. I'm not going to go over the Git commands here, but here is a good tutorial .","title":"Computers and You"},{"location":"ch1/#computers-and-you","text":"Welcome to Python for Humanists. This first chapter will introduce you to basic architecture of computers and the basics of setting up your development environment. By the end of this chapter, you'll have exercises that will ask you to walk through getting your development environment set up and ready to go.","title":"Computers and You"},{"location":"ch1/#computer-architecture","text":"If you were to open up your computer, and I do recommend that you do so someday, you'll see a bunch of silicone chips and wires and tower looking things. Whenever we use our computer, regardless of how fancy and complex the output on our screen might be or the calculations that the machine can accomplish, all that is happening inside the computer is a bunch of electricity flowing across the metal in particular patterns that are meaningful and useful. The various components work together to create patterns that achieve whatever commands we or some developer have provided to the machine. To understand how Python is working and to understand Concepts in Computing, it is useful to know the anatomy of a computer. There are very many types of computers from the system in your car to your smartphone to your desktop to your digital watch. In a nutshell, computers are machines that take some sort of input, do some calculations on those input, and finally return some sort of output. A simple calculator, for instance, takes numbers and operators as inputs, processes those inputs by performing the input operators, and finally returns the result of that operation as an output. More complicated computers, like a smartphone, just take different types of inputs and perform more complicated processes. Since all computers fundamentally do the same thing in varying degrees of complexities, they all have a basic set of components: Input and Output devices Processing Device Memory (Optional) Storage Let's start with the Input and Output (I/O) devices. I/O devices are the features that allow the computer to interact with the world. Input devices include keyboards, mice, touch screens, and so on. Each input device takes a specific type of data. Output devices include printers, monitors, speakers, and so on. Each output device returns a specific type of data. Computers might have various I/O devices, sometimes built in, sometimes peripheral, but they all will have some sort of I/O otherwise they won't be able to take data and return results. Memory is the next step. Memory is the space where data is stored when it is not immediately being processed. For instance, when you work in a Word document, your document is read from the long term storage to the memory. As you make changes, those changes are written to the memory, and when you \"Save\" the version of the document is written back to the long term storage medium. Memory is volatile, which means that when the computer shuts down or loses power, the memory is erased. The solution to this is long term storage, which will be covered below. If you've ever had the experience of working on a file and losing unsaved changes, it happened because those changes had not yet been written to long term storage. Processing devices are the processor. Processors come in various flavors and functionality, but they are responsible for managing all of the components of the computer (the memory and the I/O devices), and for running calculations. Every operation in a computer is the result of calculations done in binary. The processor is doing that constantly, often several calculations at once if you have a processor capable of multi-threading. (Optional) Most computers also have some form of long term storage. This might be a hard disk drive, a solid state drive, or a memory card. These are physical media of various sorts that can have data written to them in a permanent or semi-permanent state. In the case of hard disk drives, data is stored as charges written to magnetic platters. On larger computers like laptops and desktops, these components are usually connected through a motherboard that helps orchestrate the processes. When we begin programming, it is useful to consider what part of the physical machine is performing a particular thing because it perhaps will help you visualize and make sense of what's going on. This is especially true when we get to variables and files. Interacting with variables means we are interacting with memory and interacting with files we are interacting usually with long term storage.","title":"Computer Architecture"},{"location":"ch1/#beyond-the-graphical-user-interface","text":"Most of the time when you interact with a computer, you probably are doing so through what is called a Graphical User Interface (GUI). When you open your web browser, for instance, you have a window with URL bar and menus and a main pane where the website code is rendered for your enjoyment. Likewise, when you search for files, you are probably using File Explorer or Finder, both of which are GUIs for interacting with the file system. GUIs allow you to use your mouse and keyboard to interact with the computer through visual icons and fields. I cannot overstate the importance of GUIs to the proliferation of computers. Without a GUI, you would either have to use a command line interface or punch cards to use a computer. GUI's allow non-experts to gain access without facing the steep learning curve of learning commands or code or punch card patterns. Instead, you can issue commands to the computer through an intuitive interface of icons, labelled fields, and so on. That being said, GUIs limit the efficiency at which you can work and frequently limit your ability to issue commands to the computer. This means that if you want to move from being a user towards being a maker or developer (one who uses the computer as is, to one who might explore what the computer can be made to do) is to become familiar with what is called a Command Line Interface (CLI). There are numerous CLIs ranging from DOS Prompt, Windows Command LIne, Powershell, Bash, etc. Even Python has a CLI, which allows you to issue Python commands directly to the Python interpreter (this will make more sense next chapter). CLIs allow the user to issue text based commands to the system (whichever system reads and interprets the commands). So, just as I could use a GUI to view, create, open, move, and delete files and folders in the above example by clicking on buttons and icons in the GUI to issue commands to the Operating System, so too can I use the CLI to view, create, open, move, and delete files and folders by entering commands as text via the keyboard into the CLI. The particular CLI we will be using in this class is BASH . We are learning Bash instead of Command Prompt or Powershell because it is a very powerful \"shell\" that is built into all unix operating systems (Mac and Linux); however, at the time of writing, Mac is beginning to use Zsh instead, but the commands are largely the same so no worries. It is the standard CLI that you will encounter on nearly all web servers and will give you the most bang for your buck. Plus, it can be installed on Windows, and many bash commands are the saem in Powershell. Learning a CLI involves learning a set of commands (or \"magic words\") that are available. You won't need to memorize them all, but by spending time using the CLI, you will gradually pick them up. Why would we take the time to learn a CLI when you're already proficient at using a GUI? Great question! GUIs are limited to the set of actions that the GUI designer thinks that most users will need. The actions are usually triggered by a mouse click, but advanced users will likely learn Hotkeys or keyboard shortcuts to make their work faster. However, the program often has a number of other commands or actions that are difficult to access via the GUI. Using a CLI often gives you more power and control over what the program is doing. GUIs involve using a mouse or tabbing through buttons with the keyboard. This means that they are much slower to do complicated tasks. Once you become familiar with a CLI, you will be much faster at doing the same kinds of tasks, and many tasks are less complicated using a CLI than they are using a graphical interface. Let's say you decide to set up an application on a web server. First, that server exists in some server farm somewhere and the company that provides it allows you to access it remotely over a secure connection. That web server probably will not have a Desktop environment (a GUI for an operating system). Instead, it will have a CLI environment, and you will access it through a secure shell (ssh). Let's ignore the fact that the server will require that you use the CLI and think about how we might connect to that server remotely. To connect to that server, you set up an ssh connection. There are GUI programs that allow you to do this, like Putty, for instance. To do this, you must first install the program, then set up a connection through the form that the GUI provides and finally click the connect button. In Bash, however, all you have to do is type ssh username@server.com with any additional settings that might be necessary (e.g. you might need to type ssh -p 5257 username@server.com if you want to specify a particular port to connect to) and then hit enter. Likewise, many coding related applications have poor GUIs. Python's package manager (pip) for example only works in CLI. One word of caution: CLIs give you greater power and control over the machine, but that means you can mess things up pretty severely. I recommend knowing what a command will do before you execute it. This is particularly important if you are reading advice from StackOverflow or some other online forum that answers questions. Likewise, if you are not already practicing good backup habits, not would be an ideal time to start because it is possible to break things or lose data (e.g. rm -rf /home/ would delete all files installed by users without asking if you're sure).","title":"Beyond the Graphical User Interface"},{"location":"ch1/#installing-bash","text":"So if you're a Mac or Linux User, you can skip this section. You already have Bash or Zsh installed on your computer. In Mac, you'll need to locate the application called Terminal. In Linux, usually the hotkeys to open a terminal is CTRL+ALT+T. If you're a Windows 10 user, you have two options. You can set up Windows Subsystem Linux. Since developers frequently prefer developing in a Unix environment like Mac or Linux (for many reasons which I won't go into here), Windows has built a subsystem that allows you to use Linux within your Windows operating system. I use this personally when I'm using my Windows computer, but it is a little bit fiddly and permissions can be weird. The option I will walk you through here is using Git Bash. Git is a version control program that we'll talk about in a little bit, but they have created a version of Bash that works on Windows. It's lovely. head over to Git's download page and select the appropriate version of Git Bash to download. Run the installer that you just downloaded. I use the default settings, but if you want to customize the installation, feel free. Open Git Bash and a terminal will open up. Hooray.","title":"Installing Bash"},{"location":"ch1/#a-taste-of-bash","text":"If you want a great tutorial on how to use Bash and even write scripts in the Bash scripting language, check out Bash Academy for a really detailed tutorial of Bash. I strongly recommend this because knowing your way around a CLI will make the work of this program much easier. I will give you a quick overview here of Bash. I'd encourage you to follow along on your computer. When you open a Bash terminal, you will see a window with a black background and some text. Mine lookes like this: user1@DESKTOP-61VJ97U:~$ _ This is the prompt, and you'll see a cursor blinking right after the dollar sign. You can type commands here. Throughout this program, I will share code snippets and when I do, I will simply start with either ~$ or (env) ~$ So if you are following along and it looks slightly different, just know I'm cutting out the username and host for brevity sake. The first thing to learn about the CLI is how to navigate. Wherever the prompt is \"located\" in your file tree is where you will execute your commands. For example, if I am in a directory called \"projects\" and my prompt is set in that directory, then when I create a file it will be created within that directory. The first command we need to learn is pwd which stands for \"print working directory.\" The working directory is where my terminal is currently working. For example, when I open a terminal, it automatically opens to the home directory, represented by the tilda (~). So when I issue the command: ~$ pwd /home/user1 This means that my current working directory is /home/user1 and any command I issue, unless I specify otherwise, will be executed in that directory. Next, I will use the ls command to show you what directories reside within my home directory: ~$ ls Books Projects dylanmedina experiments Within my home directory I have Books, Projects, dylanmedina, and experiments. These are all directories that I can navigate into. These first two commands are crucial because they give me the location and context in which my CLI is operating. Now, let's say we're starting a new project, like this lesson. I might make a new directory for that project. To do so, I need to create a new directory and give it a name. The command is mkdir for \"make directory.\" You follow that by the name of the directory. One word on names: spaces don't work because each word of a command is separated by a space. So if I wanted to create a directory called Python for Humanists, and I issued the command ~$ mkdir Python for Humanists it would create three directories. One workaround is surround the name with quotation marks, but it's easier to just use names that don't have spaces. So let's go: ~$ mkdir pythonHumanist ~$ ls Books Projects dylanmedina experiments pythonHumanist You'll see, I created a directory called pythonHumanist and then I listed out the contents of my home directory, and you can see that my command worked. Now let's say we want to create our first Python script inside of the pythonHumanist directory. First, we can move into that directory and then we can create the file. To change directories we type cd followed by the absolute or relative path of the directory we want to visit. ~$ cd pythonHumanist ~/pythonHumanist$ You'll notice that the tilda is now followed by the directory name in my prompt showing me conveniently where I am (my working directory). Next, we create a file in that directory called hello.py and add some text to that file. We can do this in one step, but I'm doing two so you can see two different commands: ~/pythonHumanist$ touch hello.py ~/pythonHumanist$ ls hello.py ~/pythonHumanist$ echo \"print('Hello World')\" >> hello.py A few notes. First, we used the touch command to create a file. The general syntax is touch {filename} where {filename} is replaced by the name of the file you want to create. If you want to create multiple files, you can list them with a space separating each file name. Again, the same \"no spaces\" rule applies. Second, I listed out the contents of the directory to show that the file was created. If you opened the file at this point, it will be empty. Finally, I used the echo command followed by two >> greater than signs. The echo command prints some text. The greater than symbols writes the output of the echo command to the file. If I use 2 greater than signs, the output is appended to the end of the file. If I use one greater than sign, the file is overwritten with the new content. After this command, you'll see that the file hello.py contains the text print('Hello World') , which is Python code. More on that later. You can send the output of commands to other commands in Bash, and that ends up being a powerful feature. Next, let's say I want to copy files. This is really easy in Bash. The command is cp for copy and the syntax is cp {source} {destination} ~/pythonHumanist$ cp hello.py hello2.py ~/pythonHumanist$ ls hello.py hello2.py If you want to copy directories, you do so with the -r flag. Many commands have flags. These flags change the behavior of the command. In this case, I mean \"copy recursively\" or go through the contained directories and files and copy those as well as the outer directory that I named. The final command I want to cover here is rm which deletes files. BE CAREFUL WITH THIS COMMAND BECAUSE THERE WILL NOT BE A PROMPT ASKING IF YOU'RE SURE YOU WANT TO DELETE A FILE ~/pythonHumanist$ rm hello.py ~/pythonHumanist$ cd .. ~$ rm -r pythonHumanist First, I remove the file hello.py using the rm command. Then I change directories up one level ( .. signifies up one level) so I change the working directory to home. Then I remove the pythonHumanist directory using the -r flag. Again, many commands in Bash have flags that you can add that change the behavior. -r means recursive and it is what we use to remove directories. It means go into the directory, recursively delete all the files and then remove the directory. So if I had wanted to, I could have skipped removing the hello.py file first and just removed the directory and the file would have been deleted, too. There are many other commands that you will want to use, but I just wanted to give you a brief overview. We will encounter others that you'll have to learn as you go. If you have the time and energy, I strongly suggest spending a few hours and going further into Bash, as some of the concepts will make learning Python a bit easier.","title":"A taste of Bash"},{"location":"ch1/#setup-our-environment","text":"We've done a bit of set up already and introduced you to the CLI. Now we need to finish getting things set up so that we can dive into Python next chapter. There are a few things we'll need. First, we need to get a good text editor. Python, as all code, is a bunch of human readable text that some program on the computer can understand and translate into the appropriate machine language that the computer can understand. There are tons of text editors out there and technically we could use Notepad for our code, but we want to use something with a few more features. KEY: do not use a word processor like Word to write code. When you use a word processor it adds extra markup to your file to display the formatting of the text and this will make your code non-functional. We will be using Visual Studio Code, but Atom is another good free option. I like Visual Studio Code because it gives you a file explorer and a terminal all built into one. Head over to the Visual Studio Code download page Download the installer for your operating system and run the installer. Check the installation by opening Git Bash (or Bash if you're in Mac) and typing code --version Set up User Settings in Visual Studio Code VS Code allows you to customize settings for all projects (User Settings) or for a single project (Workspace settings). To modify default settings select Code | Preferences for the Mac or File | Preferences for Windows and then Settings. You will see 2 files side by side. On the left are the default settings and on the right are the User setting overrides. To change a default setting find the setting on the left and then copy it to the right with your desired setting. For example, if you don't want to see the minimap on the right hand side of the application, you can make the following entry in the file on the right. Notice that options are key : value pairs and that they are commas separated. { \"editor.minimap.enabled\":false } Make \"Git Bash\" the default command line in VS Code terminal by adding the following to your User Settings: \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\"","title":"Setup our Environment"},{"location":"ch1/#install-python","text":"You'll also need to install Python. Python has a number of versions, and Python 3 is the one we will be using. If you are on Windows, you don't have Python. If you're on Mac or Linux, you have Python 2 so you need to add Python 3.","title":"Install Python"},{"location":"ch1/#installing-python-on-windows","text":"Head to the Python downloads page and select the Python 3 installer. Run the installer, and allow it to add Python3 to the Path. This is important, so make sure you pay attention to the option for adding Python3 to your PATH. Once you've installed Python3, open Git Bash and type python --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. If it still doesn't work, probably Python was not added to the PATH. You can Google adding Python to the PATH in Windows.","title":"Installing Python on Windows"},{"location":"ch1/#installing-python-3-on-mac","text":"Macs come with Python2 installed, so you will need to install Python3. Note, DO NOT UNINSTALL OR OTHERWISE REMOVE PYTHON 2 . It will break your operating system. Head to the Python downloads page and select the Python 3 installer. Run the installer. (Don't worry about the PATH, as that's not an issue we deal with in UNIX in the same way.) Once you've installed Python3, open Git Bash and type python3 --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. Also, if you type python --version it will say python 2.7 or something like that. By default on Mac and Linux, Python 2 is installed so the python command will use Python 2. We need to use python3 instead until we setup virtual environments.","title":"Installing Python 3 on Mac"},{"location":"ch1/#set-up-github","text":"Github is awesome! It is a place where you can share code and manage version control. Please do not get confused between Github and Git. Git is a CLI program that manages version control. Every time you \"commit\" changes with git, you create a new version. Behind the scenes, git manages a set of diff files that keep track of the changes that were made to the repository (or collection of code) since the last commit. Github is an online storage service that integrates with git and allows you to push your code to this service and share it both with teams and publicly. I'm not going to go over the Git commands here, but here is a good tutorial .","title":"Set up Github"},{"location":"ch2/","text":"A Taste of Python File Structures Before we get too far into Python, there's one thing you need to understand very well. That is file structures. Your files are stored the computer in a hierarchical structure. A good way to think of it is as a tree starting from the root. / or c:\\ [The root directory. Everything is within this directory] /bin /opt /var /home /user1 /Documents /3010 /code my_function.py hangman.py anotherprogram.py /Articles transitions.docx techofhate.docx /Desktop hangman.py /Videos /Pictures If you look at the directory above, in the root I have the directories bin, opt, var, and home. These directories are at the same level, so they are called siblings. Each of these is a directory within the root, so the root is the parent. In Windows, the root is \"c:\\\" and folders will likely have different names, but the structure is similar. If we look at the \"home\" directory, we have a directory called \"user1\", and within that a few directories, including Documents, Desktop, Videos, and Pictures. Documents contains directories 3010 and Articles. user1 would be called a child of home. 3010 contains the code directory. /code and Articles both contain files. When I want to identify a file, I can identify it with its absolute path. This is the path from the root to the file or folder I'm identifying. So to identify the absolute path of hangman.py, I would need to call it /home/user1/Documents/code/3010/hangman.py. Likewise, to identify transitions.docx, I'd need to call it /home/user1/Documents/Articles/transitions.docx. Using the absolute path in a command or in code will guarantee that the computer can find a file I'm looking for. In commands and programming, it's important to note that unless we use a search function, the computer will not be able to \"search\" for a file. So, if I am working in /home/user1/Desktop and I issue the command python hangman.py the computer will look for hangman.py in my current working directory, and since there is no file called \"hangman.py\" in that working directory, it will be unable to find the file, and the terminal will throw a File Not Found error. What's going on here? Why can't the computer just know what file I'm talking about and run it. After all, it's stored in the memory, right? Yes, but there may be multiple files called \"hangman.py\" in different directories. That is totally legal in terms of storage, and maybe even reasonable practice. After all, you might be working on 100 websites on your local server, and each of them will have an \"index.php\" or \"index.html\" file because the web server looks for that. When entering commands or executing programs, don't want your program to stop and say, \"which hangman.py?\" every time you try to reference a file. To address such possible collisions, computers use something called \"namespaces.\" We'll think about this more later, but for now think of it as the \"working context\" in which your program is running. When you type pwd into your terminal, it tells you what the working context is, or where your terminal is focused. When you issue a command or write a line of code that references a named entity like a variable or a file, it looks for that entity or file in the working context unless you specify otherwise. This means that if you're working in /home/user1/Documents/code/3010 and you enter python hangman.py it looks only in the 3010 directory even though there is a hangman.py in Documents (see above). The thing to understand now is that the working context is where the program looks for named entities. If that entity (a file or variable) doesn't exist in that context (in that directory), then the program won't look elsewhere. It will throw an error. This is true for executing code and for changing directories. Let's say I'm working in the root directory (/). If I want to change directories to code/ I can't simply say cd code because there is no \"code\" directory in the root. Instead, I have to explicitly give the terminal the path to that directory with this command cd home/user1/Documents/code Let's break down how this is interpreted: Computer change the working directory to code which exists inside Documents, which exists inside user1, which exists inside home, The terminal is currently in the root. /home/ exists in the root so it can find that. Then inside /home/, user1/ exists as a directory, so it can find that. Then inside user1/, it can find Documents/ because that exists there. Finally, inside Documents/ it can find code/ I hope I'm not belaboring this too much, but it is crucial, especially as we move into next week to consider scope. You might know exactly where all of the files are located at. That's how a human brain works. We can create nice conceptual maps that help us infer stuff. Computers do not infer. If try to use a named entity (file or variable) in a different context (like calling a python script from another directory), the computer will only look in the local context unless you give it an explicit path to find that entity. It will never infer that you mean the \"hangman.py\" in /home/user1/Documents/code/3010/ and not the \"hangman.py\" in /home/user1/Desktop/ In short, remember, that you must be really explicit when you leave the comforts of a graphical interface like the Finder or File Explorer. Compiled versus Interpreted Languages Compiled? Interpeted? What the What? Generally when we talk about programming, we are talking about a human readable programming language that is easy for a human to understand. However, if we look at what's actually happening on the processor when the commands are being executed, those commands are in binary, or sets of on and off switches. Here is a miniature example of what addition looks like in human readable form and the binary operation that occurs on the processor when a computer calculates it: Human Readable: 12 + 11 = 23 Assembly Code: Binary Operation: 1100 + 1011 = 10111 I'd recommend that you take a moment to search for the binary representation of 23 and you will find that it is 10111. Why does this matter? A processor can't do anything with 23 until it is converted to binary, which are then converted to a series of charged and uncharged states, or a series of ON or OFF switches. It can, however, do operations with these sequences of electrical charges, and a great deal of work is done by the computer to translate between human readable and machine readable forms. For us, this means that every line of code eventually is converted into binary, and so what matters to us is how our code becomes binary. This leads us to compiled versus interpreted languages. The code we write, whether in Python or Java or C++ is written in human readable form. This means that we can understand it, and Python is particularly understandable. But the code must either be compiled or interpreted for it to run. Assembly and Machine Code I'll discuss the difference between compiled and interpreted in a moment, but there is a crucial intermediary between binary or bytecode and our high level programming languages. This intermediary is called assembly. Assembly is low level programming language that is a little bit human readable, but it is representations of specific commands that are executed by the processor. In other words, for a computer to perform an operation like 12 + 11, it would be one line of code in Python, but would require a number of operations on the processor to complete the summation. For instance, the computer needs to load the binary representation of 12 and 11 into registers (tiny bits of memory) on the processor. It needs to perform the operation on the binary values in each of the registers. The computer needs to write the result to another register and then send the decimal value of the result to the screen (which is a couple more steps). Assembly language contains the series of commands that cause the processor to do this. Assembly has a 1 to 1 relationship between command or line of code and operation performed by the processor. The translation between Assembly and the binary that the processor reads is done by the Assembler, which is processor specific (so an x86 and x64 processor would have different assemblers and different Assembly languages). You don't really need to know anything more about Assembly for our purposes except that all of the code we write is probably going to be converted into Assembly. Interpreted and Compiled is largely a difference in when and how that occurs. Compiled Languages Many programming languages are compiled. C++ and Java would be two examples. This means that a programmer writes their program, and then they run it through a compiler, which is a special program that converts the high level language into either an \"executable\" file of Assembly or some other low level language (often .exe in Windows) or directly into binary as is the case on some mobile phones or single board computers. To run the program, the programmer would not run the code written in the high level language (the source code), but instead would run the compiled executable which is the low level translation of the source code. Compiled languages have the advantage of being much faster to execute because at runtime the computer is reading assembly instead of the high level language (this will make more sense when I talk about interpreted languages). They are also slightly more complicated and often a little more difficult to learn. The communities online that surround C++ and Java, two high-level compiled languages, are also a little more grumpy towards newcomers than Python. Interpreted Languages An interpreted language does not need to be compiled. Instead, the programmer writes in the high level language. Then they run the program using the interpreter (in our case the Python program). At runtime, the interpreter reads the source code, converts the source code to lower level code like assembly. That lower level code is then executed by the processor. Notice, compiled languages are turned into executables and when we want to run the program, we don't run the source code, we run the executable which doesn't need to be interpreted into some lower level language at runtime. Interpreted languages on the other hand must be first interpreted into a lower level language and then executed, all at runtime. This can make things really slow. Python has a few tricks to address this deficiency. First, when we execute any Python script, you'll probably see a pycache folder created. In that folder, Python saves an interpreted version of the program in cache. This way, if Python has to run a program again, it will check to see if the program is the same in the cache first and if so, it will not re-interpret the source code, but run the cached version. If there is no cached version or if changes have been made, Python updates the cache and interprets the source code. Developers have also created Cython, which allows the developer to write Python or Cython code but get performance like that of a compiled language. This is a bit beyond the scope of this class, however. Do I need to know all of this? No, not really. I won't be testing you on it, but hopefully it will help you have some context around programming and programming languages. It is definitely going to be important to know the difference between a compiled and interpreted language, but the details of how they work (how programs are compiled or interpreted) is not something you need to know unless you get really serious about programming or get into computer science. Now Python Python refers to two related things. First, Python refers to a programming language that we use to give commands to our computer. This we'll talk at length about throughout the quarter. Second, Python refers to the program that runs on your computer that interprets the code that you write. Dr. Chuck talks about this to some extent in the book. Python the program converts your code into machine language that causes your computer to do things. Just like any program, Python is regularly updated and has minor and major versions. You'll hear almost immediately when looking at Python that there are two major versions: Python2 and Python3. Python 2.7.14 is the most recent version of Python2, and Python 3.8 is the main version of Python3. When we talk about Python version, we're talking about which version of the Python program we're using to interpret our code (we're also talking about our code, but more on that later). This difference is pretty important because as the language evolves over time, some of the features stop working or the syntax, or the way we write code, changes. For example, if we want to print some text to the screen, we use the \"print\" method. In Python 2 the syntax was this: print \"Hello, Snek!\" and for the same functionality in Python 3 you have to write: print(\"Hello, Snek!\") The Python3 interpreter would throw a Syntax error because it no does not recognizes the \"print\" function without parentheses. In short, as the Python program is updated, the way we write Python code has to change to account for the expectations of the interpreter. Does this mean that we have to update all of our code? Not necessarily. It does mean we need to be concerned with which version of Python we're writing for and which is running our code. In this class you will be writing code for a Python3 interpreter or you will be writing Python3 code, but it is good to be familiar with some of the major differences. We'll talk about them as they come up. What is important, though, is that you will need to make sure the Python3 interpreter is installed on your computer. Python Interpreter When we write Python programs, we're usually writing a series of instructions to a file. When we run the program, we tell the Python interpreter to open the file and read and execute the instructions that are contained therein. However, we can also issue commands to the Python interpreter in the same way we can with Bash. The Python CLI can be opened by launching Python without specifying a script. You'll notice before that I just need to type python in Windows and python3 in Mac/Linux because in the latter I have both Python 2 and Python 3 installed. Windows ~$ python Python 3.8.3 (tags/v3.8.3:6f8c832, May 13 2020, 22:37:02) [MSC v.1924 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Mac/Linux ~$ python3 Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> You know that you're in the Python interpreter because of the three greater than ( >>> ) symbols. Once there, we can play around. I recommend you follow along. >>> 2 + 2 4 >>> 2 * 8 16 >>> 2 * (18 + 72) 180 >>> print(\"Hello, world!\") Hello, world! >>> sorted([18, 27, 2, 9, 6]) [2, 6, 9, 18, 27] >>> type(2.7) <class 'float'> >>> type(2) <class 'int'> >>> type('Puppies') <class 'str'> >>> exit() ~$ What you see here is a sequence of commands that I sent to the Python interpreter in the Python programming language. On the prompt lines (preceded by >>> ), I entered my commands. On the following lines is the response of the Python interpreter. Kind of like a conversation: Me: Python, please add 2 and 2. Python: 4 Me: Python, please multiply 2 and 8. Python: 16 Me: Python, please first add 18 and 72, and then multiply that sum by 2. Python: 180 Me: Python, please print to the console the string \"Hello, world!\" Python: Hello, world! Me: Python, please sort the list of numbers 18, 27, 2, 9, and 6 in ascending order. Python: [2, 6, 9, 18, 27] Me: Python, please tell me what type of data 2.7 is. Python: It is a floating point decimal Me: Python, please tell me what type of data 2 is. Python: It is an integer. Me: Python, please tell me what type of data \"Puppies\" is. Python: It is a string Me: Please exit, python Python: exits and returns to Bash prompt If you followed along with the code above, you just coded your first bit of Python. Congratulations! Generally, when we code Python, we write the commands into a text file and then the interpreter executes them when we tell them to do so, but for now, we have cut out the middleman of the file and written our commands directly to the interpreter. It's important to note that the commands are executed in the order we give them. The same is true when we write our code into a file. The interpreter will execute those commands in order. This is the project for next chapter, so I will leave it at that. You've just gotten your first taste of Python. Virtual Environments You might be wondering, how do we keep all the versions of Python sorted out? That's a good question and it extends to all the other libraries that we install. When we use someone else's code, we're taking on dependencies. As they update their code, we might have used an older version, so we need to make sure that we don't accidentally pull in the newer version of their code because it might no longer be compatible with our code. Also, we ourselves could write a program in 2020, but within the next year probably, Python 4 will be released. This means that if we update to Python 4 on our machine, our code will probably break because there will be changes in how Python is written. We need a way to make sure that the same version of the Python interpreter is always used to execute our code. We manage this and all of our dependencies using what's called Virtual Environments. These allow us to bundle up our code and dependencies at a frozen moment in time, and isolate that project's dependencies from other projects and versions of Python. Managing Virtual Environments has become extremely easy. There are a number of tools to do so including pipenv and venv . We'll be using venv here because it is included when you install Python, and where it stores the virtual environment directory is a bit more obvious. To launch it we simply tell Python to execute the venv module. To tell Python to use a module, we need to use the -m flag. $ python3 -m venv -h usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in. optional arguments: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default) --prompt PROMPT Provides an alternative prompt prefix for this environment. Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory. My command was python3 -m venv -h , which basically means \"Python, execute a module called venv and send the -h command to it.\" You can see from the help article that is returned that when you send the -h command to venv, it displays the help article. Now we can look at the general syntax for using venv . First, it's worth noting that I called python3 rather than python . If you're in Windows and only have Python 3 installed, or if you plan to use Python 2 in Mac or Linux, you would call python . You'll see that there is a required, positional argument. We'll learn about arguments when we talk about functions, but for now, think of it as a bit of extra data that will be used by the program. Specifically, in this case it is an ENV_DIR which probably stands for environment directory. This means we need to give the command a name of a directory where the environment data will be stored. This does not mean the name of the directory for the project, but some other name that we can remember is our virtual environment directory. Let me show you the code first, so maybe it's a bit more clear. $ mkdir my_project $ ls my_project $ cd my_project $ ls $ python3 -m venv env $ ls env Ok, first I made a new directory for my project and changed into that directory. I'm using ls to show you what is there. Next, I used venv and created an environment in a directory called env . This env is arbitrary. I choose to call the directory \"env\" because it's known and makes sense. You could call it \"puppy\" or \"an_environment_directory\" but that would make less sense. Also, it's worth noting that the env directory was created by venv. I didn't need to create it first. Finally, you'll never need to manually change anything inside that env folder. Just create it and leave it alone. The package management tools will manage the environment for you. Our next step after creating the resources for our virtual environment is to activate it. Once the environment is activated, whenever we use Python, we will be using the one in this environment. This means that our commands to call Python will always be python rather than python3 because in THIS environment there is only one version of Python installed. So let's activate our environment: Mac/Linux ~/my_project$ source env/bin/activate (env) ~/my_project$ Windows ~/my_project/~ env\\Scripts\\activate (env) ~/my_project$ In both cases we run the activate script to launch our virtual environment. Pay attention to the (env) bit because that tells you your Bash prompt is working in that virtual environment. If this all seems a little confusing now, that's okay. It becomes much more clear with practice. Now that we have our virtual environment created and activated, we can start working. Pip and Pip Freeze When we use Python, we probably will be installing libraries that other people have created. These libraries give us functionality that allows us to avoid having to write a bunch of stuff. We'll talk about this in detail in a few chapters, but for now, consider the work it would require to connect to a website. First, we'd need to use sockets to get our network card to connect to the internet. Then we'd need to build our requests. Then we'd need to listen for a response and so on. Instead, I can just install the requests library that someone else built and maintains, and all that work is done for me. I just use functionality that is build into requests . We do the same thing when we use a web browser, but a web browser has more functionality built in and is used predominately through a GUI. More on this later. For now, we just need to know how to install and manage our virtual environment and the packages that are installed there. To install a package the command is simply pip install {package name} . We'll again talk about this at length in a few chapters. For now, what is most important is the pip freeze command. If we just type that in our Bash terminal the list of packages and their version numbers will be printed to the screen. In general, we will issue the pip freeze command with the output being written to a file called requirements.txt . This will allow us to track the single file in our git repository rather than the entire env/ directory. Conclusion This chapter was a brief introduction to Python and is designed to prepare you for the next chapter. In the next chapter, we'll discuss the first lessons in Python programming. We'll cover the basic syntax and variables.","title":"A Taste of Python"},{"location":"ch2/#a-taste-of-python","text":"","title":"A Taste of Python"},{"location":"ch2/#file-structures","text":"Before we get too far into Python, there's one thing you need to understand very well. That is file structures. Your files are stored the computer in a hierarchical structure. A good way to think of it is as a tree starting from the root. / or c:\\ [The root directory. Everything is within this directory] /bin /opt /var /home /user1 /Documents /3010 /code my_function.py hangman.py anotherprogram.py /Articles transitions.docx techofhate.docx /Desktop hangman.py /Videos /Pictures If you look at the directory above, in the root I have the directories bin, opt, var, and home. These directories are at the same level, so they are called siblings. Each of these is a directory within the root, so the root is the parent. In Windows, the root is \"c:\\\" and folders will likely have different names, but the structure is similar. If we look at the \"home\" directory, we have a directory called \"user1\", and within that a few directories, including Documents, Desktop, Videos, and Pictures. Documents contains directories 3010 and Articles. user1 would be called a child of home. 3010 contains the code directory. /code and Articles both contain files. When I want to identify a file, I can identify it with its absolute path. This is the path from the root to the file or folder I'm identifying. So to identify the absolute path of hangman.py, I would need to call it /home/user1/Documents/code/3010/hangman.py. Likewise, to identify transitions.docx, I'd need to call it /home/user1/Documents/Articles/transitions.docx. Using the absolute path in a command or in code will guarantee that the computer can find a file I'm looking for. In commands and programming, it's important to note that unless we use a search function, the computer will not be able to \"search\" for a file. So, if I am working in /home/user1/Desktop and I issue the command python hangman.py the computer will look for hangman.py in my current working directory, and since there is no file called \"hangman.py\" in that working directory, it will be unable to find the file, and the terminal will throw a File Not Found error. What's going on here? Why can't the computer just know what file I'm talking about and run it. After all, it's stored in the memory, right? Yes, but there may be multiple files called \"hangman.py\" in different directories. That is totally legal in terms of storage, and maybe even reasonable practice. After all, you might be working on 100 websites on your local server, and each of them will have an \"index.php\" or \"index.html\" file because the web server looks for that. When entering commands or executing programs, don't want your program to stop and say, \"which hangman.py?\" every time you try to reference a file. To address such possible collisions, computers use something called \"namespaces.\" We'll think about this more later, but for now think of it as the \"working context\" in which your program is running. When you type pwd into your terminal, it tells you what the working context is, or where your terminal is focused. When you issue a command or write a line of code that references a named entity like a variable or a file, it looks for that entity or file in the working context unless you specify otherwise. This means that if you're working in /home/user1/Documents/code/3010 and you enter python hangman.py it looks only in the 3010 directory even though there is a hangman.py in Documents (see above). The thing to understand now is that the working context is where the program looks for named entities. If that entity (a file or variable) doesn't exist in that context (in that directory), then the program won't look elsewhere. It will throw an error. This is true for executing code and for changing directories. Let's say I'm working in the root directory (/). If I want to change directories to code/ I can't simply say cd code because there is no \"code\" directory in the root. Instead, I have to explicitly give the terminal the path to that directory with this command cd home/user1/Documents/code Let's break down how this is interpreted: Computer change the working directory to code which exists inside Documents, which exists inside user1, which exists inside home, The terminal is currently in the root. /home/ exists in the root so it can find that. Then inside /home/, user1/ exists as a directory, so it can find that. Then inside user1/, it can find Documents/ because that exists there. Finally, inside Documents/ it can find code/ I hope I'm not belaboring this too much, but it is crucial, especially as we move into next week to consider scope. You might know exactly where all of the files are located at. That's how a human brain works. We can create nice conceptual maps that help us infer stuff. Computers do not infer. If try to use a named entity (file or variable) in a different context (like calling a python script from another directory), the computer will only look in the local context unless you give it an explicit path to find that entity. It will never infer that you mean the \"hangman.py\" in /home/user1/Documents/code/3010/ and not the \"hangman.py\" in /home/user1/Desktop/ In short, remember, that you must be really explicit when you leave the comforts of a graphical interface like the Finder or File Explorer.","title":"File Structures"},{"location":"ch2/#compiled-versus-interpreted-languages","text":"","title":"Compiled versus Interpreted Languages"},{"location":"ch2/#compiled-interpeted-what-the-what","text":"Generally when we talk about programming, we are talking about a human readable programming language that is easy for a human to understand. However, if we look at what's actually happening on the processor when the commands are being executed, those commands are in binary, or sets of on and off switches. Here is a miniature example of what addition looks like in human readable form and the binary operation that occurs on the processor when a computer calculates it: Human Readable: 12 + 11 = 23 Assembly Code: Binary Operation: 1100 + 1011 = 10111 I'd recommend that you take a moment to search for the binary representation of 23 and you will find that it is 10111. Why does this matter? A processor can't do anything with 23 until it is converted to binary, which are then converted to a series of charged and uncharged states, or a series of ON or OFF switches. It can, however, do operations with these sequences of electrical charges, and a great deal of work is done by the computer to translate between human readable and machine readable forms. For us, this means that every line of code eventually is converted into binary, and so what matters to us is how our code becomes binary. This leads us to compiled versus interpreted languages. The code we write, whether in Python or Java or C++ is written in human readable form. This means that we can understand it, and Python is particularly understandable. But the code must either be compiled or interpreted for it to run.","title":"Compiled? Interpeted? What the What?"},{"location":"ch2/#assembly-and-machine-code","text":"I'll discuss the difference between compiled and interpreted in a moment, but there is a crucial intermediary between binary or bytecode and our high level programming languages. This intermediary is called assembly. Assembly is low level programming language that is a little bit human readable, but it is representations of specific commands that are executed by the processor. In other words, for a computer to perform an operation like 12 + 11, it would be one line of code in Python, but would require a number of operations on the processor to complete the summation. For instance, the computer needs to load the binary representation of 12 and 11 into registers (tiny bits of memory) on the processor. It needs to perform the operation on the binary values in each of the registers. The computer needs to write the result to another register and then send the decimal value of the result to the screen (which is a couple more steps). Assembly language contains the series of commands that cause the processor to do this. Assembly has a 1 to 1 relationship between command or line of code and operation performed by the processor. The translation between Assembly and the binary that the processor reads is done by the Assembler, which is processor specific (so an x86 and x64 processor would have different assemblers and different Assembly languages). You don't really need to know anything more about Assembly for our purposes except that all of the code we write is probably going to be converted into Assembly. Interpreted and Compiled is largely a difference in when and how that occurs.","title":"Assembly and Machine Code"},{"location":"ch2/#compiled-languages","text":"Many programming languages are compiled. C++ and Java would be two examples. This means that a programmer writes their program, and then they run it through a compiler, which is a special program that converts the high level language into either an \"executable\" file of Assembly or some other low level language (often .exe in Windows) or directly into binary as is the case on some mobile phones or single board computers. To run the program, the programmer would not run the code written in the high level language (the source code), but instead would run the compiled executable which is the low level translation of the source code. Compiled languages have the advantage of being much faster to execute because at runtime the computer is reading assembly instead of the high level language (this will make more sense when I talk about interpreted languages). They are also slightly more complicated and often a little more difficult to learn. The communities online that surround C++ and Java, two high-level compiled languages, are also a little more grumpy towards newcomers than Python.","title":"Compiled Languages"},{"location":"ch2/#interpreted-languages","text":"An interpreted language does not need to be compiled. Instead, the programmer writes in the high level language. Then they run the program using the interpreter (in our case the Python program). At runtime, the interpreter reads the source code, converts the source code to lower level code like assembly. That lower level code is then executed by the processor. Notice, compiled languages are turned into executables and when we want to run the program, we don't run the source code, we run the executable which doesn't need to be interpreted into some lower level language at runtime. Interpreted languages on the other hand must be first interpreted into a lower level language and then executed, all at runtime. This can make things really slow. Python has a few tricks to address this deficiency. First, when we execute any Python script, you'll probably see a pycache folder created. In that folder, Python saves an interpreted version of the program in cache. This way, if Python has to run a program again, it will check to see if the program is the same in the cache first and if so, it will not re-interpret the source code, but run the cached version. If there is no cached version or if changes have been made, Python updates the cache and interprets the source code. Developers have also created Cython, which allows the developer to write Python or Cython code but get performance like that of a compiled language. This is a bit beyond the scope of this class, however. Do I need to know all of this? No, not really. I won't be testing you on it, but hopefully it will help you have some context around programming and programming languages. It is definitely going to be important to know the difference between a compiled and interpreted language, but the details of how they work (how programs are compiled or interpreted) is not something you need to know unless you get really serious about programming or get into computer science.","title":"Interpreted Languages"},{"location":"ch2/#now-python","text":"Python refers to two related things. First, Python refers to a programming language that we use to give commands to our computer. This we'll talk at length about throughout the quarter. Second, Python refers to the program that runs on your computer that interprets the code that you write. Dr. Chuck talks about this to some extent in the book. Python the program converts your code into machine language that causes your computer to do things. Just like any program, Python is regularly updated and has minor and major versions. You'll hear almost immediately when looking at Python that there are two major versions: Python2 and Python3. Python 2.7.14 is the most recent version of Python2, and Python 3.8 is the main version of Python3. When we talk about Python version, we're talking about which version of the Python program we're using to interpret our code (we're also talking about our code, but more on that later). This difference is pretty important because as the language evolves over time, some of the features stop working or the syntax, or the way we write code, changes. For example, if we want to print some text to the screen, we use the \"print\" method. In Python 2 the syntax was this: print \"Hello, Snek!\" and for the same functionality in Python 3 you have to write: print(\"Hello, Snek!\") The Python3 interpreter would throw a Syntax error because it no does not recognizes the \"print\" function without parentheses. In short, as the Python program is updated, the way we write Python code has to change to account for the expectations of the interpreter. Does this mean that we have to update all of our code? Not necessarily. It does mean we need to be concerned with which version of Python we're writing for and which is running our code. In this class you will be writing code for a Python3 interpreter or you will be writing Python3 code, but it is good to be familiar with some of the major differences. We'll talk about them as they come up. What is important, though, is that you will need to make sure the Python3 interpreter is installed on your computer.","title":"Now Python"},{"location":"ch2/#python-interpreter","text":"When we write Python programs, we're usually writing a series of instructions to a file. When we run the program, we tell the Python interpreter to open the file and read and execute the instructions that are contained therein. However, we can also issue commands to the Python interpreter in the same way we can with Bash. The Python CLI can be opened by launching Python without specifying a script. You'll notice before that I just need to type python in Windows and python3 in Mac/Linux because in the latter I have both Python 2 and Python 3 installed.","title":"Python Interpreter"},{"location":"ch2/#windows","text":"~$ python Python 3.8.3 (tags/v3.8.3:6f8c832, May 13 2020, 22:37:02) [MSC v.1924 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>>","title":"Windows"},{"location":"ch2/#maclinux","text":"~$ python3 Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> You know that you're in the Python interpreter because of the three greater than ( >>> ) symbols. Once there, we can play around. I recommend you follow along. >>> 2 + 2 4 >>> 2 * 8 16 >>> 2 * (18 + 72) 180 >>> print(\"Hello, world!\") Hello, world! >>> sorted([18, 27, 2, 9, 6]) [2, 6, 9, 18, 27] >>> type(2.7) <class 'float'> >>> type(2) <class 'int'> >>> type('Puppies') <class 'str'> >>> exit() ~$ What you see here is a sequence of commands that I sent to the Python interpreter in the Python programming language. On the prompt lines (preceded by >>> ), I entered my commands. On the following lines is the response of the Python interpreter. Kind of like a conversation: Me: Python, please add 2 and 2. Python: 4 Me: Python, please multiply 2 and 8. Python: 16 Me: Python, please first add 18 and 72, and then multiply that sum by 2. Python: 180 Me: Python, please print to the console the string \"Hello, world!\" Python: Hello, world! Me: Python, please sort the list of numbers 18, 27, 2, 9, and 6 in ascending order. Python: [2, 6, 9, 18, 27] Me: Python, please tell me what type of data 2.7 is. Python: It is a floating point decimal Me: Python, please tell me what type of data 2 is. Python: It is an integer. Me: Python, please tell me what type of data \"Puppies\" is. Python: It is a string Me: Please exit, python Python: exits and returns to Bash prompt If you followed along with the code above, you just coded your first bit of Python. Congratulations! Generally, when we code Python, we write the commands into a text file and then the interpreter executes them when we tell them to do so, but for now, we have cut out the middleman of the file and written our commands directly to the interpreter. It's important to note that the commands are executed in the order we give them. The same is true when we write our code into a file. The interpreter will execute those commands in order. This is the project for next chapter, so I will leave it at that. You've just gotten your first taste of Python.","title":"Mac/Linux"},{"location":"ch2/#virtual-environments","text":"You might be wondering, how do we keep all the versions of Python sorted out? That's a good question and it extends to all the other libraries that we install. When we use someone else's code, we're taking on dependencies. As they update their code, we might have used an older version, so we need to make sure that we don't accidentally pull in the newer version of their code because it might no longer be compatible with our code. Also, we ourselves could write a program in 2020, but within the next year probably, Python 4 will be released. This means that if we update to Python 4 on our machine, our code will probably break because there will be changes in how Python is written. We need a way to make sure that the same version of the Python interpreter is always used to execute our code. We manage this and all of our dependencies using what's called Virtual Environments. These allow us to bundle up our code and dependencies at a frozen moment in time, and isolate that project's dependencies from other projects and versions of Python. Managing Virtual Environments has become extremely easy. There are a number of tools to do so including pipenv and venv . We'll be using venv here because it is included when you install Python, and where it stores the virtual environment directory is a bit more obvious. To launch it we simply tell Python to execute the venv module. To tell Python to use a module, we need to use the -m flag. $ python3 -m venv -h usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in. optional arguments: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default) --prompt PROMPT Provides an alternative prompt prefix for this environment. Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory. My command was python3 -m venv -h , which basically means \"Python, execute a module called venv and send the -h command to it.\" You can see from the help article that is returned that when you send the -h command to venv, it displays the help article. Now we can look at the general syntax for using venv . First, it's worth noting that I called python3 rather than python . If you're in Windows and only have Python 3 installed, or if you plan to use Python 2 in Mac or Linux, you would call python . You'll see that there is a required, positional argument. We'll learn about arguments when we talk about functions, but for now, think of it as a bit of extra data that will be used by the program. Specifically, in this case it is an ENV_DIR which probably stands for environment directory. This means we need to give the command a name of a directory where the environment data will be stored. This does not mean the name of the directory for the project, but some other name that we can remember is our virtual environment directory. Let me show you the code first, so maybe it's a bit more clear. $ mkdir my_project $ ls my_project $ cd my_project $ ls $ python3 -m venv env $ ls env Ok, first I made a new directory for my project and changed into that directory. I'm using ls to show you what is there. Next, I used venv and created an environment in a directory called env . This env is arbitrary. I choose to call the directory \"env\" because it's known and makes sense. You could call it \"puppy\" or \"an_environment_directory\" but that would make less sense. Also, it's worth noting that the env directory was created by venv. I didn't need to create it first. Finally, you'll never need to manually change anything inside that env folder. Just create it and leave it alone. The package management tools will manage the environment for you. Our next step after creating the resources for our virtual environment is to activate it. Once the environment is activated, whenever we use Python, we will be using the one in this environment. This means that our commands to call Python will always be python rather than python3 because in THIS environment there is only one version of Python installed. So let's activate our environment:","title":"Virtual Environments"},{"location":"ch2/#maclinux_1","text":"~/my_project$ source env/bin/activate (env) ~/my_project$","title":"Mac/Linux"},{"location":"ch2/#windows_1","text":"~/my_project/~ env\\Scripts\\activate (env) ~/my_project$ In both cases we run the activate script to launch our virtual environment. Pay attention to the (env) bit because that tells you your Bash prompt is working in that virtual environment. If this all seems a little confusing now, that's okay. It becomes much more clear with practice. Now that we have our virtual environment created and activated, we can start working.","title":"Windows"},{"location":"ch2/#pip-and-pip-freeze","text":"When we use Python, we probably will be installing libraries that other people have created. These libraries give us functionality that allows us to avoid having to write a bunch of stuff. We'll talk about this in detail in a few chapters, but for now, consider the work it would require to connect to a website. First, we'd need to use sockets to get our network card to connect to the internet. Then we'd need to build our requests. Then we'd need to listen for a response and so on. Instead, I can just install the requests library that someone else built and maintains, and all that work is done for me. I just use functionality that is build into requests . We do the same thing when we use a web browser, but a web browser has more functionality built in and is used predominately through a GUI. More on this later. For now, we just need to know how to install and manage our virtual environment and the packages that are installed there. To install a package the command is simply pip install {package name} . We'll again talk about this at length in a few chapters. For now, what is most important is the pip freeze command. If we just type that in our Bash terminal the list of packages and their version numbers will be printed to the screen. In general, we will issue the pip freeze command with the output being written to a file called requirements.txt . This will allow us to track the single file in our git repository rather than the entire env/ directory.","title":"Pip and Pip Freeze"},{"location":"ch2/#conclusion","text":"This chapter was a brief introduction to Python and is designed to prepare you for the next chapter. In the next chapter, we'll discuss the first lessons in Python programming. We'll cover the basic syntax and variables.","title":"Conclusion"},{"location":"ch3/","text":"Encoding Identity","title":"Encoding Identity"},{"location":"ch3/#encoding-identity","text":"","title":"Encoding Identity"},{"location":"ch4/","text":"","title":"Ch4"}]}