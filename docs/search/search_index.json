{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python for Humanists Digital Humanists are individuals with technical skills and critical awareness. By combining the critical thinking and social consciousness rooted in social theory and humanist thougth with the technical know-how rooted in computer science and software development, digital humanists can help make our technologically saturated society more just, humane, and good. This text is designed to help digital humanists learn the Python programming language from a humanist perspective. Along with learning the syntax and design patterns, readers will be encouraged to consider what the software they develop does to the human society that it serves. This is very much a survey text, and I would strongly encourage readers to also visit Python for Everybody For the exercises in this text, starter-code is available. Please feel free to clone it here . About the Author I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids. Acknowledgements This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License .","title":"Home"},{"location":"#python-for-humanists","text":"Digital Humanists are individuals with technical skills and critical awareness. By combining the critical thinking and social consciousness rooted in social theory and humanist thougth with the technical know-how rooted in computer science and software development, digital humanists can help make our technologically saturated society more just, humane, and good. This text is designed to help digital humanists learn the Python programming language from a humanist perspective. Along with learning the syntax and design patterns, readers will be encouraged to consider what the software they develop does to the human society that it serves. This is very much a survey text, and I would strongly encourage readers to also visit Python for Everybody For the exercises in this text, starter-code is available. Please feel free to clone it here .","title":"Python for Humanists"},{"location":"#about-the-author","text":"I direct the Web, Application, and Technology Studies program at Seattle University\u2019s School of New and Continuing Studies. My research and pedagogy are deeply invested learning and its application to future contexts. My MA and PhD research focuses on how students acquire and deploy rhetorical strategies and skills within the social, material, and technological landscapes in which they work. I teach in the areas of social theory, social science research, writing, web development, and Python. At heart, I am a maker and have devoted a great deal of energy to creating projects and programs to address problems I see in the world around me. This lead me to develop a transition workshop for service members, which I taught for four years at Joint Base Lewis-McChord. I also lead a team developing Cluster\u2014a suite of tools that work like a personal writing trainer. In the summer, I teach a Python camp for underrepresented kids.","title":"About the Author"},{"location":"#acknowledgements","text":"This book is written by Dylan Medina and is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License .","title":"Acknowledgements"},{"location":"ch1/","text":"Computers and You Welcome to Python for Humanists. This first chapter will introduce you to basic architecture of computers and the basics of setting up your development environment. By the end of this chapter, you'll have exercises that will ask you to walk through getting your development environment set up and ready to go. Computer Architecture If you were to open up your computer, and I do recommend that you do so someday, you'll see a bunch of silicone chips and wires and tower looking things. Whenever we use our computer, regardless of how fancy and complex the output on our screen might be or the calculations that the machine can accomplish, all that is happening inside the computer is a bunch of electricity flowing across the metal in particular patterns that are meaningful and useful. The various components work together to create patterns that achieve whatever commands we or some developer have provided to the machine. To understand how Python is working and to understand Concepts in Computing, it is useful to know the anatomy of a computer. There are very many types of computers from the system in your car to your smartphone to your desktop to your digital watch. In a nutshell, computers are machines that take some sort of input, do some calculations on those input, and finally return some sort of output. A simple calculator, for instance, takes numbers and operators as inputs, processes those inputs by performing the input operators, and finally returns the result of that operation as an output. More complicated computers, like a smartphone, just take different types of inputs and perform more complicated processes. Since all computers fundamentally do the same thing in varying degrees of complexities, they all have a basic set of components: Input and Output devices Processing Device Memory (Optional) Storage Let's start with the Input and Output (I/O) devices. I/O devices are the features that allow the computer to interact with the world. Input devices include keyboards, mice, touch screens, and so on. Each input device takes a specific type of data. Output devices include printers, monitors, speakers, and so on. Each output device returns a specific type of data. Computers might have various I/O devices, sometimes built in, sometimes peripheral, but they all will have some sort of I/O otherwise they won't be able to take data and return results. Memory is the next step. Memory is the space where data is stored when it is not immediately being processed. For instance, when you work in a Word document, your document is read from the long term storage to the memory. As you make changes, those changes are written to the memory, and when you \"Save\" the version of the document is written back to the long term storage medium. Memory is volatile, which means that when the computer shuts down or loses power, the memory is erased. The solution to this is long term storage, which will be covered below. If you've ever had the experience of working on a file and losing unsaved changes, it happened because those changes had not yet been written to long term storage. Processing devices are the processor. Processors come in various flavors and functionality, but they are responsible for managing all of the components of the computer (the memory and the I/O devices), and for running calculations. Every operation in a computer is the result of calculations done in binary. The processor is doing that constantly, often several calculations at once if you have a processor capable of multi-threading. (Optional) Most computers also have some form of long term storage. This might be a hard disk drive, a solid state drive, or a memory card. These are physical media of various sorts that can have data written to them in a permanent or semi-permanent state. In the case of hard disk drives, data is stored as charges written to magnetic platters. On larger computers like laptops and desktops, these components are usually connected through a motherboard that helps orchestrate the processes. When we begin programming, it is useful to consider what part of the physical machine is performing a particular thing because it perhaps will help you visualize and make sense of what's going on. This is especially true when we get to variables and files. Interacting with variables means we are interacting with memory and interacting with files we are interacting usually with long term storage. Beyond the Graphical User Interface Most of the time when you interact with a computer, you probably are doing so through what is called a Graphical User Interface (GUI). When you open your web browser, for instance, you have a window with URL bar and menus and a main pane where the website code is rendered for your enjoyment. Likewise, when you search for files, you are probably using File Explorer or Finder, both of which are GUIs for interacting with the file system. GUIs allow you to use your mouse and keyboard to interact with the computer through visual icons and fields. I cannot overstate the importance of GUIs to the proliferation of computers. Without a GUI, you would either have to use a command line interface or punch cards to use a computer. GUI's allow non-experts to gain access without facing the steep learning curve of learning commands or code or punch card patterns. Instead, you can issue commands to the computer through an intuitive interface of icons, labelled fields, and so on. That being said, GUIs limit the efficiency at which you can work and frequently limit your ability to issue commands to the computer. This means that if you want to move from being a user towards being a maker or developer (one who uses the computer as is, to one who might explore what the computer can be made to do) is to become familiar with what is called a Command Line Interface (CLI). There are numerous CLIs ranging from DOS Prompt, Windows Command LIne, Powershell, Bash, etc. Even Python has a CLI, which allows you to issue Python commands directly to the Python interpreter (this will make more sense next chapter). CLIs allow the user to issue text based commands to the system (whichever system reads and interprets the commands). So, just as I could use a GUI to view, create, open, move, and delete files and folders in the above example by clicking on buttons and icons in the GUI to issue commands to the Operating System, so too can I use the CLI to view, create, open, move, and delete files and folders by entering commands as text via the keyboard into the CLI. The particular CLI we will be using in this class is BASH . We are learning Bash instead of Command Prompt or Powershell because it is a very powerful \"shell\" that is built into all unix operating systems (Mac and Linux); however, at the time of writing, Mac is beginning to use Zsh instead, but the commands are largely the same so no worries. It is the standard CLI that you will encounter on nearly all web servers and will give you the most bang for your buck. Plus, it can be installed on Windows, and many bash commands are the saem in Powershell. Learning a CLI involves learning a set of commands (or \"magic words\") that are available. You won't need to memorize them all, but by spending time using the CLI, you will gradually pick them up. Why would we take the time to learn a CLI when you're already proficient at using a GUI? Great question! GUIs are limited to the set of actions that the GUI designer thinks that most users will need. The actions are usually triggered by a mouse click, but advanced users will likely learn Hotkeys or keyboard shortcuts to make their work faster. However, the program often has a number of other commands or actions that are difficult to access via the GUI. Using a CLI often gives you more power and control over what the program is doing. GUIs involve using a mouse or tabbing through buttons with the keyboard. This means that they are much slower to do complicated tasks. Once you become familiar with a CLI, you will be much faster at doing the same kinds of tasks, and many tasks are less complicated using a CLI than they are using a graphical interface. Let's say you decide to set up an application on a web server. First, that server exists in some server farm somewhere and the company that provides it allows you to access it remotely over a secure connection. That web server probably will not have a Desktop environment (a GUI for an operating system). Instead, it will have a CLI environment, and you will access it through a secure shell (ssh). Let's ignore the fact that the server will require that you use the CLI and think about how we might connect to that server remotely. To connect to that server, you set up an ssh connection. There are GUI programs that allow you to do this, like Putty, for instance. To do this, you must first install the program, then set up a connection through the form that the GUI provides and finally click the connect button. In Bash, however, all you have to do is type ssh username@server.com with any additional settings that might be necessary (e.g. you might need to type ssh -p 5257 username@server.com if you want to specify a particular port to connect to) and then hit enter. Likewise, many coding related applications have poor GUIs. Python's package manager (pip) for example only works in CLI. One word of caution: CLIs give you greater power and control over the machine, but that means you can mess things up pretty severely. I recommend knowing what a command will do before you execute it. This is particularly important if you are reading advice from StackOverflow or some other online forum that answers questions. Likewise, if you are not already practicing good backup habits, not would be an ideal time to start because it is possible to break things or lose data (e.g. rm -rf /home/ would delete all files installed by users without asking if you're sure). Installing Bash So if you're a Mac or Linux User, you can skip this section. You already have Bash or Zsh installed on your computer. In Mac, you'll need to locate the application called Terminal. In Linux, usually the hotkeys to open a terminal is CTRL+ALT+T. If you're a Windows 10 user, you have two options. You can set up Windows Subsystem Linux. Since developers frequently prefer developing in a Unix environment like Mac or Linux (for many reasons which I won't go into here), Windows has built a subsystem that allows you to use Linux within your Windows operating system. I use this personally when I'm using my Windows computer, but it is a little bit fiddly and permissions can be weird. The option I will walk you through here is using Git Bash. Git is a version control program that we'll talk about in a little bit, but they have created a version of Bash that works on Windows. It's lovely. head over to Git's download page and select the appropriate version of Git Bash to download. Run the installer that you just downloaded. I use the default settings, but if you want to customize the installation, feel free. Open Git Bash and a terminal will open up. Hooray. A taste of Bash If you want a great tutorial on how to use Bash and even write scripts in the Bash scripting language, check out Bash Academy for a really detailed tutorial of Bash. I strongly recommend this because knowing your way around a CLI will make the work of this program much easier. I will give you a quick overview here of Bash. I'd encourage you to follow along on your computer. When you open a Bash terminal, you will see a window with a black background and some text. Mine lookes like this: user1@DESKTOP-61VJ97U:~$ _ This is the prompt, and you'll see a cursor blinking right after the dollar sign. You can type commands here. Throughout this program, I will share code snippets and when I do, I will simply start with either ~$ or (env) ~$ So if you are following along and it looks slightly different, just know I'm cutting out the username and host for brevity sake. The first thing to learn about the CLI is how to navigate. Wherever the prompt is \"located\" in your file tree is where you will execute your commands. For example, if I am in a directory called \"projects\" and my prompt is set in that directory, then when I create a file it will be created within that directory. The first command we need to learn is pwd which stands for \"print working directory.\" The working directory is where my terminal is currently working. For example, when I open a terminal, it automatically opens to the home directory, represented by the tilda (~). So when I issue the command: ~$ pwd /home/user1 This means that my current working directory is /home/user1 and any command I issue, unless I specify otherwise, will be executed in that directory. Next, I will use the ls command to show you what directories reside within my home directory: ~$ ls Books Projects dylanmedina experiments Within my home directory I have Books, Projects, dylanmedina, and experiments. These are all directories that I can navigate into. These first two commands are crucial because they give me the location and context in which my CLI is operating. Now, let's say we're starting a new project, like this lesson. I might make a new directory for that project. To do so, I need to create a new directory and give it a name. The command is mkdir for \"make directory.\" You follow that by the name of the directory. One word on names: spaces don't work because each word of a command is separated by a space. So if I wanted to create a directory called Python for Humanists, and I issued the command ~$ mkdir Python for Humanists it would create three directories. One workaround is surround the name with quotation marks, but it's easier to just use names that don't have spaces. So let's go: ~$ mkdir pythonHumanist ~$ ls Books Projects dylanmedina experiments pythonHumanist You'll see, I created a directory called pythonHumanist and then I listed out the contents of my home directory, and you can see that my command worked. Now let's say we want to create our first Python script inside of the pythonHumanist directory. First, we can move into that directory and then we can create the file. To change directories we type cd followed by the absolute or relative path of the directory we want to visit. ~$ cd pythonHumanist ~/pythonHumanist$ You'll notice that the tilda is now followed by the directory name in my prompt showing me conveniently where I am (my working directory). Next, we create a file in that directory called hello.py and add some text to that file. We can do this in one step, but I'm doing two so you can see two different commands: ~/pythonHumanist$ touch hello.py ~/pythonHumanist$ ls hello.py ~/pythonHumanist$ echo \"print('Hello World')\" >> hello.py A few notes. First, we used the touch command to create a file. The general syntax is touch {filename} where {filename} is replaced by the name of the file you want to create. If you want to create multiple files, you can list them with a space separating each file name. Again, the same \"no spaces\" rule applies. Second, I listed out the contents of the directory to show that the file was created. If you opened the file at this point, it will be empty. Finally, I used the echo command followed by two >> greater than signs. The echo command prints some text. The greater than symbols writes the output of the echo command to the file. If I use 2 greater than signs, the output is appended to the end of the file. If I use one greater than sign, the file is overwritten with the new content. After this command, you'll see that the file hello.py contains the text print('Hello World') , which is Python code. More on that later. You can send the output of commands to other commands in Bash, and that ends up being a powerful feature. Next, let's say I want to copy files. This is really easy in Bash. The command is cp for copy and the syntax is cp {source} {destination} ~/pythonHumanist$ cp hello.py hello2.py ~/pythonHumanist$ ls hello.py hello2.py If you want to copy directories, you do so with the -r flag. Many commands have flags. These flags change the behavior of the command. In this case, I mean \"copy recursively\" or go through the contained directories and files and copy those as well as the outer directory that I named. The final command I want to cover here is rm which deletes files. BE CAREFUL WITH THIS COMMAND BECAUSE THERE WILL NOT BE A PROMPT ASKING IF YOU'RE SURE YOU WANT TO DELETE A FILE ~/pythonHumanist$ rm hello.py ~/pythonHumanist$ cd .. ~$ rm -r pythonHumanist First, I remove the file hello.py using the rm command. Then I change directories up one level ( .. signifies up one level) so I change the working directory to home. Then I remove the pythonHumanist directory using the -r flag. Again, many commands in Bash have flags that you can add that change the behavior. -r means recursive and it is what we use to remove directories. It means go into the directory, recursively delete all the files and then remove the directory. So if I had wanted to, I could have skipped removing the hello.py file first and just removed the directory and the file would have been deleted, too. There are many other commands that you will want to use, but I just wanted to give you a brief overview. We will encounter others that you'll have to learn as you go. If you have the time and energy, I strongly suggest spending a few hours and going further into Bash, as some of the concepts will make learning Python a bit easier. Setup our Environment We've done a bit of set up already and introduced you to the CLI. Now we need to finish getting things set up so that we can dive into Python next chapter. There are a few things we'll need. First, we need to get a good text editor. Python, as all code, is a bunch of human readable text that some program on the computer can understand and translate into the appropriate machine language that the computer can understand. There are tons of text editors out there and technically we could use Notepad for our code, but we want to use something with a few more features. KEY: do not use a word processor like Word to write code. When you use a word processor it adds extra markup to your file to display the formatting of the text and this will make your code non-functional. We will be using Visual Studio Code, but Atom is another good free option. I like Visual Studio Code because it gives you a file explorer and a terminal all built into one. Head over to the Visual Studio Code download page Download the installer for your operating system and run the installer. Check the installation by opening Git Bash (or Bash if you're in Mac) and typing code --version Set up User Settings in Visual Studio Code VS Code allows you to customize settings for all projects (User Settings) or for a single project (Workspace settings). To modify default settings select Code | Preferences for the Mac or File | Preferences for Windows and then Settings. You will see 2 files side by side. On the left are the default settings and on the right are the User setting overrides. To change a default setting find the setting on the left and then copy it to the right with your desired setting. For example, if you don't want to see the minimap on the right hand side of the application, you can make the following entry in the file on the right. Notice that options are key : value pairs and that they are commas separated. { \"editor.minimap.enabled\":false } Make \"Git Bash\" the default command line in VS Code terminal by adding the following to your User Settings: \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\" Install Python You'll also need to install Python. Python has a number of versions, and Python 3 is the one we will be using. If you are on Windows, you don't have Python. If you're on Mac or Linux, you have Python 2 so you need to add Python 3. Installing Python on Windows Head to the Python downloads page and select the Python 3 installer. Run the installer, and allow it to add Python3 to the Path. This is important, so make sure you pay attention to the option for adding Python3 to your PATH. Once you've installed Python3, open Git Bash and type python --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. If it still doesn't work, probably Python was not added to the PATH. You can Google adding Python to the PATH in Windows. Installing Python 3 on Mac Macs come with Python2 installed, so you will need to install Python3. Note, DO NOT UNINSTALL OR OTHERWISE REMOVE PYTHON 2 . It will break your operating system. Head to the Python downloads page and select the Python 3 installer. Run the installer. (Don't worry about the PATH, as that's not an issue we deal with in UNIX in the same way.) Once you've installed Python3, open Git Bash and type python3 --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. Also, if you type python --version it will say python 2.7 or something like that. By default on Mac and Linux, Python 2 is installed so the python command will use Python 2. We need to use python3 instead until we setup virtual environments. Set up Github Github is awesome! It is a place where you can share code and manage version control. Please do not get confused between Github and Git. Git is a CLI program that manages version control. Every time you \"commit\" changes with git, you create a new version. Behind the scenes, git manages a set of diff files that keep track of the changes that were made to the repository (or collection of code) since the last commit. Github is an online storage service that integrates with git and allows you to push your code to this service and share it both with teams and publicly. I'm not going to go over the Git commands here, but here is a good tutorial .","title":"Computers and You"},{"location":"ch1/#computers-and-you","text":"Welcome to Python for Humanists. This first chapter will introduce you to basic architecture of computers and the basics of setting up your development environment. By the end of this chapter, you'll have exercises that will ask you to walk through getting your development environment set up and ready to go.","title":"Computers and You"},{"location":"ch1/#computer-architecture","text":"If you were to open up your computer, and I do recommend that you do so someday, you'll see a bunch of silicone chips and wires and tower looking things. Whenever we use our computer, regardless of how fancy and complex the output on our screen might be or the calculations that the machine can accomplish, all that is happening inside the computer is a bunch of electricity flowing across the metal in particular patterns that are meaningful and useful. The various components work together to create patterns that achieve whatever commands we or some developer have provided to the machine. To understand how Python is working and to understand Concepts in Computing, it is useful to know the anatomy of a computer. There are very many types of computers from the system in your car to your smartphone to your desktop to your digital watch. In a nutshell, computers are machines that take some sort of input, do some calculations on those input, and finally return some sort of output. A simple calculator, for instance, takes numbers and operators as inputs, processes those inputs by performing the input operators, and finally returns the result of that operation as an output. More complicated computers, like a smartphone, just take different types of inputs and perform more complicated processes. Since all computers fundamentally do the same thing in varying degrees of complexities, they all have a basic set of components: Input and Output devices Processing Device Memory (Optional) Storage Let's start with the Input and Output (I/O) devices. I/O devices are the features that allow the computer to interact with the world. Input devices include keyboards, mice, touch screens, and so on. Each input device takes a specific type of data. Output devices include printers, monitors, speakers, and so on. Each output device returns a specific type of data. Computers might have various I/O devices, sometimes built in, sometimes peripheral, but they all will have some sort of I/O otherwise they won't be able to take data and return results. Memory is the next step. Memory is the space where data is stored when it is not immediately being processed. For instance, when you work in a Word document, your document is read from the long term storage to the memory. As you make changes, those changes are written to the memory, and when you \"Save\" the version of the document is written back to the long term storage medium. Memory is volatile, which means that when the computer shuts down or loses power, the memory is erased. The solution to this is long term storage, which will be covered below. If you've ever had the experience of working on a file and losing unsaved changes, it happened because those changes had not yet been written to long term storage. Processing devices are the processor. Processors come in various flavors and functionality, but they are responsible for managing all of the components of the computer (the memory and the I/O devices), and for running calculations. Every operation in a computer is the result of calculations done in binary. The processor is doing that constantly, often several calculations at once if you have a processor capable of multi-threading. (Optional) Most computers also have some form of long term storage. This might be a hard disk drive, a solid state drive, or a memory card. These are physical media of various sorts that can have data written to them in a permanent or semi-permanent state. In the case of hard disk drives, data is stored as charges written to magnetic platters. On larger computers like laptops and desktops, these components are usually connected through a motherboard that helps orchestrate the processes. When we begin programming, it is useful to consider what part of the physical machine is performing a particular thing because it perhaps will help you visualize and make sense of what's going on. This is especially true when we get to variables and files. Interacting with variables means we are interacting with memory and interacting with files we are interacting usually with long term storage.","title":"Computer Architecture"},{"location":"ch1/#beyond-the-graphical-user-interface","text":"Most of the time when you interact with a computer, you probably are doing so through what is called a Graphical User Interface (GUI). When you open your web browser, for instance, you have a window with URL bar and menus and a main pane where the website code is rendered for your enjoyment. Likewise, when you search for files, you are probably using File Explorer or Finder, both of which are GUIs for interacting with the file system. GUIs allow you to use your mouse and keyboard to interact with the computer through visual icons and fields. I cannot overstate the importance of GUIs to the proliferation of computers. Without a GUI, you would either have to use a command line interface or punch cards to use a computer. GUI's allow non-experts to gain access without facing the steep learning curve of learning commands or code or punch card patterns. Instead, you can issue commands to the computer through an intuitive interface of icons, labelled fields, and so on. That being said, GUIs limit the efficiency at which you can work and frequently limit your ability to issue commands to the computer. This means that if you want to move from being a user towards being a maker or developer (one who uses the computer as is, to one who might explore what the computer can be made to do) is to become familiar with what is called a Command Line Interface (CLI). There are numerous CLIs ranging from DOS Prompt, Windows Command LIne, Powershell, Bash, etc. Even Python has a CLI, which allows you to issue Python commands directly to the Python interpreter (this will make more sense next chapter). CLIs allow the user to issue text based commands to the system (whichever system reads and interprets the commands). So, just as I could use a GUI to view, create, open, move, and delete files and folders in the above example by clicking on buttons and icons in the GUI to issue commands to the Operating System, so too can I use the CLI to view, create, open, move, and delete files and folders by entering commands as text via the keyboard into the CLI. The particular CLI we will be using in this class is BASH . We are learning Bash instead of Command Prompt or Powershell because it is a very powerful \"shell\" that is built into all unix operating systems (Mac and Linux); however, at the time of writing, Mac is beginning to use Zsh instead, but the commands are largely the same so no worries. It is the standard CLI that you will encounter on nearly all web servers and will give you the most bang for your buck. Plus, it can be installed on Windows, and many bash commands are the saem in Powershell. Learning a CLI involves learning a set of commands (or \"magic words\") that are available. You won't need to memorize them all, but by spending time using the CLI, you will gradually pick them up. Why would we take the time to learn a CLI when you're already proficient at using a GUI? Great question! GUIs are limited to the set of actions that the GUI designer thinks that most users will need. The actions are usually triggered by a mouse click, but advanced users will likely learn Hotkeys or keyboard shortcuts to make their work faster. However, the program often has a number of other commands or actions that are difficult to access via the GUI. Using a CLI often gives you more power and control over what the program is doing. GUIs involve using a mouse or tabbing through buttons with the keyboard. This means that they are much slower to do complicated tasks. Once you become familiar with a CLI, you will be much faster at doing the same kinds of tasks, and many tasks are less complicated using a CLI than they are using a graphical interface. Let's say you decide to set up an application on a web server. First, that server exists in some server farm somewhere and the company that provides it allows you to access it remotely over a secure connection. That web server probably will not have a Desktop environment (a GUI for an operating system). Instead, it will have a CLI environment, and you will access it through a secure shell (ssh). Let's ignore the fact that the server will require that you use the CLI and think about how we might connect to that server remotely. To connect to that server, you set up an ssh connection. There are GUI programs that allow you to do this, like Putty, for instance. To do this, you must first install the program, then set up a connection through the form that the GUI provides and finally click the connect button. In Bash, however, all you have to do is type ssh username@server.com with any additional settings that might be necessary (e.g. you might need to type ssh -p 5257 username@server.com if you want to specify a particular port to connect to) and then hit enter. Likewise, many coding related applications have poor GUIs. Python's package manager (pip) for example only works in CLI. One word of caution: CLIs give you greater power and control over the machine, but that means you can mess things up pretty severely. I recommend knowing what a command will do before you execute it. This is particularly important if you are reading advice from StackOverflow or some other online forum that answers questions. Likewise, if you are not already practicing good backup habits, not would be an ideal time to start because it is possible to break things or lose data (e.g. rm -rf /home/ would delete all files installed by users without asking if you're sure).","title":"Beyond the Graphical User Interface"},{"location":"ch1/#installing-bash","text":"So if you're a Mac or Linux User, you can skip this section. You already have Bash or Zsh installed on your computer. In Mac, you'll need to locate the application called Terminal. In Linux, usually the hotkeys to open a terminal is CTRL+ALT+T. If you're a Windows 10 user, you have two options. You can set up Windows Subsystem Linux. Since developers frequently prefer developing in a Unix environment like Mac or Linux (for many reasons which I won't go into here), Windows has built a subsystem that allows you to use Linux within your Windows operating system. I use this personally when I'm using my Windows computer, but it is a little bit fiddly and permissions can be weird. The option I will walk you through here is using Git Bash. Git is a version control program that we'll talk about in a little bit, but they have created a version of Bash that works on Windows. It's lovely. head over to Git's download page and select the appropriate version of Git Bash to download. Run the installer that you just downloaded. I use the default settings, but if you want to customize the installation, feel free. Open Git Bash and a terminal will open up. Hooray.","title":"Installing Bash"},{"location":"ch1/#a-taste-of-bash","text":"If you want a great tutorial on how to use Bash and even write scripts in the Bash scripting language, check out Bash Academy for a really detailed tutorial of Bash. I strongly recommend this because knowing your way around a CLI will make the work of this program much easier. I will give you a quick overview here of Bash. I'd encourage you to follow along on your computer. When you open a Bash terminal, you will see a window with a black background and some text. Mine lookes like this: user1@DESKTOP-61VJ97U:~$ _ This is the prompt, and you'll see a cursor blinking right after the dollar sign. You can type commands here. Throughout this program, I will share code snippets and when I do, I will simply start with either ~$ or (env) ~$ So if you are following along and it looks slightly different, just know I'm cutting out the username and host for brevity sake. The first thing to learn about the CLI is how to navigate. Wherever the prompt is \"located\" in your file tree is where you will execute your commands. For example, if I am in a directory called \"projects\" and my prompt is set in that directory, then when I create a file it will be created within that directory. The first command we need to learn is pwd which stands for \"print working directory.\" The working directory is where my terminal is currently working. For example, when I open a terminal, it automatically opens to the home directory, represented by the tilda (~). So when I issue the command: ~$ pwd /home/user1 This means that my current working directory is /home/user1 and any command I issue, unless I specify otherwise, will be executed in that directory. Next, I will use the ls command to show you what directories reside within my home directory: ~$ ls Books Projects dylanmedina experiments Within my home directory I have Books, Projects, dylanmedina, and experiments. These are all directories that I can navigate into. These first two commands are crucial because they give me the location and context in which my CLI is operating. Now, let's say we're starting a new project, like this lesson. I might make a new directory for that project. To do so, I need to create a new directory and give it a name. The command is mkdir for \"make directory.\" You follow that by the name of the directory. One word on names: spaces don't work because each word of a command is separated by a space. So if I wanted to create a directory called Python for Humanists, and I issued the command ~$ mkdir Python for Humanists it would create three directories. One workaround is surround the name with quotation marks, but it's easier to just use names that don't have spaces. So let's go: ~$ mkdir pythonHumanist ~$ ls Books Projects dylanmedina experiments pythonHumanist You'll see, I created a directory called pythonHumanist and then I listed out the contents of my home directory, and you can see that my command worked. Now let's say we want to create our first Python script inside of the pythonHumanist directory. First, we can move into that directory and then we can create the file. To change directories we type cd followed by the absolute or relative path of the directory we want to visit. ~$ cd pythonHumanist ~/pythonHumanist$ You'll notice that the tilda is now followed by the directory name in my prompt showing me conveniently where I am (my working directory). Next, we create a file in that directory called hello.py and add some text to that file. We can do this in one step, but I'm doing two so you can see two different commands: ~/pythonHumanist$ touch hello.py ~/pythonHumanist$ ls hello.py ~/pythonHumanist$ echo \"print('Hello World')\" >> hello.py A few notes. First, we used the touch command to create a file. The general syntax is touch {filename} where {filename} is replaced by the name of the file you want to create. If you want to create multiple files, you can list them with a space separating each file name. Again, the same \"no spaces\" rule applies. Second, I listed out the contents of the directory to show that the file was created. If you opened the file at this point, it will be empty. Finally, I used the echo command followed by two >> greater than signs. The echo command prints some text. The greater than symbols writes the output of the echo command to the file. If I use 2 greater than signs, the output is appended to the end of the file. If I use one greater than sign, the file is overwritten with the new content. After this command, you'll see that the file hello.py contains the text print('Hello World') , which is Python code. More on that later. You can send the output of commands to other commands in Bash, and that ends up being a powerful feature. Next, let's say I want to copy files. This is really easy in Bash. The command is cp for copy and the syntax is cp {source} {destination} ~/pythonHumanist$ cp hello.py hello2.py ~/pythonHumanist$ ls hello.py hello2.py If you want to copy directories, you do so with the -r flag. Many commands have flags. These flags change the behavior of the command. In this case, I mean \"copy recursively\" or go through the contained directories and files and copy those as well as the outer directory that I named. The final command I want to cover here is rm which deletes files. BE CAREFUL WITH THIS COMMAND BECAUSE THERE WILL NOT BE A PROMPT ASKING IF YOU'RE SURE YOU WANT TO DELETE A FILE ~/pythonHumanist$ rm hello.py ~/pythonHumanist$ cd .. ~$ rm -r pythonHumanist First, I remove the file hello.py using the rm command. Then I change directories up one level ( .. signifies up one level) so I change the working directory to home. Then I remove the pythonHumanist directory using the -r flag. Again, many commands in Bash have flags that you can add that change the behavior. -r means recursive and it is what we use to remove directories. It means go into the directory, recursively delete all the files and then remove the directory. So if I had wanted to, I could have skipped removing the hello.py file first and just removed the directory and the file would have been deleted, too. There are many other commands that you will want to use, but I just wanted to give you a brief overview. We will encounter others that you'll have to learn as you go. If you have the time and energy, I strongly suggest spending a few hours and going further into Bash, as some of the concepts will make learning Python a bit easier.","title":"A taste of Bash"},{"location":"ch1/#setup-our-environment","text":"We've done a bit of set up already and introduced you to the CLI. Now we need to finish getting things set up so that we can dive into Python next chapter. There are a few things we'll need. First, we need to get a good text editor. Python, as all code, is a bunch of human readable text that some program on the computer can understand and translate into the appropriate machine language that the computer can understand. There are tons of text editors out there and technically we could use Notepad for our code, but we want to use something with a few more features. KEY: do not use a word processor like Word to write code. When you use a word processor it adds extra markup to your file to display the formatting of the text and this will make your code non-functional. We will be using Visual Studio Code, but Atom is another good free option. I like Visual Studio Code because it gives you a file explorer and a terminal all built into one. Head over to the Visual Studio Code download page Download the installer for your operating system and run the installer. Check the installation by opening Git Bash (or Bash if you're in Mac) and typing code --version Set up User Settings in Visual Studio Code VS Code allows you to customize settings for all projects (User Settings) or for a single project (Workspace settings). To modify default settings select Code | Preferences for the Mac or File | Preferences for Windows and then Settings. You will see 2 files side by side. On the left are the default settings and on the right are the User setting overrides. To change a default setting find the setting on the left and then copy it to the right with your desired setting. For example, if you don't want to see the minimap on the right hand side of the application, you can make the following entry in the file on the right. Notice that options are key : value pairs and that they are commas separated. { \"editor.minimap.enabled\":false } Make \"Git Bash\" the default command line in VS Code terminal by adding the following to your User Settings: \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\"","title":"Setup our Environment"},{"location":"ch1/#install-python","text":"You'll also need to install Python. Python has a number of versions, and Python 3 is the one we will be using. If you are on Windows, you don't have Python. If you're on Mac or Linux, you have Python 2 so you need to add Python 3.","title":"Install Python"},{"location":"ch1/#installing-python-on-windows","text":"Head to the Python downloads page and select the Python 3 installer. Run the installer, and allow it to add Python3 to the Path. This is important, so make sure you pay attention to the option for adding Python3 to your PATH. Once you've installed Python3, open Git Bash and type python --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. If it still doesn't work, probably Python was not added to the PATH. You can Google adding Python to the PATH in Windows.","title":"Installing Python on Windows"},{"location":"ch1/#installing-python-3-on-mac","text":"Macs come with Python2 installed, so you will need to install Python3. Note, DO NOT UNINSTALL OR OTHERWISE REMOVE PYTHON 2 . It will break your operating system. Head to the Python downloads page and select the Python 3 installer. Run the installer. (Don't worry about the PATH, as that's not an issue we deal with in UNIX in the same way.) Once you've installed Python3, open Git Bash and type python3 --version and you should get a version number back. If not, or if you get an error, try to close Bash and open it again. If that doesn't work, try installing again. Also, if you type python --version it will say python 2.7 or something like that. By default on Mac and Linux, Python 2 is installed so the python command will use Python 2. We need to use python3 instead until we setup virtual environments.","title":"Installing Python 3 on Mac"},{"location":"ch1/#set-up-github","text":"Github is awesome! It is a place where you can share code and manage version control. Please do not get confused between Github and Git. Git is a CLI program that manages version control. Every time you \"commit\" changes with git, you create a new version. Behind the scenes, git manages a set of diff files that keep track of the changes that were made to the repository (or collection of code) since the last commit. Github is an online storage service that integrates with git and allows you to push your code to this service and share it both with teams and publicly. I'm not going to go over the Git commands here, but here is a good tutorial .","title":"Set up Github"},{"location":"ch2/","text":"A Taste of Python File Structures Before we get too far into Python, there's one thing you need to understand very well. That is file structures. Your files are stored the computer in a hierarchical structure. A good way to think of it is as a tree starting from the root. / or c:\\ [The root directory. Everything is within this directory] /bin /opt /var /home /user1 /Documents /3010 /code my_function.py hangman.py anotherprogram.py /Articles transitions.docx techofhate.docx /Desktop hangman.py /Videos /Pictures If you look at the directory above, in the root I have the directories bin, opt, var, and home. These directories are at the same level, so they are called siblings. Each of these is a directory within the root, so the root is the parent. In Windows, the root is \"c:\\\" and folders will likely have different names, but the structure is similar. If we look at the \"home\" directory, we have a directory called \"user1\", and within that a few directories, including Documents, Desktop, Videos, and Pictures. Documents contains directories 3010 and Articles. user1 would be called a child of home. 3010 contains the code directory. /code and Articles both contain files. When I want to identify a file, I can identify it with its absolute path. This is the path from the root to the file or folder I'm identifying. So to identify the absolute path of hangman.py, I would need to call it /home/user1/Documents/code/3010/hangman.py. Likewise, to identify transitions.docx, I'd need to call it /home/user1/Documents/Articles/transitions.docx. Using the absolute path in a command or in code will guarantee that the computer can find a file I'm looking for. In commands and programming, it's important to note that unless we use a search function, the computer will not be able to \"search\" for a file. So, if I am working in /home/user1/Desktop and I issue the command python hangman.py the computer will look for hangman.py in my current working directory, and since there is no file called \"hangman.py\" in that working directory, it will be unable to find the file, and the terminal will throw a File Not Found error. What's going on here? Why can't the computer just know what file I'm talking about and run it. After all, it's stored in the memory, right? Yes, but there may be multiple files called \"hangman.py\" in different directories. That is totally legal in terms of storage, and maybe even reasonable practice. After all, you might be working on 100 websites on your local server, and each of them will have an \"index.php\" or \"index.html\" file because the web server looks for that. When entering commands or executing programs, don't want your program to stop and say, \"which hangman.py?\" every time you try to reference a file. To address such possible collisions, computers use something called \"namespaces.\" We'll think about this more later, but for now think of it as the \"working context\" in which your program is running. When you type pwd into your terminal, it tells you what the working context is, or where your terminal is focused. When you issue a command or write a line of code that references a named entity like a variable or a file, it looks for that entity or file in the working context unless you specify otherwise. This means that if you're working in /home/user1/Documents/code/3010 and you enter python hangman.py it looks only in the 3010 directory even though there is a hangman.py in Documents (see above). The thing to understand now is that the working context is where the program looks for named entities. If that entity (a file or variable) doesn't exist in that context (in that directory), then the program won't look elsewhere. It will throw an error. This is true for executing code and for changing directories. Let's say I'm working in the root directory (/). If I want to change directories to code/ I can't simply say cd code because there is no \"code\" directory in the root. Instead, I have to explicitly give the terminal the path to that directory with this command cd home/user1/Documents/code Let's break down how this is interpreted: Computer change the working directory to code which exists inside Documents, which exists inside user1, which exists inside home, The terminal is currently in the root. /home/ exists in the root so it can find that. Then inside /home/, user1/ exists as a directory, so it can find that. Then inside user1/, it can find Documents/ because that exists there. Finally, inside Documents/ it can find code/ I hope I'm not belaboring this too much, but it is crucial, especially as we move into next week to consider scope. You might know exactly where all of the files are located at. That's how a human brain works. We can create nice conceptual maps that help us infer stuff. Computers do not infer. If try to use a named entity (file or variable) in a different context (like calling a python script from another directory), the computer will only look in the local context unless you give it an explicit path to find that entity. It will never infer that you mean the \"hangman.py\" in /home/user1/Documents/code/3010/ and not the \"hangman.py\" in /home/user1/Desktop/ In short, remember, that you must be really explicit when you leave the comforts of a graphical interface like the Finder or File Explorer. Compiled versus Interpreted Languages Compiled? Interpeted? What the What? Generally when we talk about programming, we are talking about a human readable programming language that is easy for a human to understand. However, if we look at what's actually happening on the processor when the commands are being executed, those commands are in binary, or sets of on and off switches. Here is a miniature example of what addition looks like in human readable form and the binary operation that occurs on the processor when a computer calculates it: Human Readable: 12 + 11 = 23 Assembly Code: Binary Operation: 1100 + 1011 = 10111 I'd recommend that you take a moment to search for the binary representation of 23 and you will find that it is 10111. Why does this matter? A processor can't do anything with 23 until it is converted to binary, which are then converted to a series of charged and uncharged states, or a series of ON or OFF switches. It can, however, do operations with these sequences of electrical charges, and a great deal of work is done by the computer to translate between human readable and machine readable forms. For us, this means that every line of code eventually is converted into binary, and so what matters to us is how our code becomes binary. This leads us to compiled versus interpreted languages. The code we write, whether in Python or Java or C++ is written in human readable form. This means that we can understand it, and Python is particularly understandable. But the code must either be compiled or interpreted for it to run. Assembly and Machine Code I'll discuss the difference between compiled and interpreted in a moment, but there is a crucial intermediary between binary or bytecode and our high level programming languages. This intermediary is called assembly. Assembly is low level programming language that is a little bit human readable, but it is representations of specific commands that are executed by the processor. In other words, for a computer to perform an operation like 12 + 11, it would be one line of code in Python, but would require a number of operations on the processor to complete the summation. For instance, the computer needs to load the binary representation of 12 and 11 into registers (tiny bits of memory) on the processor. It needs to perform the operation on the binary values in each of the registers. The computer needs to write the result to another register and then send the decimal value of the result to the screen (which is a couple more steps). Assembly language contains the series of commands that cause the processor to do this. Assembly has a 1 to 1 relationship between command or line of code and operation performed by the processor. The translation between Assembly and the binary that the processor reads is done by the Assembler, which is processor specific (so an x86 and x64 processor would have different assemblers and different Assembly languages). You don't really need to know anything more about Assembly for our purposes except that all of the code we write is probably going to be converted into Assembly. Interpreted and Compiled is largely a difference in when and how that occurs. Compiled Languages Many programming languages are compiled. C++ and Java would be two examples. This means that a programmer writes their program, and then they run it through a compiler, which is a special program that converts the high level language into either an \"executable\" file of Assembly or some other low level language (often .exe in Windows) or directly into binary as is the case on some mobile phones or single board computers. To run the program, the programmer would not run the code written in the high level language (the source code), but instead would run the compiled executable which is the low level translation of the source code. Compiled languages have the advantage of being much faster to execute because at runtime the computer is reading assembly instead of the high level language (this will make more sense when I talk about interpreted languages). They are also slightly more complicated and often a little more difficult to learn. The communities online that surround C++ and Java, two high-level compiled languages, are also a little more grumpy towards newcomers than Python. Interpreted Languages An interpreted language does not need to be compiled. Instead, the programmer writes in the high level language. Then they run the program using the interpreter (in our case the Python program). At runtime, the interpreter reads the source code, converts the source code to lower level code like assembly. That lower level code is then executed by the processor. Notice, compiled languages are turned into executables and when we want to run the program, we don't run the source code, we run the executable which doesn't need to be interpreted into some lower level language at runtime. Interpreted languages on the other hand must be first interpreted into a lower level language and then executed, all at runtime. This can make things really slow. Python has a few tricks to address this deficiency. First, when we execute any Python script, you'll probably see a pycache folder created. In that folder, Python saves an interpreted version of the program in cache. This way, if Python has to run a program again, it will check to see if the program is the same in the cache first and if so, it will not re-interpret the source code, but run the cached version. If there is no cached version or if changes have been made, Python updates the cache and interprets the source code. Developers have also created Cython, which allows the developer to write Python or Cython code but get performance like that of a compiled language. This is a bit beyond the scope of this class, however. Do I need to know all of this? No, not really. I won't be testing you on it, but hopefully it will help you have some context around programming and programming languages. It is definitely going to be important to know the difference between a compiled and interpreted language, but the details of how they work (how programs are compiled or interpreted) is not something you need to know unless you get really serious about programming or get into computer science. Now Python Python refers to two related things. First, Python refers to a programming language that we use to give commands to our computer. This we'll talk at length about throughout the quarter. Second, Python refers to the program that runs on your computer that interprets the code that you write. Dr. Chuck talks about this to some extent in the book. Python the program converts your code into machine language that causes your computer to do things. Just like any program, Python is regularly updated and has minor and major versions. You'll hear almost immediately when looking at Python that there are two major versions: Python2 and Python3. Python 2.7.14 is the most recent version of Python2, and Python 3.8 is the main version of Python3. When we talk about Python version, we're talking about which version of the Python program we're using to interpret our code (we're also talking about our code, but more on that later). This difference is pretty important because as the language evolves over time, some of the features stop working or the syntax, or the way we write code, changes. For example, if we want to print some text to the screen, we use the \"print\" method. In Python 2 the syntax was this: print \"Hello, Snek!\" and for the same functionality in Python 3 you have to write: print(\"Hello, Snek!\") The Python3 interpreter would throw a Syntax error because it no does not recognizes the \"print\" function without parentheses. In short, as the Python program is updated, the way we write Python code has to change to account for the expectations of the interpreter. Does this mean that we have to update all of our code? Not necessarily. It does mean we need to be concerned with which version of Python we're writing for and which is running our code. In this class you will be writing code for a Python3 interpreter or you will be writing Python3 code, but it is good to be familiar with some of the major differences. We'll talk about them as they come up. What is important, though, is that you will need to make sure the Python3 interpreter is installed on your computer. Python Interpreter When we write Python programs, we're usually writing a series of instructions to a file. When we run the program, we tell the Python interpreter to open the file and read and execute the instructions that are contained therein. However, we can also issue commands to the Python interpreter in the same way we can with Bash. The Python CLI can be opened by launching Python without specifying a script. You'll notice before that I just need to type python in Windows and python3 in Mac/Linux because in the latter I have both Python 2 and Python 3 installed. Windows ~$ python Python 3.8.3 (tags/v3.8.3:6f8c832, May 13 2020, 22:37:02) [MSC v.1924 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Mac/Linux ~$ python3 Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> You know that you're in the Python interpreter because of the three greater than ( >>> ) symbols. Once there, we can play around. I recommend you follow along. >>> 2 + 2 4 >>> 2 * 8 16 >>> 2 * (18 + 72) 180 >>> print(\"Hello, world!\") Hello, world! >>> sorted([18, 27, 2, 9, 6]) [2, 6, 9, 18, 27] >>> type(2.7) <class 'float'> >>> type(2) <class 'int'> >>> type('Puppies') <class 'str'> >>> exit() ~$ What you see here is a sequence of commands that I sent to the Python interpreter in the Python programming language. On the prompt lines (preceded by >>> ), I entered my commands. On the following lines is the response of the Python interpreter. Kind of like a conversation: Me: Python, please add 2 and 2. Python: 4 Me: Python, please multiply 2 and 8. Python: 16 Me: Python, please first add 18 and 72, and then multiply that sum by 2. Python: 180 Me: Python, please print to the console the string \"Hello, world!\" Python: Hello, world! Me: Python, please sort the list of numbers 18, 27, 2, 9, and 6 in ascending order. Python: [2, 6, 9, 18, 27] Me: Python, please tell me what type of data 2.7 is. Python: It is a floating point decimal Me: Python, please tell me what type of data 2 is. Python: It is an integer. Me: Python, please tell me what type of data \"Puppies\" is. Python: It is a string Me: Please exit, python Python: exits and returns to Bash prompt If you followed along with the code above, you just coded your first bit of Python. Congratulations! Generally, when we code Python, we write the commands into a text file and then the interpreter executes them when we tell them to do so, but for now, we have cut out the middleman of the file and written our commands directly to the interpreter. It's important to note that the commands are executed in the order we give them. The same is true when we write our code into a file. The interpreter will execute those commands in order. This is the project for next chapter, so I will leave it at that. You've just gotten your first taste of Python. Virtual Environments You might be wondering, how do we keep all the versions of Python sorted out? That's a good question and it extends to all the other libraries that we install. When we use someone else's code, we're taking on dependencies. As they update their code, we might have used an older version, so we need to make sure that we don't accidentally pull in the newer version of their code because it might no longer be compatible with our code. Also, we ourselves could write a program in 2020, but within the next year probably, Python 4 will be released. This means that if we update to Python 4 on our machine, our code will probably break because there will be changes in how Python is written. We need a way to make sure that the same version of the Python interpreter is always used to execute our code. We manage this and all of our dependencies using what's called Virtual Environments. These allow us to bundle up our code and dependencies at a frozen moment in time, and isolate that project's dependencies from other projects and versions of Python. Managing Virtual Environments has become extremely easy. There are a number of tools to do so including pipenv and venv . We'll be using venv here because it is included when you install Python, and where it stores the virtual environment directory is a bit more obvious. To launch it we simply tell Python to execute the venv module. To tell Python to use a module, we need to use the -m flag. $ python3 -m venv -h usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in. optional arguments: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default) --prompt PROMPT Provides an alternative prompt prefix for this environment. Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory. My command was python3 -m venv -h , which basically means \"Python, execute a module called venv and send the -h command to it.\" You can see from the help article that is returned that when you send the -h command to venv, it displays the help article. Now we can look at the general syntax for using venv . First, it's worth noting that I called python3 rather than python . If you're in Windows and only have Python 3 installed, or if you plan to use Python 2 in Mac or Linux, you would call python . You'll see that there is a required, positional argument. We'll learn about arguments when we talk about functions, but for now, think of it as a bit of extra data that will be used by the program. Specifically, in this case it is an ENV_DIR which probably stands for environment directory. This means we need to give the command a name of a directory where the environment data will be stored. This does not mean the name of the directory for the project, but some other name that we can remember is our virtual environment directory. Let me show you the code first, so maybe it's a bit more clear. $ mkdir my_project $ ls my_project $ cd my_project $ ls $ python3 -m venv env $ ls env Ok, first I made a new directory for my project and changed into that directory. I'm using ls to show you what is there. Next, I used venv and created an environment in a directory called env . This env is arbitrary. I choose to call the directory \"env\" because it's known and makes sense. You could call it \"puppy\" or \"an_environment_directory\" but that would make less sense. Also, it's worth noting that the env directory was created by venv. I didn't need to create it first. Finally, you'll never need to manually change anything inside that env folder. Just create it and leave it alone. The package management tools will manage the environment for you. Our next step after creating the resources for our virtual environment is to activate it. Once the environment is activated, whenever we use Python, we will be using the one in this environment. This means that our commands to call Python will always be python rather than python3 because in THIS environment there is only one version of Python installed. So let's activate our environment: Mac/Linux ~/my_project$ source env/bin/activate (env) ~/my_project$ Windows ~/my_project/~ env\\Scripts\\activate (env) ~/my_project$ In both cases we run the activate script to launch our virtual environment. Pay attention to the (env) bit because that tells you your Bash prompt is working in that virtual environment. If this all seems a little confusing now, that's okay. It becomes much more clear with practice. Now that we have our virtual environment created and activated, we can start working. Pip and Pip Freeze When we use Python, we probably will be installing libraries that other people have created. These libraries give us functionality that allows us to avoid having to write a bunch of stuff. We'll talk about this in detail in a few chapters, but for now, consider the work it would require to connect to a website. First, we'd need to use sockets to get our network card to connect to the internet. Then we'd need to build our requests. Then we'd need to listen for a response and so on. Instead, I can just install the requests library that someone else built and maintains, and all that work is done for me. I just use functionality that is build into requests . We do the same thing when we use a web browser, but a web browser has more functionality built in and is used predominately through a GUI. More on this later. For now, we just need to know how to install and manage our virtual environment and the packages that are installed there. To install a package the command is simply pip install {package name} . We'll again talk about this at length in a few chapters. For now, what is most important is the pip freeze command. If we just type that in our Bash terminal the list of packages and their version numbers will be printed to the screen. In general, we will issue the pip freeze command with the output being written to a file called requirements.txt . This will allow us to track the single file in our git repository rather than the entire env/ directory. Conclusion This chapter was a brief introduction to Python and is designed to prepare you for the next chapter. In the next chapter, we'll discuss the first lessons in Python programming. We'll cover the basic syntax and variables.","title":"A Taste of Python"},{"location":"ch2/#a-taste-of-python","text":"","title":"A Taste of Python"},{"location":"ch2/#file-structures","text":"Before we get too far into Python, there's one thing you need to understand very well. That is file structures. Your files are stored the computer in a hierarchical structure. A good way to think of it is as a tree starting from the root. / or c:\\ [The root directory. Everything is within this directory] /bin /opt /var /home /user1 /Documents /3010 /code my_function.py hangman.py anotherprogram.py /Articles transitions.docx techofhate.docx /Desktop hangman.py /Videos /Pictures If you look at the directory above, in the root I have the directories bin, opt, var, and home. These directories are at the same level, so they are called siblings. Each of these is a directory within the root, so the root is the parent. In Windows, the root is \"c:\\\" and folders will likely have different names, but the structure is similar. If we look at the \"home\" directory, we have a directory called \"user1\", and within that a few directories, including Documents, Desktop, Videos, and Pictures. Documents contains directories 3010 and Articles. user1 would be called a child of home. 3010 contains the code directory. /code and Articles both contain files. When I want to identify a file, I can identify it with its absolute path. This is the path from the root to the file or folder I'm identifying. So to identify the absolute path of hangman.py, I would need to call it /home/user1/Documents/code/3010/hangman.py. Likewise, to identify transitions.docx, I'd need to call it /home/user1/Documents/Articles/transitions.docx. Using the absolute path in a command or in code will guarantee that the computer can find a file I'm looking for. In commands and programming, it's important to note that unless we use a search function, the computer will not be able to \"search\" for a file. So, if I am working in /home/user1/Desktop and I issue the command python hangman.py the computer will look for hangman.py in my current working directory, and since there is no file called \"hangman.py\" in that working directory, it will be unable to find the file, and the terminal will throw a File Not Found error. What's going on here? Why can't the computer just know what file I'm talking about and run it. After all, it's stored in the memory, right? Yes, but there may be multiple files called \"hangman.py\" in different directories. That is totally legal in terms of storage, and maybe even reasonable practice. After all, you might be working on 100 websites on your local server, and each of them will have an \"index.php\" or \"index.html\" file because the web server looks for that. When entering commands or executing programs, don't want your program to stop and say, \"which hangman.py?\" every time you try to reference a file. To address such possible collisions, computers use something called \"namespaces.\" We'll think about this more later, but for now think of it as the \"working context\" in which your program is running. When you type pwd into your terminal, it tells you what the working context is, or where your terminal is focused. When you issue a command or write a line of code that references a named entity like a variable or a file, it looks for that entity or file in the working context unless you specify otherwise. This means that if you're working in /home/user1/Documents/code/3010 and you enter python hangman.py it looks only in the 3010 directory even though there is a hangman.py in Documents (see above). The thing to understand now is that the working context is where the program looks for named entities. If that entity (a file or variable) doesn't exist in that context (in that directory), then the program won't look elsewhere. It will throw an error. This is true for executing code and for changing directories. Let's say I'm working in the root directory (/). If I want to change directories to code/ I can't simply say cd code because there is no \"code\" directory in the root. Instead, I have to explicitly give the terminal the path to that directory with this command cd home/user1/Documents/code Let's break down how this is interpreted: Computer change the working directory to code which exists inside Documents, which exists inside user1, which exists inside home, The terminal is currently in the root. /home/ exists in the root so it can find that. Then inside /home/, user1/ exists as a directory, so it can find that. Then inside user1/, it can find Documents/ because that exists there. Finally, inside Documents/ it can find code/ I hope I'm not belaboring this too much, but it is crucial, especially as we move into next week to consider scope. You might know exactly where all of the files are located at. That's how a human brain works. We can create nice conceptual maps that help us infer stuff. Computers do not infer. If try to use a named entity (file or variable) in a different context (like calling a python script from another directory), the computer will only look in the local context unless you give it an explicit path to find that entity. It will never infer that you mean the \"hangman.py\" in /home/user1/Documents/code/3010/ and not the \"hangman.py\" in /home/user1/Desktop/ In short, remember, that you must be really explicit when you leave the comforts of a graphical interface like the Finder or File Explorer.","title":"File Structures"},{"location":"ch2/#compiled-versus-interpreted-languages","text":"","title":"Compiled versus Interpreted Languages"},{"location":"ch2/#compiled-interpeted-what-the-what","text":"Generally when we talk about programming, we are talking about a human readable programming language that is easy for a human to understand. However, if we look at what's actually happening on the processor when the commands are being executed, those commands are in binary, or sets of on and off switches. Here is a miniature example of what addition looks like in human readable form and the binary operation that occurs on the processor when a computer calculates it: Human Readable: 12 + 11 = 23 Assembly Code: Binary Operation: 1100 + 1011 = 10111 I'd recommend that you take a moment to search for the binary representation of 23 and you will find that it is 10111. Why does this matter? A processor can't do anything with 23 until it is converted to binary, which are then converted to a series of charged and uncharged states, or a series of ON or OFF switches. It can, however, do operations with these sequences of electrical charges, and a great deal of work is done by the computer to translate between human readable and machine readable forms. For us, this means that every line of code eventually is converted into binary, and so what matters to us is how our code becomes binary. This leads us to compiled versus interpreted languages. The code we write, whether in Python or Java or C++ is written in human readable form. This means that we can understand it, and Python is particularly understandable. But the code must either be compiled or interpreted for it to run.","title":"Compiled? Interpeted? What the What?"},{"location":"ch2/#assembly-and-machine-code","text":"I'll discuss the difference between compiled and interpreted in a moment, but there is a crucial intermediary between binary or bytecode and our high level programming languages. This intermediary is called assembly. Assembly is low level programming language that is a little bit human readable, but it is representations of specific commands that are executed by the processor. In other words, for a computer to perform an operation like 12 + 11, it would be one line of code in Python, but would require a number of operations on the processor to complete the summation. For instance, the computer needs to load the binary representation of 12 and 11 into registers (tiny bits of memory) on the processor. It needs to perform the operation on the binary values in each of the registers. The computer needs to write the result to another register and then send the decimal value of the result to the screen (which is a couple more steps). Assembly language contains the series of commands that cause the processor to do this. Assembly has a 1 to 1 relationship between command or line of code and operation performed by the processor. The translation between Assembly and the binary that the processor reads is done by the Assembler, which is processor specific (so an x86 and x64 processor would have different assemblers and different Assembly languages). You don't really need to know anything more about Assembly for our purposes except that all of the code we write is probably going to be converted into Assembly. Interpreted and Compiled is largely a difference in when and how that occurs.","title":"Assembly and Machine Code"},{"location":"ch2/#compiled-languages","text":"Many programming languages are compiled. C++ and Java would be two examples. This means that a programmer writes their program, and then they run it through a compiler, which is a special program that converts the high level language into either an \"executable\" file of Assembly or some other low level language (often .exe in Windows) or directly into binary as is the case on some mobile phones or single board computers. To run the program, the programmer would not run the code written in the high level language (the source code), but instead would run the compiled executable which is the low level translation of the source code. Compiled languages have the advantage of being much faster to execute because at runtime the computer is reading assembly instead of the high level language (this will make more sense when I talk about interpreted languages). They are also slightly more complicated and often a little more difficult to learn. The communities online that surround C++ and Java, two high-level compiled languages, are also a little more grumpy towards newcomers than Python.","title":"Compiled Languages"},{"location":"ch2/#interpreted-languages","text":"An interpreted language does not need to be compiled. Instead, the programmer writes in the high level language. Then they run the program using the interpreter (in our case the Python program). At runtime, the interpreter reads the source code, converts the source code to lower level code like assembly. That lower level code is then executed by the processor. Notice, compiled languages are turned into executables and when we want to run the program, we don't run the source code, we run the executable which doesn't need to be interpreted into some lower level language at runtime. Interpreted languages on the other hand must be first interpreted into a lower level language and then executed, all at runtime. This can make things really slow. Python has a few tricks to address this deficiency. First, when we execute any Python script, you'll probably see a pycache folder created. In that folder, Python saves an interpreted version of the program in cache. This way, if Python has to run a program again, it will check to see if the program is the same in the cache first and if so, it will not re-interpret the source code, but run the cached version. If there is no cached version or if changes have been made, Python updates the cache and interprets the source code. Developers have also created Cython, which allows the developer to write Python or Cython code but get performance like that of a compiled language. This is a bit beyond the scope of this class, however. Do I need to know all of this? No, not really. I won't be testing you on it, but hopefully it will help you have some context around programming and programming languages. It is definitely going to be important to know the difference between a compiled and interpreted language, but the details of how they work (how programs are compiled or interpreted) is not something you need to know unless you get really serious about programming or get into computer science.","title":"Interpreted Languages"},{"location":"ch2/#now-python","text":"Python refers to two related things. First, Python refers to a programming language that we use to give commands to our computer. This we'll talk at length about throughout the quarter. Second, Python refers to the program that runs on your computer that interprets the code that you write. Dr. Chuck talks about this to some extent in the book. Python the program converts your code into machine language that causes your computer to do things. Just like any program, Python is regularly updated and has minor and major versions. You'll hear almost immediately when looking at Python that there are two major versions: Python2 and Python3. Python 2.7.14 is the most recent version of Python2, and Python 3.8 is the main version of Python3. When we talk about Python version, we're talking about which version of the Python program we're using to interpret our code (we're also talking about our code, but more on that later). This difference is pretty important because as the language evolves over time, some of the features stop working or the syntax, or the way we write code, changes. For example, if we want to print some text to the screen, we use the \"print\" method. In Python 2 the syntax was this: print \"Hello, Snek!\" and for the same functionality in Python 3 you have to write: print(\"Hello, Snek!\") The Python3 interpreter would throw a Syntax error because it no does not recognizes the \"print\" function without parentheses. In short, as the Python program is updated, the way we write Python code has to change to account for the expectations of the interpreter. Does this mean that we have to update all of our code? Not necessarily. It does mean we need to be concerned with which version of Python we're writing for and which is running our code. In this class you will be writing code for a Python3 interpreter or you will be writing Python3 code, but it is good to be familiar with some of the major differences. We'll talk about them as they come up. What is important, though, is that you will need to make sure the Python3 interpreter is installed on your computer.","title":"Now Python"},{"location":"ch2/#python-interpreter","text":"When we write Python programs, we're usually writing a series of instructions to a file. When we run the program, we tell the Python interpreter to open the file and read and execute the instructions that are contained therein. However, we can also issue commands to the Python interpreter in the same way we can with Bash. The Python CLI can be opened by launching Python without specifying a script. You'll notice before that I just need to type python in Windows and python3 in Mac/Linux because in the latter I have both Python 2 and Python 3 installed.","title":"Python Interpreter"},{"location":"ch2/#windows","text":"~$ python Python 3.8.3 (tags/v3.8.3:6f8c832, May 13 2020, 22:37:02) [MSC v.1924 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>>","title":"Windows"},{"location":"ch2/#maclinux","text":"~$ python3 Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> You know that you're in the Python interpreter because of the three greater than ( >>> ) symbols. Once there, we can play around. I recommend you follow along. >>> 2 + 2 4 >>> 2 * 8 16 >>> 2 * (18 + 72) 180 >>> print(\"Hello, world!\") Hello, world! >>> sorted([18, 27, 2, 9, 6]) [2, 6, 9, 18, 27] >>> type(2.7) <class 'float'> >>> type(2) <class 'int'> >>> type('Puppies') <class 'str'> >>> exit() ~$ What you see here is a sequence of commands that I sent to the Python interpreter in the Python programming language. On the prompt lines (preceded by >>> ), I entered my commands. On the following lines is the response of the Python interpreter. Kind of like a conversation: Me: Python, please add 2 and 2. Python: 4 Me: Python, please multiply 2 and 8. Python: 16 Me: Python, please first add 18 and 72, and then multiply that sum by 2. Python: 180 Me: Python, please print to the console the string \"Hello, world!\" Python: Hello, world! Me: Python, please sort the list of numbers 18, 27, 2, 9, and 6 in ascending order. Python: [2, 6, 9, 18, 27] Me: Python, please tell me what type of data 2.7 is. Python: It is a floating point decimal Me: Python, please tell me what type of data 2 is. Python: It is an integer. Me: Python, please tell me what type of data \"Puppies\" is. Python: It is a string Me: Please exit, python Python: exits and returns to Bash prompt If you followed along with the code above, you just coded your first bit of Python. Congratulations! Generally, when we code Python, we write the commands into a text file and then the interpreter executes them when we tell them to do so, but for now, we have cut out the middleman of the file and written our commands directly to the interpreter. It's important to note that the commands are executed in the order we give them. The same is true when we write our code into a file. The interpreter will execute those commands in order. This is the project for next chapter, so I will leave it at that. You've just gotten your first taste of Python.","title":"Mac/Linux"},{"location":"ch2/#virtual-environments","text":"You might be wondering, how do we keep all the versions of Python sorted out? That's a good question and it extends to all the other libraries that we install. When we use someone else's code, we're taking on dependencies. As they update their code, we might have used an older version, so we need to make sure that we don't accidentally pull in the newer version of their code because it might no longer be compatible with our code. Also, we ourselves could write a program in 2020, but within the next year probably, Python 4 will be released. This means that if we update to Python 4 on our machine, our code will probably break because there will be changes in how Python is written. We need a way to make sure that the same version of the Python interpreter is always used to execute our code. We manage this and all of our dependencies using what's called Virtual Environments. These allow us to bundle up our code and dependencies at a frozen moment in time, and isolate that project's dependencies from other projects and versions of Python. Managing Virtual Environments has become extremely easy. There are a number of tools to do so including pipenv and venv . We'll be using venv here because it is included when you install Python, and where it stores the virtual environment directory is a bit more obvious. To launch it we simply tell Python to execute the venv module. To tell Python to use a module, we need to use the -m flag. $ python3 -m venv -h usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] ENV_DIR [ENV_DIR ...] Creates virtual Python environments in one or more target directories. positional arguments: ENV_DIR A directory to create the environment in. optional arguments: -h, --help show this help message and exit --system-site-packages Give the virtual environment access to the system site-packages dir. --symlinks Try to use symlinks rather than copies, when symlinks are not the default for the platform. --copies Try to use copies rather than symlinks, even when symlinks are the default for the platform. --clear Delete the contents of the environment directory if it already exists, before environment creation. --upgrade Upgrade the environment directory to use this version of Python, assuming Python has been upgraded in-place. --without-pip Skips installing or upgrading pip in the virtual environment (pip is bootstrapped by default) --prompt PROMPT Provides an alternative prompt prefix for this environment. Once an environment has been created, you may wish to activate it, e.g. by sourcing an activate script in its bin directory. My command was python3 -m venv -h , which basically means \"Python, execute a module called venv and send the -h command to it.\" You can see from the help article that is returned that when you send the -h command to venv, it displays the help article. Now we can look at the general syntax for using venv . First, it's worth noting that I called python3 rather than python . If you're in Windows and only have Python 3 installed, or if you plan to use Python 2 in Mac or Linux, you would call python . You'll see that there is a required, positional argument. We'll learn about arguments when we talk about functions, but for now, think of it as a bit of extra data that will be used by the program. Specifically, in this case it is an ENV_DIR which probably stands for environment directory. This means we need to give the command a name of a directory where the environment data will be stored. This does not mean the name of the directory for the project, but some other name that we can remember is our virtual environment directory. Let me show you the code first, so maybe it's a bit more clear. $ mkdir my_project $ ls my_project $ cd my_project $ ls $ python3 -m venv env $ ls env Ok, first I made a new directory for my project and changed into that directory. I'm using ls to show you what is there. Next, I used venv and created an environment in a directory called env . This env is arbitrary. I choose to call the directory \"env\" because it's known and makes sense. You could call it \"puppy\" or \"an_environment_directory\" but that would make less sense. Also, it's worth noting that the env directory was created by venv. I didn't need to create it first. Finally, you'll never need to manually change anything inside that env folder. Just create it and leave it alone. The package management tools will manage the environment for you. Our next step after creating the resources for our virtual environment is to activate it. Once the environment is activated, whenever we use Python, we will be using the one in this environment. This means that our commands to call Python will always be python rather than python3 because in THIS environment there is only one version of Python installed. So let's activate our environment:","title":"Virtual Environments"},{"location":"ch2/#maclinux_1","text":"~/my_project$ source env/bin/activate (env) ~/my_project$","title":"Mac/Linux"},{"location":"ch2/#windows_1","text":"~/my_project/~ env\\Scripts\\activate (env) ~/my_project$ In both cases we run the activate script to launch our virtual environment. Pay attention to the (env) bit because that tells you your Bash prompt is working in that virtual environment. If this all seems a little confusing now, that's okay. It becomes much more clear with practice. Now that we have our virtual environment created and activated, we can start working.","title":"Windows"},{"location":"ch2/#pip-and-pip-freeze","text":"When we use Python, we probably will be installing libraries that other people have created. These libraries give us functionality that allows us to avoid having to write a bunch of stuff. We'll talk about this in detail in a few chapters, but for now, consider the work it would require to connect to a website. First, we'd need to use sockets to get our network card to connect to the internet. Then we'd need to build our requests. Then we'd need to listen for a response and so on. Instead, I can just install the requests library that someone else built and maintains, and all that work is done for me. I just use functionality that is build into requests . We do the same thing when we use a web browser, but a web browser has more functionality built in and is used predominately through a GUI. More on this later. For now, we just need to know how to install and manage our virtual environment and the packages that are installed there. To install a package the command is simply pip install {package name} . We'll again talk about this at length in a few chapters. For now, what is most important is the pip freeze command. If we just type that in our Bash terminal the list of packages and their version numbers will be printed to the screen. In general, we will issue the pip freeze command with the output being written to a file called requirements.txt . This will allow us to track the single file in our git repository rather than the entire env/ directory.","title":"Pip and Pip Freeze"},{"location":"ch2/#conclusion","text":"This chapter was a brief introduction to Python and is designed to prepare you for the next chapter. In the next chapter, we'll discuss the first lessons in Python programming. We'll cover the basic syntax and variables.","title":"Conclusion"},{"location":"ch3/","text":"Encoding Identity In this chapter we're going to really begin diving into Python. We'll start with a bit of review of the basic syntax using the Python CLI. Then we will move into writing scripts. As we go, I will try to highlight considerations that humanists might have as we start learning the coding. One of the more interesting things, I believe, about programming is that most programming occurs because someone has a problem. For example, I have a problem that I have to transcribe a bunch of video lectures so that they have subtitles. It is a critical task, but it is also a pain. One solution to the problem is the painful task of manually transcribing the audio with my headphones and a transcription pedal. I type fast, but it is still not fun. Alternatively, I could write some code to pipe my audio files into a speech recognition engine (which itself is code) that will return the text of the speech. I could even maybe write code to put in timestamps automatically. The question that we have to answer, then, is at what point is it worth the effort to write the code to avoid the pain of transcription? How accurate must that automatic transcription system be to be worth implementing? Now, to get to the place where we can solve problems, we need to know a bit about the programming language's syntax and how to run it. That is the work of this program. We also need to be able to consider how our code can translate the real problems that humans encounter into the computations that computers can do. That is, we must figure out how to render the world into code so that the computer can help us. In this chapter, we're focusing on the basic computations that a computer can do along with the kind of data it can store. This is the first step of encoding the world. After that we'll move into more complex stuff. What is Programming? Literally, programming is the process of writing a list of commands that a computer can execute in a programming language. The programmer uses some language that the computer can either interpret or understand directly. The list of instructions is the program. Pretty simple. Most programming languages have a set of known instructions built in. For example, when we write print(\"Hello, World\") we are telling Python to use the instructions that cause the computer to write text to the terminal to write the string \"Hello, World\" to our terminal. Likewise, Python, and most programming languages, knows that 8 * 8 means that it should evaluate the integer 8 multiplied by the integer 8 and the result should be printed to the terminal. As programmers, we are given both these built in instructions and we get the opportunity to build our own sets of instructions by combining the built in ones. We can also overwrite the instructions that are part of the programming language, but for our purposes, we will not be doing that. The built in instructions are a combination of human readable words and math symbols. These words and symbols do specific things. Here is a list of the words that are part of the Python language as \"reserved words\" or words that are part of the language that you cannot use when naming new variables: and del global not with as elif if or yield assert else import pass break except in raise class finally is return continue for lambda try def from nonlocal while Python also has many built in \"functions\" or sets of instructions that accomplish a particular task. print() was an example that I used above. Likewise, the format() function allows us to format and add variables to a string. We'll talk about those in a bit, and I will not list all of the built in functions that are part of Python here as that would be too much. Instead it is better to know that built in functions exists, and when you're trying to do something new it's worth checking to see if there's already a built in function for that. Python also uses a bunch of \"math\" characters. These characters are called operators and they have special functionality in the language. Here are the major operators: +, -, *, / Addition, subtraction, multiplication, and division operators. x + y returns the sum of x and y. x**y Exponent operator. The interpreter returns x raised to the yth power x % y The modulo operator returns the remainder of x divided by y x == y Equality operator. The interpreter returns True if x and y are equal x != y Not equal. Returns True if x is not equal to y >, <, >=, <= Greater than, less than, greater than or equal to, less than or equal to. The same as math. x = y Assignment operator. NOTE: This isn't the same as math. It doesn't evaluate equality, but assigns the value of y to the variable x The first three sets of operators are used to perform calculations. The next 3 sets of operators ask the interpreter to evaluate equality and return True or False based on the evaluation. So 2 == 2 would return True, and 2 > 20 would return False. We use these to evaluate conditions and select which set of instructions to follow. The last operator = is important to pay attention to. In mathmatics, when we say 2 = 2, we are saying that \"it is true that 2 is the same value as 2.\" A statement like \"2 + 2 = 7\" would not be true or valid in Math. In Python, the equals sign is an assignment operator and it means assign the value on the right to the entity on the left. So for example x = 2 is assigning the value 2 to the variable x. When assignment happens, we evaluate the expression on the right of the equals sign before we assign the value to the variable. So, x = input(\"what is your name?\") would first ask the user for input. Then once it receives input, that input would be assigned to the variable x. I would advice against trying to memorize all of these, but instead refer back to this document or the official Python documentation if you run into syntax errors. Variables Variables are a crucial concept in programming worth taking some time to think about. Anytime we have the computer do a calculation or some action, the data that is produced by that action needs to get stored somewhere. If you recall, our computer has two sites for storage: RAM (or system memory) and Long Term Storage (SSDs HDDS, etc). If I entered the following instruction into the python interpeter: >>> 2 * 2 4 >>> input(\"What is your name? \") What is your name? Dylan 'Dylan' >>> I ask it to multiply 2 and 2. The computer complies and prints the value to the screen. Then I ask the computer to prompt me for a name. It does so and I respond with the string 'Dylan.' The interpreter then prints that value to the screen. Each time the interpeter responds, and gives me a new empty prompt, it has forgotten what data has been generated UNLESS I explicitly ask the interpreter to save the value to memory. We do this with variables. A variable is a named location in system memory (RAM). As long as our program is running and the variable is in scope (we'll explain scope later), the computer will remember the data stored in the memory location identified by that name (unless we overwrite it). A quick example: let me capture the result of 2 times two. >>> y = 2 * 2 >>> y 4 >>> A variable can store a lot of different types of data. In a moment we'll look at data types. Python allows you to change the kind of data that is stored in a variable, but don't get in the habit of doing so. In other programming languages--specifically compiled languages--you have to define the data type in advance and then it cannot change. The key thing to remember is that in the context of a script, a variable stores data from line to line. Things get a little more complicated when we build functions, but don't worry about that yet. Likewise, when we use the Python CLI, variables stick around until you close that session. What happens once you close a session? Great question: once a script is finished running our you exit the session, the variables are tagged for deletion and you won't be able to access that data anymore. Likewise, if your computer loses power, the RAM is wiped and you lose anything that was only stored in that volatile memory. So, if you want some data to be retained after a sequence of instructions, you MUST write the data to some form of long term storage: either a file or a database or something else. We still have a ways to go before we get there. You'll see variables in the next chapter, and you by no means need to master them yet. You should start thinking of them as containers for data that can store various values, hence they are variable. For example, 2 is always 2 is always 2. Likewise the string \"Dylan\" is always a series of characters, specifically \"D\" \"y\" \"l\" \"a\" \"n\". They also have a static representation in binary, which is what the computer works with. The integer 2 is equivalent to 00000010 in binary. Likewise, \"Dylan\" is equal to \"01000100 01111001 01101100 01100001 01101110\" in binary when we use the ASCII/UTF-8 encoding (or the system for converting characters into binary). However, the variable x is just a name that you tell Python to remember that points to a particular address in memory that might hold 2 or \"Dylan\" or something else. Variables can be named whatever you like as long as you're not using reserved words, they don't start with anything but letters (upper or lower case), and they don't contain spaces. Generally, the name should have something to do with what kind of data it will store. For example, if I have a variable that will hold a number value, I'll probably call it num or if I have a variable holding a first name, I'd call it first_name or fname . These are arbitrary choices. One of the stylistic rules of Python is that your code should be easy to read, and a major part of that is using logical and descriptive variable names. You can always identify a variable with a comment instead, but it's much better to identify the variable with it's own name and then you don't need a comment. Data Types Python has primitive datatypes and complex. Complex data types are combinations of primitive data types. In this section, I will only discuss primitive data types. Integer: An integer is a whole number. It can be positive or negative. When we do math with integers, like division, for instance, and the result contains a decimal, the numbers after the decimal are dropped. Float: A number with a decimal place. It offers greater precision. 8 as an integer could be anything from 8 to 8.99... whereas 8. is exactly 8. String: This is a sequence of characters. It can contain spaces, and it is always surrounded by single or double quotes (they must match). Boolean: This is the True or False value. We use this regularly when we help teach a computer to make semi-autonomous decisions. Combinging these into groups and we can get complex data types. For now, however, it is simply worth knowing that they exist. Important Note You should know exactly what type of data a variable will contain. Python allows you to create a variable that could hold several different types of data. Other languages like C++ or Java do not. This has to do with how the compiler reserves memory for the variables. While you could allow a variable to contain at times a string and at other times and integer, it is bad practice. Errors You will get errors. Whenever you program, there will be times that you make mistakes. I'm not going to go into the kinds of mistakes right now in detail, but very frequently, the Python interpreter is smart enough to identify the mistake and throw and error message at you. These error messages were written by people and they're usually pretty terse. Let's look at a couple examples: $ python Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> python --version Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'python' is not defined >>> 2 .* 2 File \"<stdin>\", line 1 2 .* 2 ^ SyntaxError: invalid syntax >>> The first error gives us a \"Traceback\" message followed by a \"NameError\". I read errors from bottom to top. The bottom is the error message. From there, the message can be read from bottom to top. If an error gets thrown as a result of a series of instructions, the traceback from the moment of error to initial call will be long. Our first instinct, perhaps, when seeing error messages is to throw our hands up and say, \"OH! It's broken! I got it wrong.\" That's a totally normal instinct but it is not super helpful, and it will leave you feeling stressed out and unhappy. Instead, think of an error message as an invitation to learn. You're trying to do a thing, but Python, as much as it wants to understand you, can't understand you. You get to learn how to make yourself understood by the Python interpreter. I even sometimes read the error messages in a silly voice to make the Python interpreter seem more friendly. Let's look at the first error message. It says, \"NameError: name 'python' is not defined.\" This is telling me that there is a problem with the word that I used. I used a word that the Python interpreter doesn't know. Specifically, the Python interpreter doesn't know the word \"python\" (ironic, I know). Now, I would be left to think, what is this \"Python\" name that I'm calling in the previous command? My command was python --version meaning I want to call the Python interpreter to give me the version number. Well, I can't call the Python interpreter from within the Python interpreter because it's already running. This means I need to make this call from a different environment. I then realize that I call the Python interpreter from Bash and I realize, oh, python --version is a Bash command, not a Python command. I fix this by exiting the Python interpeter and trying again. (env) ~/Books/Python1$ python Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> python --version Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'python' is not defined >>> exit() (env) ~/Books/Python1$ python --version Python 3.8.2 (env) ~/Books/Python1$ The next error says, \"SyntaxError: invalid syntax\" which means that I wrote the code incorrectly. That's what a syntax error means. Python is great because look, it gives us exactly where the error is: 2 .* 2 ^ I accidentally added a period. Probably just a typo. I can fix this and be on my way. >>> 2 * 2 4 >>> I'm going over errors early because you'll encounter them a lot and how you respond will determine how much you struggle and suffer in learning Python. If you panic at error messages, the learning process will be less pleasant. If you take error messages as an opportunity to learn how to communicate with Python better, then it will be a more fun, but still challenging process. Now, you will definitely get error messages that you have no idea what they mean. I usually will then copy the error message and paste it into the Google search engine and see what other people did to solve this problem. Googling for answers is how programs really get written (even by the professionals), but learning how to search and read results on Google takes some time and practice. So practice now and be prepared for that. \"Tech wiz\" types frequently are not any more intelligent than anywone else. They usually just have a bit of experience and more importantly are really good at Googling. Humanities Check-in We've just gone through a good number of basic concepts in Python. We've looked at reserved words, operators, variables, primitive data types and errors. We also discussed how programming exists to solve problems or to train computers to help us solve problems. I want to focus for a while on how this relates to human culture. I want to start at data types. Every computer system has a set of data types it is able to work with. It must because the computer can only process calculations in binary, so the data we can store must be able to be represented in binary. If you remember the UTF-8 encoding of my first name (01000100 01111001 01101100 01100001 01101110) you'll see a series of 8 bit groupings, each grouping is a sequence of 1s and 0s that represent a letter. So \"D\" is encoded into binary as 01000100 using UTF-8 encoding. There are other codes that we might use, but UTF-8 is the common one. In turn, \"Dylan\" is an alphabetic encoding of a particular sequence of sounds that we've decided represent the human sitting here typing these words right now. So you can see, perhaps, that once we start using computers to help us with our lives, we have to be able to encode elements of our lives into the binary that computers store and run operations on. This is all fine, but there are a few things to consider. When I say \"Dylan Medina\" I am using a name that represents a complex organism. Is everything I am represented by that sequence of sounds or letters on a page? Probably not. Consider being a student: one of the major complaints students have at large Universities is that they are frequently treated as a number (a student id number). This complaint stems from the fact that the students feel like they are unique and complicated individuals who have cares and interests, but the administrative system is designed to identify them as a number for registration and finance purposes, etc. The same is true in many complex human systems where we have to deal with a lot of people, and we use ID numbers for the sake of convenience. Computers take this a step further insofar as they can only deal with binary representations of stuff. So, when a student goes to an advisor in the University, the advisor can simply treat them as a number, but they can also choose to listen to the student, empathize with them, understand the possible extenuating circumstances and make moral and ethical situations based on the whole student. That would be a good advisor. A computer cannot do this unless they are explicitly programed to be able to process the data representation of the extenuating circumstances and emotions of the student and then have preprogrammed responses to that \"whole student.\" We'll discuss this further when we get to flow control, but for now, what is important is how the world surrounding any given problem we are trying to solve with a computer gets encoded into something the computer can process. This means that we must be able to render the features of the world that we care about into either primitive data types or collections of primitive data types. Some things are quite easy to encode: things that are already numeric and have regular patterns. Other things are quite difficult to encode: the illocutionary force of a particular utterance--or the implied meaning of something someone says. Likewise, when we design a system, we make decisions on what kind of data we want to store. Strings, for example, require a considerable amount of memory, as do floats. Integers require less memory. Booleans are perhaps the most memory efficient because they can be stored in one bit (0 or 1). I want to consider an example that I think is interesting. Platforms that allow users to create profiles (e.g. social media) often have a field for gender. Early in social media days, they provided two options: male and female. This is because the people designing the system probably were not versed in or concerned about the notion of gender as a spectrum or non-binary or gender non-conforming individuals. Having a binary is convenient for developers because if I were designing a system that had to store data for billions of people, I would want to be as memory efficient as possible, and if we consider gender as a binary, the logical thing to do would be to store gender not as a string (male or female) but as a bit of binary (0 for male and 1 for female, for instance). Such a storage system then would only allow for a 0 or 1 and not any other option. Of course, people reasonably got upset by these kinds of systems and public outcry has forced change in interfaces and platforms to account for a more representative set of options, but that change required a redesign of both the frontend user interface (the website) AND the database structure. That is a considerable revision. This is not so say it isn't worth doing, but the most important point is that computers have limitations in how data can be represented and developers make choices based on the various strengths and limitations of their systems on which way to represent a particular kind of data. <soapbox> Our job as Digital Humanists is to be at the table when systems are being designed because we have some sense of how computers can encode human life and the world and because we are trained in humanities and social theories. One of the major roles of digital humanitists, I believe is to participate in design and development discussions to help make sure the technology that we build is just and equitable and humane. </soapbox>","title":"Encoding Identity"},{"location":"ch3/#encoding-identity","text":"In this chapter we're going to really begin diving into Python. We'll start with a bit of review of the basic syntax using the Python CLI. Then we will move into writing scripts. As we go, I will try to highlight considerations that humanists might have as we start learning the coding. One of the more interesting things, I believe, about programming is that most programming occurs because someone has a problem. For example, I have a problem that I have to transcribe a bunch of video lectures so that they have subtitles. It is a critical task, but it is also a pain. One solution to the problem is the painful task of manually transcribing the audio with my headphones and a transcription pedal. I type fast, but it is still not fun. Alternatively, I could write some code to pipe my audio files into a speech recognition engine (which itself is code) that will return the text of the speech. I could even maybe write code to put in timestamps automatically. The question that we have to answer, then, is at what point is it worth the effort to write the code to avoid the pain of transcription? How accurate must that automatic transcription system be to be worth implementing? Now, to get to the place where we can solve problems, we need to know a bit about the programming language's syntax and how to run it. That is the work of this program. We also need to be able to consider how our code can translate the real problems that humans encounter into the computations that computers can do. That is, we must figure out how to render the world into code so that the computer can help us. In this chapter, we're focusing on the basic computations that a computer can do along with the kind of data it can store. This is the first step of encoding the world. After that we'll move into more complex stuff.","title":"Encoding Identity"},{"location":"ch3/#what-is-programming","text":"Literally, programming is the process of writing a list of commands that a computer can execute in a programming language. The programmer uses some language that the computer can either interpret or understand directly. The list of instructions is the program. Pretty simple. Most programming languages have a set of known instructions built in. For example, when we write print(\"Hello, World\") we are telling Python to use the instructions that cause the computer to write text to the terminal to write the string \"Hello, World\" to our terminal. Likewise, Python, and most programming languages, knows that 8 * 8 means that it should evaluate the integer 8 multiplied by the integer 8 and the result should be printed to the terminal. As programmers, we are given both these built in instructions and we get the opportunity to build our own sets of instructions by combining the built in ones. We can also overwrite the instructions that are part of the programming language, but for our purposes, we will not be doing that. The built in instructions are a combination of human readable words and math symbols. These words and symbols do specific things. Here is a list of the words that are part of the Python language as \"reserved words\" or words that are part of the language that you cannot use when naming new variables: and del global not with as elif if or yield assert else import pass break except in raise class finally is return continue for lambda try def from nonlocal while Python also has many built in \"functions\" or sets of instructions that accomplish a particular task. print() was an example that I used above. Likewise, the format() function allows us to format and add variables to a string. We'll talk about those in a bit, and I will not list all of the built in functions that are part of Python here as that would be too much. Instead it is better to know that built in functions exists, and when you're trying to do something new it's worth checking to see if there's already a built in function for that. Python also uses a bunch of \"math\" characters. These characters are called operators and they have special functionality in the language. Here are the major operators: +, -, *, / Addition, subtraction, multiplication, and division operators. x + y returns the sum of x and y. x**y Exponent operator. The interpreter returns x raised to the yth power x % y The modulo operator returns the remainder of x divided by y x == y Equality operator. The interpreter returns True if x and y are equal x != y Not equal. Returns True if x is not equal to y >, <, >=, <= Greater than, less than, greater than or equal to, less than or equal to. The same as math. x = y Assignment operator. NOTE: This isn't the same as math. It doesn't evaluate equality, but assigns the value of y to the variable x The first three sets of operators are used to perform calculations. The next 3 sets of operators ask the interpreter to evaluate equality and return True or False based on the evaluation. So 2 == 2 would return True, and 2 > 20 would return False. We use these to evaluate conditions and select which set of instructions to follow. The last operator = is important to pay attention to. In mathmatics, when we say 2 = 2, we are saying that \"it is true that 2 is the same value as 2.\" A statement like \"2 + 2 = 7\" would not be true or valid in Math. In Python, the equals sign is an assignment operator and it means assign the value on the right to the entity on the left. So for example x = 2 is assigning the value 2 to the variable x. When assignment happens, we evaluate the expression on the right of the equals sign before we assign the value to the variable. So, x = input(\"what is your name?\") would first ask the user for input. Then once it receives input, that input would be assigned to the variable x. I would advice against trying to memorize all of these, but instead refer back to this document or the official Python documentation if you run into syntax errors.","title":"What is Programming?"},{"location":"ch3/#variables","text":"Variables are a crucial concept in programming worth taking some time to think about. Anytime we have the computer do a calculation or some action, the data that is produced by that action needs to get stored somewhere. If you recall, our computer has two sites for storage: RAM (or system memory) and Long Term Storage (SSDs HDDS, etc). If I entered the following instruction into the python interpeter: >>> 2 * 2 4 >>> input(\"What is your name? \") What is your name? Dylan 'Dylan' >>> I ask it to multiply 2 and 2. The computer complies and prints the value to the screen. Then I ask the computer to prompt me for a name. It does so and I respond with the string 'Dylan.' The interpreter then prints that value to the screen. Each time the interpeter responds, and gives me a new empty prompt, it has forgotten what data has been generated UNLESS I explicitly ask the interpreter to save the value to memory. We do this with variables. A variable is a named location in system memory (RAM). As long as our program is running and the variable is in scope (we'll explain scope later), the computer will remember the data stored in the memory location identified by that name (unless we overwrite it). A quick example: let me capture the result of 2 times two. >>> y = 2 * 2 >>> y 4 >>> A variable can store a lot of different types of data. In a moment we'll look at data types. Python allows you to change the kind of data that is stored in a variable, but don't get in the habit of doing so. In other programming languages--specifically compiled languages--you have to define the data type in advance and then it cannot change. The key thing to remember is that in the context of a script, a variable stores data from line to line. Things get a little more complicated when we build functions, but don't worry about that yet. Likewise, when we use the Python CLI, variables stick around until you close that session. What happens once you close a session? Great question: once a script is finished running our you exit the session, the variables are tagged for deletion and you won't be able to access that data anymore. Likewise, if your computer loses power, the RAM is wiped and you lose anything that was only stored in that volatile memory. So, if you want some data to be retained after a sequence of instructions, you MUST write the data to some form of long term storage: either a file or a database or something else. We still have a ways to go before we get there. You'll see variables in the next chapter, and you by no means need to master them yet. You should start thinking of them as containers for data that can store various values, hence they are variable. For example, 2 is always 2 is always 2. Likewise the string \"Dylan\" is always a series of characters, specifically \"D\" \"y\" \"l\" \"a\" \"n\". They also have a static representation in binary, which is what the computer works with. The integer 2 is equivalent to 00000010 in binary. Likewise, \"Dylan\" is equal to \"01000100 01111001 01101100 01100001 01101110\" in binary when we use the ASCII/UTF-8 encoding (or the system for converting characters into binary). However, the variable x is just a name that you tell Python to remember that points to a particular address in memory that might hold 2 or \"Dylan\" or something else. Variables can be named whatever you like as long as you're not using reserved words, they don't start with anything but letters (upper or lower case), and they don't contain spaces. Generally, the name should have something to do with what kind of data it will store. For example, if I have a variable that will hold a number value, I'll probably call it num or if I have a variable holding a first name, I'd call it first_name or fname . These are arbitrary choices. One of the stylistic rules of Python is that your code should be easy to read, and a major part of that is using logical and descriptive variable names. You can always identify a variable with a comment instead, but it's much better to identify the variable with it's own name and then you don't need a comment.","title":"Variables"},{"location":"ch3/#data-types","text":"Python has primitive datatypes and complex. Complex data types are combinations of primitive data types. In this section, I will only discuss primitive data types. Integer: An integer is a whole number. It can be positive or negative. When we do math with integers, like division, for instance, and the result contains a decimal, the numbers after the decimal are dropped. Float: A number with a decimal place. It offers greater precision. 8 as an integer could be anything from 8 to 8.99... whereas 8. is exactly 8. String: This is a sequence of characters. It can contain spaces, and it is always surrounded by single or double quotes (they must match). Boolean: This is the True or False value. We use this regularly when we help teach a computer to make semi-autonomous decisions. Combinging these into groups and we can get complex data types. For now, however, it is simply worth knowing that they exist. Important Note You should know exactly what type of data a variable will contain. Python allows you to create a variable that could hold several different types of data. Other languages like C++ or Java do not. This has to do with how the compiler reserves memory for the variables. While you could allow a variable to contain at times a string and at other times and integer, it is bad practice.","title":"Data Types"},{"location":"ch3/#errors","text":"You will get errors. Whenever you program, there will be times that you make mistakes. I'm not going to go into the kinds of mistakes right now in detail, but very frequently, the Python interpreter is smart enough to identify the mistake and throw and error message at you. These error messages were written by people and they're usually pretty terse. Let's look at a couple examples: $ python Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> python --version Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'python' is not defined >>> 2 .* 2 File \"<stdin>\", line 1 2 .* 2 ^ SyntaxError: invalid syntax >>> The first error gives us a \"Traceback\" message followed by a \"NameError\". I read errors from bottom to top. The bottom is the error message. From there, the message can be read from bottom to top. If an error gets thrown as a result of a series of instructions, the traceback from the moment of error to initial call will be long. Our first instinct, perhaps, when seeing error messages is to throw our hands up and say, \"OH! It's broken! I got it wrong.\" That's a totally normal instinct but it is not super helpful, and it will leave you feeling stressed out and unhappy. Instead, think of an error message as an invitation to learn. You're trying to do a thing, but Python, as much as it wants to understand you, can't understand you. You get to learn how to make yourself understood by the Python interpreter. I even sometimes read the error messages in a silly voice to make the Python interpreter seem more friendly. Let's look at the first error message. It says, \"NameError: name 'python' is not defined.\" This is telling me that there is a problem with the word that I used. I used a word that the Python interpreter doesn't know. Specifically, the Python interpreter doesn't know the word \"python\" (ironic, I know). Now, I would be left to think, what is this \"Python\" name that I'm calling in the previous command? My command was python --version meaning I want to call the Python interpreter to give me the version number. Well, I can't call the Python interpreter from within the Python interpreter because it's already running. This means I need to make this call from a different environment. I then realize that I call the Python interpreter from Bash and I realize, oh, python --version is a Bash command, not a Python command. I fix this by exiting the Python interpeter and trying again. (env) ~/Books/Python1$ python Python 3.8.2 (default, Jul 16 2020, 14:00:26) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> python --version Traceback (most recent call last): File \"<stdin>\", line 1, in <module> NameError: name 'python' is not defined >>> exit() (env) ~/Books/Python1$ python --version Python 3.8.2 (env) ~/Books/Python1$ The next error says, \"SyntaxError: invalid syntax\" which means that I wrote the code incorrectly. That's what a syntax error means. Python is great because look, it gives us exactly where the error is: 2 .* 2 ^ I accidentally added a period. Probably just a typo. I can fix this and be on my way. >>> 2 * 2 4 >>> I'm going over errors early because you'll encounter them a lot and how you respond will determine how much you struggle and suffer in learning Python. If you panic at error messages, the learning process will be less pleasant. If you take error messages as an opportunity to learn how to communicate with Python better, then it will be a more fun, but still challenging process. Now, you will definitely get error messages that you have no idea what they mean. I usually will then copy the error message and paste it into the Google search engine and see what other people did to solve this problem. Googling for answers is how programs really get written (even by the professionals), but learning how to search and read results on Google takes some time and practice. So practice now and be prepared for that. \"Tech wiz\" types frequently are not any more intelligent than anywone else. They usually just have a bit of experience and more importantly are really good at Googling.","title":"Errors"},{"location":"ch3/#humanities-check-in","text":"We've just gone through a good number of basic concepts in Python. We've looked at reserved words, operators, variables, primitive data types and errors. We also discussed how programming exists to solve problems or to train computers to help us solve problems. I want to focus for a while on how this relates to human culture. I want to start at data types. Every computer system has a set of data types it is able to work with. It must because the computer can only process calculations in binary, so the data we can store must be able to be represented in binary. If you remember the UTF-8 encoding of my first name (01000100 01111001 01101100 01100001 01101110) you'll see a series of 8 bit groupings, each grouping is a sequence of 1s and 0s that represent a letter. So \"D\" is encoded into binary as 01000100 using UTF-8 encoding. There are other codes that we might use, but UTF-8 is the common one. In turn, \"Dylan\" is an alphabetic encoding of a particular sequence of sounds that we've decided represent the human sitting here typing these words right now. So you can see, perhaps, that once we start using computers to help us with our lives, we have to be able to encode elements of our lives into the binary that computers store and run operations on. This is all fine, but there are a few things to consider. When I say \"Dylan Medina\" I am using a name that represents a complex organism. Is everything I am represented by that sequence of sounds or letters on a page? Probably not. Consider being a student: one of the major complaints students have at large Universities is that they are frequently treated as a number (a student id number). This complaint stems from the fact that the students feel like they are unique and complicated individuals who have cares and interests, but the administrative system is designed to identify them as a number for registration and finance purposes, etc. The same is true in many complex human systems where we have to deal with a lot of people, and we use ID numbers for the sake of convenience. Computers take this a step further insofar as they can only deal with binary representations of stuff. So, when a student goes to an advisor in the University, the advisor can simply treat them as a number, but they can also choose to listen to the student, empathize with them, understand the possible extenuating circumstances and make moral and ethical situations based on the whole student. That would be a good advisor. A computer cannot do this unless they are explicitly programed to be able to process the data representation of the extenuating circumstances and emotions of the student and then have preprogrammed responses to that \"whole student.\" We'll discuss this further when we get to flow control, but for now, what is important is how the world surrounding any given problem we are trying to solve with a computer gets encoded into something the computer can process. This means that we must be able to render the features of the world that we care about into either primitive data types or collections of primitive data types. Some things are quite easy to encode: things that are already numeric and have regular patterns. Other things are quite difficult to encode: the illocutionary force of a particular utterance--or the implied meaning of something someone says. Likewise, when we design a system, we make decisions on what kind of data we want to store. Strings, for example, require a considerable amount of memory, as do floats. Integers require less memory. Booleans are perhaps the most memory efficient because they can be stored in one bit (0 or 1). I want to consider an example that I think is interesting. Platforms that allow users to create profiles (e.g. social media) often have a field for gender. Early in social media days, they provided two options: male and female. This is because the people designing the system probably were not versed in or concerned about the notion of gender as a spectrum or non-binary or gender non-conforming individuals. Having a binary is convenient for developers because if I were designing a system that had to store data for billions of people, I would want to be as memory efficient as possible, and if we consider gender as a binary, the logical thing to do would be to store gender not as a string (male or female) but as a bit of binary (0 for male and 1 for female, for instance). Such a storage system then would only allow for a 0 or 1 and not any other option. Of course, people reasonably got upset by these kinds of systems and public outcry has forced change in interfaces and platforms to account for a more representative set of options, but that change required a redesign of both the frontend user interface (the website) AND the database structure. That is a considerable revision. This is not so say it isn't worth doing, but the most important point is that computers have limitations in how data can be represented and developers make choices based on the various strengths and limitations of their systems on which way to represent a particular kind of data. <soapbox> Our job as Digital Humanists is to be at the table when systems are being designed because we have some sense of how computers can encode human life and the world and because we are trained in humanities and social theories. One of the major roles of digital humanitists, I believe is to participate in design and development discussions to help make sure the technology that we build is just and equitable and humane. </soapbox>","title":"Humanities Check-in"},{"location":"ch4/","text":"Really getting into Python Now In the last chapter we discussed Python in pretty abstract terms. In this chapter, we are going to start using it and applying some of those abstract concepts. I'm going to first show you a bit about the interpreter. Then I'm going to show you the anatomy of a Python script, and finally, we'll build a simple Python program that helps us convert speed limits. I recommend you follow along as we go. Start in the interpreter I like to start playing with Python in the interpreter. This section will be pretty short, but I'll give you a bunch of lines in Python, which you should try for yourself. Then I'll translate those lines into plain English. >>> print(\"Hello, Dylan\") Hello, Dylan >>> 2 * 2 4 >>> 2 + 2 * 27 56 >>> 2 - 2 0 >>> 12 % 5 2 >>> 12 % 2 0 >>> 13 % 2 1 >>> 12 % 2 == 0 True >>> x = 27 >>> x % 2 == 0 False >>> input(\"What is your name\") What is your nameDylan 'Dylan' >>> n = input(\"What is your name? \") What is your name? Dylan >>> n 'Dylan' >>> print(\"Hello, \" + n) Hello, Dylan >>> n == \"Dylan\" True Me: Please print \"Hello, Dylan\" Python Interpreter (PI): Hello, Dylan Me: Calculate the product of 2 and 2 PI: 4 Me: Calculate the sum of 2 and 2 times 27 ( Note: Order of operations is PEMDAS just like in math). PI: 56 (Not 108) Me: Calculate 2 minus 2 PI: 0 Me: Calculate the remainder of 12 divided by 5 PI: 2 Me: Calculate the remainder of 12 divided by 2 PI: 0 Me: Calculate the remainder of 13 divided by 2 PI: 1 Me: Evaluate if the remainder of 12 divided by 2 is 0 PI: True (The remainder of 12 divided by 2 is 0) Me: Create a variable called 'x' and assign the value 27 to it PI: (Done) Me: Evaluate if the remainder of the value stored in the variable x divided by 2 is 0 ( Note: This is a really cool way to check if a number is even or not) PI: False Me: Prompt the user for some input with the prompt \"What is your name\" PI: What is your name (Waits for a response) Me: Dylan PI: Your input was Dylan Me: Create a variable called 'n' and prompt the user for input with the prompt \"What is your name? \" and when they respond store that response to the variable n. PI: *What is your name? * (Waits for a response) Me: Dylan PI: (Stores 'Dylan' to the variable n) Me: What's n? PI: Dylan Me: Print the string \"Hello, \" plus whatever value is stored in 'n' PI: Hello, Dylan Me: *Evaluate if the value stored in 'n' is 'Dylan' PI: 'True' That's all pretty much straightforward. You'll notice I added some notes in the parentheses to explain what's going on. Of course, the Python CLI is cool, but once we exit out of it, all the work we did was lost unless we explicitly saved stuff to a file. Wouldn't it be nice if we could write a set of commands that could be run over and over again without having to type them in manually each time? Yes, indeed! That's where Python scripts come in to play. The Anatomy of a Python Script While we can issue Python commands directly to the Python interpreter in the Python Terminal, we can also write Python to a file that the interpreter will execute. A few things to know: Python files are text files with the file extension .py. A file extension is like .docx or .pdf. They tell the computer what type of file this is. Python files contain a sequence of instructions that are executed in the order they are written. When we execute a Python program, we call the file in Bash using the Python program. Next, the general layout of a Python program is as follows: test.py #!/usr/bin/env python3 # This is a comment. Any line beginning with a hashtag is # ignored by the interpreter. # At the top of our file we usually have import statements # if any. import requests # Next we will have our instructions. In more complicated # programs these will usually reside in Functions, or # reusible bundles of code. I'll give you an example of # that here. def website_checker(url): r = requests.get(url) if r.status_code == 200: return True return False # The instructions section is usually quite long. # Finally, we *might* have a driver section, or the section # that calls the functions if there are functions. if __name__ == \"__main__\": print(website_checker('https://www.google.com')) In the above program, I have demonstrated the general format of a python script. The very first line is the shebang line. It is not required, but frequently is included in standalone scripts. It serves two purposes: It allows you to run the script without invoking Python first. Instead of typing $ python3 my_script.py the shebang line allows you to simply type $ ./my_script.py to run the script. The Shebang line tells Bash which program to use to interpret the code. It tells someone who reads your code what interpreter this code was written for. The shebang line is not usually included in multifile programs, and I usually only include it in small, utility scripts that I write. Also, if we use the virtual environment, we can run into trouble because if you look closely, the shebang line tries to use the most recent Python 3 executable in the global environment. Support for pointing to the executable in the virtual environment in the shebang line ( #!env/bin/ python3 ) is not recommended practice. So likewise, if I'm writing a program that uses a virtual environment, I'll usually also leave off the shebang. Next, we import any libraries at the top. In this case, I've imported the library that allows me to request data from websites. Note: Sometimes we wait to import libraries until later. We'll discuss this later. The second section is where we have the instructions of our program. This is the code that tells the computer what we want it to do. Frequently the instruction section will contain functions, which we discuss in a couple chapters. Sometimes, the instructions are executed on the fly rather than stored in a function. Finally, the driver section exists if you need to call those functions. In larger programs, the driver section is frequently a separate file, and you might actually have a bunch of different files that are make up different parts of your program, but more on that later. Building a Python Program For this chapter, we're going to start with a script that just contains the instructions section without any imports. For my example, I'm going to create a calculator that will allow the user to convert between Kilometers per hour (KPH) and Miles per hour (MPH). Now this is a real problem, perhaps for someone who is accustomed to driving in the USA and is moving to Canada or Europe. How fast is 100KPH really? The first step is to break down the problem. This is called decomposition . I will decompose the problem into a series of steps that the computer needs to help me solve. The program needs to know the original unit and the converted unit. So, I need to know if we're going from MPH to KPH or KPH to MPH. The program needs to know the original value. Is it 60? 100? 80? The program needs to contain the calculations in both directions. I'll look those up on Google. Based on the information the program needs to know, it will have two variables: the original unit and the original value. Now I'm going to write up what is called a user story. This is part of the Agile software development paradigm, and it is the story of a user interacting with the program. My name is John, and I occasionally drive my vehicle from the United States to Canada. When I am there, I have a hard time with the speed limit conversion. So, I open the program, and it prompts me whether I want to convert FROM KPH or MPH. I am in Canada, so I need to convert from KPH to MPH. The program then prompts me for the speed limit. I enter it, and it prints out the speed limit in MPH. I really don't want to worry about decimals, so I need to make sure it rounds. Ok, now that I have a sense of what the program needs to do, I need to create a file to hold this script. First I create a project directory and a file to hold my code. I'm not going to worry about a virtual environment because I don't anticipate this is going to be a very large project. Then I need to open the directory with VS Code. ~$ mkdir speed && cd speed ~/speed/$ touch speed_converter.py ~/speed/$ ls speed_converter.py ~/speed/$ code . The first command, again, creates a directory and changes into that directory. The second command creates the file called speed_converter.py. It is a python script. The name is arbitrary but logical. Next, I use the ls command to show you that the file was created. I wouldn't probably actually do this in real life, and it's not necessary to check every time you create a file. You can always do it if you want, but not required. Finally, I open VS Code with the code command. I pass that command an argument: . which means open the local directory. A VS Code window opens and I click on my python script in the file explorer pane to open it in the text editor pane. You'll see it is empty, so I'm going to start writing in a bunch of comments to help me code. speed_converter.py #!/usr/bin/env python3 # Prompt user for original limit and save to variable. # Prompt user for original value and save to variable. # If the original limit is KPH use this expression. # output = value * 0.62137 # If the original limit is MPH use this expression. # output = value * 1.60934 # convert output to integer # print output Okay, so I now have all the steps that I need my program to take. I will walk through each of these and turn them into code. For the book here, I will do them all at once, but in practice, I go through step by step. If I don't know how to do something, I will search for it on Google. For instance, if I don't know how to get input from a user, I might search for \"get user input in python3\". speed_converter.py #!/usr/bin/env python3 # Prompt user for original units and save to variable. units = input(\"Are you converting from KPH to MPH? (Y/n)\") # Prompt user for original value and save to variable. value = input(\"What is the original speed limit? \") # If the original limit is KPH use this expression. if units != \"n\" or units != \"N\": output = value * 0.62137 # If the original limit is MPH use this expression. if units == \"n\" or units == \"N\": output = value * 1.60934 # convert output to integer output = int(output) # print output print(output) Okay, so I have workable code. I can run it now and see how it works. $python3 speed_converter.py Are you converting from KPH to MPH? (Y/n)Y What is the original speed limit? 100 Traceback (most recent call last): File \"speed_converter.py\", line 9, in <module> output = value * 0.62137 TypeError: can't multiply sequence by non-int of type 'float' Ok, so I have an error. I need to look at the error. I see that I have a type error, which means that my data in the expression output = value * 0.62137 is the wrong type. The issue is either with value or the floating point number. I'm guessing it is probably the value because I know that I can multiply integers with floats. I need to look at the input() function and see what kind of data is getting stored in value when I get data from the user. You can look it up if you like. Welcome back. The problem, of course, is that input() returns a string. This means that the data type stored in value is a string. I know that strings cannot be multiplied by decimals. Instead, I need to convert whatever I'm getting from the input function from a string to a float or integer. Let's do some revision, or refactoring of the code. I'm also going to adjust a couple other things with my logic checks at the same time. speed_converter.py #!/usr/bin/env python3 # Prompt user for original units and save to variable. units = input(\"Are you converting from KPH to MPH? (Y/n)\") # Prompt user for original value and save to variable. value = int(input(\"What is the original speed limit? \")) # If the original limit is MPH use this expression. if units == \"n\" or units == \"N\": output = value * 1.60934 # If the original limit is KPH use this expression. else: output = value * 0.62137 # convert output to integer output = int(output) # print output print(output) Now we run it again and see that it works this time. $ python3 speed_converter.py Are you converting from KPH to MPH? (Y/n)y What is the original speed limit? 100 62 I'll quickly walk through the code. Line one is the shebang line, but since I run the script with the python interpreter from my command, I don't need this. Line two prompts the user for input. I let them know that the default is \"Y\" for KPH to MPH. Line three prompts the user for the original speed limit and immediately converts their response to an integer. Line four checks if the user entered either \"n\" or \"N\" into the prompt on line two. If so, we're converting from MPH to KPH. The calculation is run. Line 6 is \"else\" which is the default condition if the user didn't enter \"n\" or \"N\". In that case, we calculate from KPH to MPH. Finally, regardless we convert from the floating point value in output to an integer so that we don't have to worry about a decimal, and print out the results. So that's your first Python script that does some decision making. In the next chapters we'll dive into decision making, but for now, you can see we have already built a pretty cool program that could be applied to any sort of conversion problem. In the next section, as we discuss conditions there will be a great deal to say regarding concerns of the Humanities and human culture. Until then, practice and enjoy! Can you maybe modify our code to convert for something else (currency? temperature? etc.)","title":"Anatomy of a Script"},{"location":"ch4/#really-getting-into-python-now","text":"In the last chapter we discussed Python in pretty abstract terms. In this chapter, we are going to start using it and applying some of those abstract concepts. I'm going to first show you a bit about the interpreter. Then I'm going to show you the anatomy of a Python script, and finally, we'll build a simple Python program that helps us convert speed limits. I recommend you follow along as we go.","title":"Really getting into Python Now"},{"location":"ch4/#start-in-the-interpreter","text":"I like to start playing with Python in the interpreter. This section will be pretty short, but I'll give you a bunch of lines in Python, which you should try for yourself. Then I'll translate those lines into plain English. >>> print(\"Hello, Dylan\") Hello, Dylan >>> 2 * 2 4 >>> 2 + 2 * 27 56 >>> 2 - 2 0 >>> 12 % 5 2 >>> 12 % 2 0 >>> 13 % 2 1 >>> 12 % 2 == 0 True >>> x = 27 >>> x % 2 == 0 False >>> input(\"What is your name\") What is your nameDylan 'Dylan' >>> n = input(\"What is your name? \") What is your name? Dylan >>> n 'Dylan' >>> print(\"Hello, \" + n) Hello, Dylan >>> n == \"Dylan\" True Me: Please print \"Hello, Dylan\" Python Interpreter (PI): Hello, Dylan Me: Calculate the product of 2 and 2 PI: 4 Me: Calculate the sum of 2 and 2 times 27 ( Note: Order of operations is PEMDAS just like in math). PI: 56 (Not 108) Me: Calculate 2 minus 2 PI: 0 Me: Calculate the remainder of 12 divided by 5 PI: 2 Me: Calculate the remainder of 12 divided by 2 PI: 0 Me: Calculate the remainder of 13 divided by 2 PI: 1 Me: Evaluate if the remainder of 12 divided by 2 is 0 PI: True (The remainder of 12 divided by 2 is 0) Me: Create a variable called 'x' and assign the value 27 to it PI: (Done) Me: Evaluate if the remainder of the value stored in the variable x divided by 2 is 0 ( Note: This is a really cool way to check if a number is even or not) PI: False Me: Prompt the user for some input with the prompt \"What is your name\" PI: What is your name (Waits for a response) Me: Dylan PI: Your input was Dylan Me: Create a variable called 'n' and prompt the user for input with the prompt \"What is your name? \" and when they respond store that response to the variable n. PI: *What is your name? * (Waits for a response) Me: Dylan PI: (Stores 'Dylan' to the variable n) Me: What's n? PI: Dylan Me: Print the string \"Hello, \" plus whatever value is stored in 'n' PI: Hello, Dylan Me: *Evaluate if the value stored in 'n' is 'Dylan' PI: 'True' That's all pretty much straightforward. You'll notice I added some notes in the parentheses to explain what's going on. Of course, the Python CLI is cool, but once we exit out of it, all the work we did was lost unless we explicitly saved stuff to a file. Wouldn't it be nice if we could write a set of commands that could be run over and over again without having to type them in manually each time? Yes, indeed! That's where Python scripts come in to play.","title":"Start in the interpreter"},{"location":"ch4/#the-anatomy-of-a-python-script","text":"While we can issue Python commands directly to the Python interpreter in the Python Terminal, we can also write Python to a file that the interpreter will execute. A few things to know: Python files are text files with the file extension .py. A file extension is like .docx or .pdf. They tell the computer what type of file this is. Python files contain a sequence of instructions that are executed in the order they are written. When we execute a Python program, we call the file in Bash using the Python program. Next, the general layout of a Python program is as follows: test.py #!/usr/bin/env python3 # This is a comment. Any line beginning with a hashtag is # ignored by the interpreter. # At the top of our file we usually have import statements # if any. import requests # Next we will have our instructions. In more complicated # programs these will usually reside in Functions, or # reusible bundles of code. I'll give you an example of # that here. def website_checker(url): r = requests.get(url) if r.status_code == 200: return True return False # The instructions section is usually quite long. # Finally, we *might* have a driver section, or the section # that calls the functions if there are functions. if __name__ == \"__main__\": print(website_checker('https://www.google.com')) In the above program, I have demonstrated the general format of a python script. The very first line is the shebang line. It is not required, but frequently is included in standalone scripts. It serves two purposes: It allows you to run the script without invoking Python first. Instead of typing $ python3 my_script.py the shebang line allows you to simply type $ ./my_script.py to run the script. The Shebang line tells Bash which program to use to interpret the code. It tells someone who reads your code what interpreter this code was written for. The shebang line is not usually included in multifile programs, and I usually only include it in small, utility scripts that I write. Also, if we use the virtual environment, we can run into trouble because if you look closely, the shebang line tries to use the most recent Python 3 executable in the global environment. Support for pointing to the executable in the virtual environment in the shebang line ( #!env/bin/ python3 ) is not recommended practice. So likewise, if I'm writing a program that uses a virtual environment, I'll usually also leave off the shebang. Next, we import any libraries at the top. In this case, I've imported the library that allows me to request data from websites. Note: Sometimes we wait to import libraries until later. We'll discuss this later. The second section is where we have the instructions of our program. This is the code that tells the computer what we want it to do. Frequently the instruction section will contain functions, which we discuss in a couple chapters. Sometimes, the instructions are executed on the fly rather than stored in a function. Finally, the driver section exists if you need to call those functions. In larger programs, the driver section is frequently a separate file, and you might actually have a bunch of different files that are make up different parts of your program, but more on that later.","title":"The Anatomy of a Python Script"},{"location":"ch4/#building-a-python-program","text":"For this chapter, we're going to start with a script that just contains the instructions section without any imports. For my example, I'm going to create a calculator that will allow the user to convert between Kilometers per hour (KPH) and Miles per hour (MPH). Now this is a real problem, perhaps for someone who is accustomed to driving in the USA and is moving to Canada or Europe. How fast is 100KPH really? The first step is to break down the problem. This is called decomposition . I will decompose the problem into a series of steps that the computer needs to help me solve. The program needs to know the original unit and the converted unit. So, I need to know if we're going from MPH to KPH or KPH to MPH. The program needs to know the original value. Is it 60? 100? 80? The program needs to contain the calculations in both directions. I'll look those up on Google. Based on the information the program needs to know, it will have two variables: the original unit and the original value. Now I'm going to write up what is called a user story. This is part of the Agile software development paradigm, and it is the story of a user interacting with the program. My name is John, and I occasionally drive my vehicle from the United States to Canada. When I am there, I have a hard time with the speed limit conversion. So, I open the program, and it prompts me whether I want to convert FROM KPH or MPH. I am in Canada, so I need to convert from KPH to MPH. The program then prompts me for the speed limit. I enter it, and it prints out the speed limit in MPH. I really don't want to worry about decimals, so I need to make sure it rounds. Ok, now that I have a sense of what the program needs to do, I need to create a file to hold this script. First I create a project directory and a file to hold my code. I'm not going to worry about a virtual environment because I don't anticipate this is going to be a very large project. Then I need to open the directory with VS Code. ~$ mkdir speed && cd speed ~/speed/$ touch speed_converter.py ~/speed/$ ls speed_converter.py ~/speed/$ code . The first command, again, creates a directory and changes into that directory. The second command creates the file called speed_converter.py. It is a python script. The name is arbitrary but logical. Next, I use the ls command to show you that the file was created. I wouldn't probably actually do this in real life, and it's not necessary to check every time you create a file. You can always do it if you want, but not required. Finally, I open VS Code with the code command. I pass that command an argument: . which means open the local directory. A VS Code window opens and I click on my python script in the file explorer pane to open it in the text editor pane. You'll see it is empty, so I'm going to start writing in a bunch of comments to help me code. speed_converter.py #!/usr/bin/env python3 # Prompt user for original limit and save to variable. # Prompt user for original value and save to variable. # If the original limit is KPH use this expression. # output = value * 0.62137 # If the original limit is MPH use this expression. # output = value * 1.60934 # convert output to integer # print output Okay, so I now have all the steps that I need my program to take. I will walk through each of these and turn them into code. For the book here, I will do them all at once, but in practice, I go through step by step. If I don't know how to do something, I will search for it on Google. For instance, if I don't know how to get input from a user, I might search for \"get user input in python3\". speed_converter.py #!/usr/bin/env python3 # Prompt user for original units and save to variable. units = input(\"Are you converting from KPH to MPH? (Y/n)\") # Prompt user for original value and save to variable. value = input(\"What is the original speed limit? \") # If the original limit is KPH use this expression. if units != \"n\" or units != \"N\": output = value * 0.62137 # If the original limit is MPH use this expression. if units == \"n\" or units == \"N\": output = value * 1.60934 # convert output to integer output = int(output) # print output print(output) Okay, so I have workable code. I can run it now and see how it works. $python3 speed_converter.py Are you converting from KPH to MPH? (Y/n)Y What is the original speed limit? 100 Traceback (most recent call last): File \"speed_converter.py\", line 9, in <module> output = value * 0.62137 TypeError: can't multiply sequence by non-int of type 'float' Ok, so I have an error. I need to look at the error. I see that I have a type error, which means that my data in the expression output = value * 0.62137 is the wrong type. The issue is either with value or the floating point number. I'm guessing it is probably the value because I know that I can multiply integers with floats. I need to look at the input() function and see what kind of data is getting stored in value when I get data from the user. You can look it up if you like. Welcome back. The problem, of course, is that input() returns a string. This means that the data type stored in value is a string. I know that strings cannot be multiplied by decimals. Instead, I need to convert whatever I'm getting from the input function from a string to a float or integer. Let's do some revision, or refactoring of the code. I'm also going to adjust a couple other things with my logic checks at the same time. speed_converter.py #!/usr/bin/env python3 # Prompt user for original units and save to variable. units = input(\"Are you converting from KPH to MPH? (Y/n)\") # Prompt user for original value and save to variable. value = int(input(\"What is the original speed limit? \")) # If the original limit is MPH use this expression. if units == \"n\" or units == \"N\": output = value * 1.60934 # If the original limit is KPH use this expression. else: output = value * 0.62137 # convert output to integer output = int(output) # print output print(output) Now we run it again and see that it works this time. $ python3 speed_converter.py Are you converting from KPH to MPH? (Y/n)y What is the original speed limit? 100 62 I'll quickly walk through the code. Line one is the shebang line, but since I run the script with the python interpreter from my command, I don't need this. Line two prompts the user for input. I let them know that the default is \"Y\" for KPH to MPH. Line three prompts the user for the original speed limit and immediately converts their response to an integer. Line four checks if the user entered either \"n\" or \"N\" into the prompt on line two. If so, we're converting from MPH to KPH. The calculation is run. Line 6 is \"else\" which is the default condition if the user didn't enter \"n\" or \"N\". In that case, we calculate from KPH to MPH. Finally, regardless we convert from the floating point value in output to an integer so that we don't have to worry about a decimal, and print out the results. So that's your first Python script that does some decision making. In the next chapters we'll dive into decision making, but for now, you can see we have already built a pretty cool program that could be applied to any sort of conversion problem. In the next section, as we discuss conditions there will be a great deal to say regarding concerns of the Humanities and human culture. Until then, practice and enjoy! Can you maybe modify our code to convert for something else (currency? temperature? etc.)","title":"Building a Python Program"},{"location":"ch5/","text":"Conditionals Introduction to Flow Control Thus far, we've basically told the computer what to do and it has done it basically as we requested. However, in programming, one of our goals is to turn over more of the work to computers. We saw this a little bit with our speed conversion program. Instead of writing two different programs, one for MPH to KPH and another for KPH to MPH, we wrote one program with a decision in it that allowed the computer to decide which calculation to perform based on the user's input. This ability of a computer to make decisions based on input is a central part of flow control . Flow control refers to the controls that we build into our program that tell the computer when and how many times to execute a particular group of instructions. There are two separate parts of flow control: conditionals, which tell the computer to execute instructions based on a set of conditions, and iterators or loops, which tell the computer to execute instructions while a particular condition is true or for a particular number of times. In this chapter, we'll look at the first. In the next chapter we'll look at the second. Conditionals: An example To set the stage, let's say my user wants to figure out if one number is a factor of another number. A number is a factor if the second number can be divided evenly by the first. So, 4 is a factor of 12 because 12 can be evenly divided by 4. Programming languages give us the % (mod) operator to help us out with that. So let me write the program. It will prompt the user for two numbers. It will print \"x is a factor of y\" if the second number is a factor, and \"Is not a factor\" if not. mult = int(input(\"What is the multiple? \")) fact = int(input(\"What is the factor to check? \")) if mult % fact == 0: print(\"{} is a factor of {}\".format(fact, mult)) else: print(\"{} is NOT a factor of {}\".format(fact, mult)) When we run this program from our bash terminal we get something like this: ~$ python factor.py What is the multiple? 12 What is the factor to check? 4 4 is a factor of 12 ~$ Then we can run it again with something we know should be false: ~$ python factor.py What is the multiple? 12 What is the factor to check? 5 5 is NOT a factor of 12 ~$ What's going on here? On our first two lines, we're prompting the user for input and storing those values to two separate variables. Then we use an \"if\" statement to check to see if the remainder of multi / fact is zero. If this is true, then we execute the code on the next line (line 5). Otherwise, we skip down to the \"else\" statement and execute that instruction. We can see, then, the first time we run the code, 12 / 4 has a remainder of 0, so the condition in the \"if\" statement is True. So you see the appropriate instruction is executed. On the other hand, in the second run of our code, 12 / 5 does have a remainder that is not equal to zero (it is equal to 2 specifically). As a result, the statement evaluates to False and we do not execute the code within the \"if\" block. Instead, we go down to the \"else\" and execute that code instead. Notice the instructions on the lines after if and else are indented one level. This signifies to the Python interpreter that they are part of the if or else block. A code block is a collection of code that only gets executed if some condition is met. In this case, the if block only gets executed when the condition we defined for if is True. Otherwise, the else block is executed. Regardless of the input (as long as it is valid input), either the if block will execute or the else block, but never both. We can also set up conditions with only an if block. Let's say we want a program to print \"Happy Birthday\" on a user's Birthday and not print anything else if it is not. That code would look like this: BIRTHDAY = \"05/02\" today = input(\"What is the date today (mm/dd)? \") if BIRTHDAY == today: print(\"Happy Birthday!\") Once again, I'll show you what it looks like when we run this code: ~$ python birthday.py What is the date today (mm/dd)? 05/02 Happy Birthday! ~$ python birthday.py What is the date today (mm/dd)? 03/12 ~$ I set BIRTHDAY as a constant value. Then the program prompts the user for the date with a hint at the format. I check to see if what the user entered matches or is equal to the value stored in BIRTHDAY . If it is, then the program prints \"Happy Birthday!\" and if it is not, then it does nothing. Once again, I show you what that looks like when we run the program in both cases. Sometimes it is useful to have code that only runs when a condition is satisfied. We can also use negative conditions, so if we wanted to congratulate the user that it's not their birthday, we'd need to change our condition to be if BIRTHDAY != today: . Finally, we can set a series of conditions. Perhaps we want to help someone who is trying to decide whether to wear a jacket or not based on the temperature: temp = int(input(\"What is the temperature? \")) if temp > 70: print(\"Wear Shorts\") elif temp > 50: print(\"Pants and a wind breaker\") elif temp > 40: print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") In the above example, we have 4 conditions: warmer than 70 degrees, warmer than 50 degrees, warmer than 40 degrees, or colder than 40 degrees. This leads us to a cool design decision. In the if/elif/else or if/else structure only one of the blocks will be executed. Specifically, the first time the condition is True, the corresponding block is executed and the rest are skipped. So, in the above example, if the user inputs 75, only the first block will execute. It is true that 75 is also greater than 50 and 40, but Python stops at the first True condition and once we have a True condition none of the other blocks are executed. As a design decision, this allows us to check for warmer than 70, 50, and 40 without having to say elif temp > 50 and temp <= 70: for the second condition. We know that if the Python interpreter is even evaluating that condition, then the first condition failed and the temperature is 70 or less. The else acts as a fall through condition. If none of the specific cases is True, then the else block is executed. As you design your conditionals, you will find clever ways to short circuit the way you test truthiness that can make your code more efficient. Related to this, we can also test multiple conditions at the same time. For example, let's take our code from the last example and add a prompt for the rain. temp = int(input(\"What is the temperature? \")) rain = input(\"Are you expecting it to precipitate?(y/n) \") if temp > 70 and rain == \"n\": print(\"Wear Shorts\") elif temp > 50 and rain == \"n\": print(\"Pants and a wind breaker\") elif temp > 40 or rain == \"y\": print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") You can see that we are testing two conditions each time. In the first two cases we use the key word and which means that the whole test or condition is True if--and only if--both conditions are true. In the third case, we use the key word or which means that at least one of the conditions must evaluate to True. So if it is warmer than 40 or it's raining or both, the code block is executed. There are other logical operators that can be used but mainly if we are testing truthiness for bits. I'll have a section at the end of this chapter discussing bitwise operations, but you can skip it if you're not interested. Finally, we can \"nest\" our conditions within conditions. Sometimes this is more efficient than having a bunch of conditions with multiple logic tests. For example, I might like to refactor my code again so there are fewer logic tests: temp = int(input(\"What is the temperature? \")) rain = input(\"Are you expecting it to precipitate?(y/n) \") if rain == \"y\": print(\"Maybe a raincoat\") else: if temp > 70: print(\"Wear Shorts\") elif temp > 50: print(\"Pants and a wind breaker\") elif temp > 40: print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") You hopefully notice that there are several different ways to do things. Generally the way that is the most clear is the best in Python. In this case, we know that regardless, if it is raining, the program should tell the user to wear a raincoat, so there's no point in wasting the processing power checking the rest of the conditions. We simply short circuit the if/else structure if it happens to be raining. Now that you have a sense of these structures, I'm going to talk a bit about Booleans. Booleans Booleans are a primitive data type that is either True or False. Whenever we use a conditional, the condition returns a True or a False value. So 9 == 10 in Python asks the interpreter to assess whether nine equals ten. Obviously, this is not true so Python will return False. This is a particular type of data and False is not the same as the string \"False\". This data type is important to understand because it is the fundamental operation of the computer. At the level of the hardware, all of the operations of the computer are computed through boolean logic comparing binary bits. We can manipulate bits directly with Python using bitwise operators, and frequently the operation is much faster, but for our purposes here, we're not going to worry too much about that. Instead, we're going to focus on True and False and expressions that evaluate to True and False. True and False are the primitive data type for booleans, but other things can be evaluated by True and False through Truthiness tests. Here is a table of some examples: Expression Boolean True True False False 1 == 1 True 1 == 2 False 1 != 2 True \"\" False (empty strings are false) \"a\" True 0 False 1 True 8 > 6 True And so on. As you design your programs and work with control, you will write code that evaluates conditions. These conditions will evaluate to True or False, and the code will execute the block that corresponds to the passing test. The key take away besides the syntax is to recognize that you'll want to spend some time thinking about what conditions you want to evaluate and then what should happen when those conditions evaluate to a certain boolean value.","title":"Conditions"},{"location":"ch5/#conditionals","text":"","title":"Conditionals"},{"location":"ch5/#introduction-to-flow-control","text":"Thus far, we've basically told the computer what to do and it has done it basically as we requested. However, in programming, one of our goals is to turn over more of the work to computers. We saw this a little bit with our speed conversion program. Instead of writing two different programs, one for MPH to KPH and another for KPH to MPH, we wrote one program with a decision in it that allowed the computer to decide which calculation to perform based on the user's input. This ability of a computer to make decisions based on input is a central part of flow control . Flow control refers to the controls that we build into our program that tell the computer when and how many times to execute a particular group of instructions. There are two separate parts of flow control: conditionals, which tell the computer to execute instructions based on a set of conditions, and iterators or loops, which tell the computer to execute instructions while a particular condition is true or for a particular number of times. In this chapter, we'll look at the first. In the next chapter we'll look at the second.","title":"Introduction to Flow Control"},{"location":"ch5/#conditionals-an-example","text":"To set the stage, let's say my user wants to figure out if one number is a factor of another number. A number is a factor if the second number can be divided evenly by the first. So, 4 is a factor of 12 because 12 can be evenly divided by 4. Programming languages give us the % (mod) operator to help us out with that. So let me write the program. It will prompt the user for two numbers. It will print \"x is a factor of y\" if the second number is a factor, and \"Is not a factor\" if not. mult = int(input(\"What is the multiple? \")) fact = int(input(\"What is the factor to check? \")) if mult % fact == 0: print(\"{} is a factor of {}\".format(fact, mult)) else: print(\"{} is NOT a factor of {}\".format(fact, mult)) When we run this program from our bash terminal we get something like this: ~$ python factor.py What is the multiple? 12 What is the factor to check? 4 4 is a factor of 12 ~$ Then we can run it again with something we know should be false: ~$ python factor.py What is the multiple? 12 What is the factor to check? 5 5 is NOT a factor of 12 ~$ What's going on here? On our first two lines, we're prompting the user for input and storing those values to two separate variables. Then we use an \"if\" statement to check to see if the remainder of multi / fact is zero. If this is true, then we execute the code on the next line (line 5). Otherwise, we skip down to the \"else\" statement and execute that instruction. We can see, then, the first time we run the code, 12 / 4 has a remainder of 0, so the condition in the \"if\" statement is True. So you see the appropriate instruction is executed. On the other hand, in the second run of our code, 12 / 5 does have a remainder that is not equal to zero (it is equal to 2 specifically). As a result, the statement evaluates to False and we do not execute the code within the \"if\" block. Instead, we go down to the \"else\" and execute that code instead. Notice the instructions on the lines after if and else are indented one level. This signifies to the Python interpreter that they are part of the if or else block. A code block is a collection of code that only gets executed if some condition is met. In this case, the if block only gets executed when the condition we defined for if is True. Otherwise, the else block is executed. Regardless of the input (as long as it is valid input), either the if block will execute or the else block, but never both. We can also set up conditions with only an if block. Let's say we want a program to print \"Happy Birthday\" on a user's Birthday and not print anything else if it is not. That code would look like this: BIRTHDAY = \"05/02\" today = input(\"What is the date today (mm/dd)? \") if BIRTHDAY == today: print(\"Happy Birthday!\") Once again, I'll show you what it looks like when we run this code: ~$ python birthday.py What is the date today (mm/dd)? 05/02 Happy Birthday! ~$ python birthday.py What is the date today (mm/dd)? 03/12 ~$ I set BIRTHDAY as a constant value. Then the program prompts the user for the date with a hint at the format. I check to see if what the user entered matches or is equal to the value stored in BIRTHDAY . If it is, then the program prints \"Happy Birthday!\" and if it is not, then it does nothing. Once again, I show you what that looks like when we run the program in both cases. Sometimes it is useful to have code that only runs when a condition is satisfied. We can also use negative conditions, so if we wanted to congratulate the user that it's not their birthday, we'd need to change our condition to be if BIRTHDAY != today: . Finally, we can set a series of conditions. Perhaps we want to help someone who is trying to decide whether to wear a jacket or not based on the temperature: temp = int(input(\"What is the temperature? \")) if temp > 70: print(\"Wear Shorts\") elif temp > 50: print(\"Pants and a wind breaker\") elif temp > 40: print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") In the above example, we have 4 conditions: warmer than 70 degrees, warmer than 50 degrees, warmer than 40 degrees, or colder than 40 degrees. This leads us to a cool design decision. In the if/elif/else or if/else structure only one of the blocks will be executed. Specifically, the first time the condition is True, the corresponding block is executed and the rest are skipped. So, in the above example, if the user inputs 75, only the first block will execute. It is true that 75 is also greater than 50 and 40, but Python stops at the first True condition and once we have a True condition none of the other blocks are executed. As a design decision, this allows us to check for warmer than 70, 50, and 40 without having to say elif temp > 50 and temp <= 70: for the second condition. We know that if the Python interpreter is even evaluating that condition, then the first condition failed and the temperature is 70 or less. The else acts as a fall through condition. If none of the specific cases is True, then the else block is executed. As you design your conditionals, you will find clever ways to short circuit the way you test truthiness that can make your code more efficient. Related to this, we can also test multiple conditions at the same time. For example, let's take our code from the last example and add a prompt for the rain. temp = int(input(\"What is the temperature? \")) rain = input(\"Are you expecting it to precipitate?(y/n) \") if temp > 70 and rain == \"n\": print(\"Wear Shorts\") elif temp > 50 and rain == \"n\": print(\"Pants and a wind breaker\") elif temp > 40 or rain == \"y\": print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") You can see that we are testing two conditions each time. In the first two cases we use the key word and which means that the whole test or condition is True if--and only if--both conditions are true. In the third case, we use the key word or which means that at least one of the conditions must evaluate to True. So if it is warmer than 40 or it's raining or both, the code block is executed. There are other logical operators that can be used but mainly if we are testing truthiness for bits. I'll have a section at the end of this chapter discussing bitwise operations, but you can skip it if you're not interested. Finally, we can \"nest\" our conditions within conditions. Sometimes this is more efficient than having a bunch of conditions with multiple logic tests. For example, I might like to refactor my code again so there are fewer logic tests: temp = int(input(\"What is the temperature? \")) rain = input(\"Are you expecting it to precipitate?(y/n) \") if rain == \"y\": print(\"Maybe a raincoat\") else: if temp > 70: print(\"Wear Shorts\") elif temp > 50: print(\"Pants and a wind breaker\") elif temp > 40: print(\"Maybe a jacket?\") else: print(\"Bundle up, it's cold!\") You hopefully notice that there are several different ways to do things. Generally the way that is the most clear is the best in Python. In this case, we know that regardless, if it is raining, the program should tell the user to wear a raincoat, so there's no point in wasting the processing power checking the rest of the conditions. We simply short circuit the if/else structure if it happens to be raining. Now that you have a sense of these structures, I'm going to talk a bit about Booleans.","title":"Conditionals: An example"},{"location":"ch5/#booleans","text":"Booleans are a primitive data type that is either True or False. Whenever we use a conditional, the condition returns a True or a False value. So 9 == 10 in Python asks the interpreter to assess whether nine equals ten. Obviously, this is not true so Python will return False. This is a particular type of data and False is not the same as the string \"False\". This data type is important to understand because it is the fundamental operation of the computer. At the level of the hardware, all of the operations of the computer are computed through boolean logic comparing binary bits. We can manipulate bits directly with Python using bitwise operators, and frequently the operation is much faster, but for our purposes here, we're not going to worry too much about that. Instead, we're going to focus on True and False and expressions that evaluate to True and False. True and False are the primitive data type for booleans, but other things can be evaluated by True and False through Truthiness tests. Here is a table of some examples: Expression Boolean True True False False 1 == 1 True 1 == 2 False 1 != 2 True \"\" False (empty strings are false) \"a\" True 0 False 1 True 8 > 6 True And so on. As you design your programs and work with control, you will write code that evaluates conditions. These conditions will evaluate to True or False, and the code will execute the block that corresponds to the passing test. The key take away besides the syntax is to recognize that you'll want to spend some time thinking about what conditions you want to evaluate and then what should happen when those conditions evaluate to a certain boolean value.","title":"Booleans"}]}